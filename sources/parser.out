Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> stmt
Rule 2     program -> stmt program
Rule 3     stmt -> simple_stmt
Rule 4     stmt -> compound_stmt
Rule 5     simple_stmt -> small_stmt END_STATEMENT
Rule 6     small_stmt -> assignment
Rule 7     small_stmt -> const_decl
Rule 8     small_stmt -> expr
Rule 9     small_stmt -> return_stmt
Rule 10    small_stmt -> loop_stmt
Rule 11    return_stmt -> RETURN
Rule 12    return_stmt -> RETURN expr
Rule 13    return_stmt -> RETURN boolean
Rule 14    loop_stmt -> BREAK
Rule 15    loop_stmt -> CONTINUE
Rule 16    assignment -> IDENTIFIER ASSIGN expr
Rule 17    assignment -> IDENTIFIER ASSIGN boolean
Rule 18    assignment -> ARRAY_CELL ASSIGN expr
Rule 19    assignment -> ARRAY_CELL ASSIGN boolean
Rule 20    const_decl -> IDENTIFIER CONST expr
Rule 21    func_call -> IDENTIFIER LPAREN call_args RPAREN
Rule 22    func_call -> IDENTIFIER LPAREN RPAREN
Rule 23    call_args -> arg
Rule 24    call_args -> arg COMMA call_args
Rule 25    arg -> expr
Rule 26    expr -> IDENTIFIER
Rule 27    expr -> ARRAY_CELL
Rule 28    expr -> func_call
Rule 29    expr -> arithmetic
Rule 30    expr -> cond_list
Rule 31    expr -> LPAREN expr RPAREN
Rule 32    expr -> INTEGER
Rule 33    expr -> DOUBLE
Rule 34    boolean -> TRUE
Rule 35    boolean -> FALSE
Rule 36    arithmetic -> expr ADD_OP expr
Rule 37    arithmetic -> expr SUB_OP expr
Rule 38    arithmetic -> expr MUL_OP expr
Rule 39    arithmetic -> expr DIV_OP expr
Rule 40    arithmetic -> expr MOD_OP expr
Rule 41    comb_op -> OR
Rule 42    comb_op -> AND
Rule 43    comp_op -> CEQ
Rule 44    comp_op -> CNE
Rule 45    comp_op -> CLT
Rule 46    comp_op -> CLE
Rule 47    comp_op -> CGT
Rule 48    comp_op -> CGE
Rule 49    compound_stmt -> func_def
Rule 50    compound_stmt -> if_stmt
Rule 51    compound_stmt -> while_stmt
Rule 52    compound_stmt -> for_stmt
Rule 53    func_def -> head END_STATEMENT body END
Rule 54    head -> FUNCTION IDENTIFIER LPAREN p_func_def_args RPAREN COLON
Rule 55    head -> FUNCTION IDENTIFIER LPAREN RPAREN COLON
Rule 56    p_func_def_args -> IDENTIFIER
Rule 57    p_func_def_args -> IDENTIFIER COMMA p_func_def_args
Rule 58    body -> stmt
Rule 59    body -> stmt body
Rule 60    while_stmt -> WHILE cond_list COLON END_STATEMENT body END
Rule 61    cond_list -> condition
Rule 62    cond_list -> condition comb_op cond_list
Rule 63    cond_list -> LPAREN cond_list RPAREN
Rule 64    condition -> expr comp_op expr
Rule 65    condition -> boolean
Rule 66    for_stmt -> FOR IDENTIFIER IN RANGE LPAREN INTEGER COMMA INTEGER RPAREN COLON END_STATEMENT body END
Rule 67    for_stmt -> FOR IDENTIFIER IN IDENTIFIER COLON END_STATEMENT body END
Rule 68    if_stmt -> IF cond_list COLON END_STATEMENT body END
Rule 69    if_stmt -> IF cond_list COLON END_STATEMENT body END elseif_list
Rule 70    if_stmt -> IF cond_list COLON END_STATEMENT body END elseif_list ELSE COLON END_STATEMENT body END
Rule 71    if_stmt -> IF cond_list COLON END_STATEMENT body END ELSE COLON END_STATEMENT body END
Rule 72    elseif_list -> ELSEIF cond_list COLON END_STATEMENT body END
Rule 73    elseif_list -> ELSEIF cond_list COLON END_STATEMENT body END elseif_list

Terminals, with rules where they appear

ADD_OP               : 36
AND                  : 42
ARRAY_CELL           : 18 19 27
ASSIGN               : 16 17 18 19
BREAK                : 14
CEQ                  : 43
CGE                  : 48
CGT                  : 47
CLE                  : 46
CLT                  : 45
CNE                  : 44
COLON                : 54 55 60 66 67 68 69 70 70 71 71 72 73
COMMA                : 24 57 66
CONST                : 20
CONTINUE             : 15
DIV_OP               : 39
DOUBLE               : 33
ELSE                 : 70 71
ELSEIF               : 72 73
END                  : 53 60 66 67 68 69 70 70 71 71 72 73
END_STATEMENT        : 5 53 60 66 67 68 69 70 70 71 71 72 73
FALSE                : 35
FOR                  : 66 67
FUNCTION             : 54 55
IDENTIFIER           : 16 17 20 21 22 26 54 55 56 57 66 67 67
IF                   : 68 69 70 71
IN                   : 66 67
INTEGER              : 32 66 66
LPAREN               : 21 22 31 54 55 63 66
MOD_OP               : 40
MUL_OP               : 38
OR                   : 41
RANGE                : 66
RETURN               : 11 12 13
RPAREN               : 21 22 31 54 55 63 66
SUB_OP               : 37
TRUE                 : 34
WHILE                : 60
error                : 

Nonterminals, with rules where they appear

arg                  : 23 24
arithmetic           : 29
assignment           : 6
body                 : 53 59 60 66 67 68 69 70 70 71 71 72 73
boolean              : 13 17 19 65
call_args            : 21 24
comb_op              : 62
comp_op              : 64
compound_stmt        : 4
cond_list            : 30 60 62 63 68 69 70 71 72 73
condition            : 61 62
const_decl           : 7
elseif_list          : 69 70 73
expr                 : 8 12 16 18 20 25 31 36 36 37 37 38 38 39 39 40 40 64 64
for_stmt             : 52
func_call            : 28
func_def             : 49
head                 : 53
if_stmt              : 50
loop_stmt            : 10
p_func_def_args      : 54 57
program              : 2 0
return_stmt          : 9
simple_stmt          : 3
small_stmt           : 5
stmt                 : 1 2 58 59
while_stmt           : 51

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . stmt
    (2) program -> . stmt program
    (3) stmt -> . simple_stmt
    (4) stmt -> . compound_stmt
    (5) simple_stmt -> . small_stmt END_STATEMENT
    (49) compound_stmt -> . func_def
    (50) compound_stmt -> . if_stmt
    (51) compound_stmt -> . while_stmt
    (52) compound_stmt -> . for_stmt
    (6) small_stmt -> . assignment
    (7) small_stmt -> . const_decl
    (8) small_stmt -> . expr
    (9) small_stmt -> . return_stmt
    (10) small_stmt -> . loop_stmt
    (53) func_def -> . head END_STATEMENT body END
    (68) if_stmt -> . IF cond_list COLON END_STATEMENT body END
    (69) if_stmt -> . IF cond_list COLON END_STATEMENT body END elseif_list
    (70) if_stmt -> . IF cond_list COLON END_STATEMENT body END elseif_list ELSE COLON END_STATEMENT body END
    (71) if_stmt -> . IF cond_list COLON END_STATEMENT body END ELSE COLON END_STATEMENT body END
    (60) while_stmt -> . WHILE cond_list COLON END_STATEMENT body END
    (66) for_stmt -> . FOR IDENTIFIER IN RANGE LPAREN INTEGER COMMA INTEGER RPAREN COLON END_STATEMENT body END
    (67) for_stmt -> . FOR IDENTIFIER IN IDENTIFIER COLON END_STATEMENT body END
    (16) assignment -> . IDENTIFIER ASSIGN expr
    (17) assignment -> . IDENTIFIER ASSIGN boolean
    (18) assignment -> . ARRAY_CELL ASSIGN expr
    (19) assignment -> . ARRAY_CELL ASSIGN boolean
    (20) const_decl -> . IDENTIFIER CONST expr
    (26) expr -> . IDENTIFIER
    (27) expr -> . ARRAY_CELL
    (28) expr -> . func_call
    (29) expr -> . arithmetic
    (30) expr -> . cond_list
    (31) expr -> . LPAREN expr RPAREN
    (32) expr -> . INTEGER
    (33) expr -> . DOUBLE
    (11) return_stmt -> . RETURN
    (12) return_stmt -> . RETURN expr
    (13) return_stmt -> . RETURN boolean
    (14) loop_stmt -> . BREAK
    (15) loop_stmt -> . CONTINUE
    (54) head -> . FUNCTION IDENTIFIER LPAREN p_func_def_args RPAREN COLON
    (55) head -> . FUNCTION IDENTIFIER LPAREN RPAREN COLON
    (21) func_call -> . IDENTIFIER LPAREN call_args RPAREN
    (22) func_call -> . IDENTIFIER LPAREN RPAREN
    (36) arithmetic -> . expr ADD_OP expr
    (37) arithmetic -> . expr SUB_OP expr
    (38) arithmetic -> . expr MUL_OP expr
    (39) arithmetic -> . expr DIV_OP expr
    (40) arithmetic -> . expr MOD_OP expr
    (61) cond_list -> . condition
    (62) cond_list -> . condition comb_op cond_list
    (63) cond_list -> . LPAREN cond_list RPAREN
    (64) condition -> . expr comp_op expr
    (65) condition -> . boolean
    (34) boolean -> . TRUE
    (35) boolean -> . FALSE

    IF              shift and go to state 25
    WHILE           shift and go to state 3
    FOR             shift and go to state 8
    IDENTIFIER      shift and go to state 12
    ARRAY_CELL      shift and go to state 2
    LPAREN          shift and go to state 22
    INTEGER         shift and go to state 11
    DOUBLE          shift and go to state 33
    RETURN          shift and go to state 6
    BREAK           shift and go to state 30
    CONTINUE        shift and go to state 32
    FUNCTION        shift and go to state 23
    TRUE            shift and go to state 7
    FALSE           shift and go to state 27

    small_stmt                     shift and go to state 1
    boolean                        shift and go to state 4
    return_stmt                    shift and go to state 5
    const_decl                     shift and go to state 9
    program                        shift and go to state 10
    compound_stmt                  shift and go to state 13
    arithmetic                     shift and go to state 14
    head                           shift and go to state 15
    func_def                       shift and go to state 16
    simple_stmt                    shift and go to state 17
    assignment                     shift and go to state 18
    stmt                           shift and go to state 19
    for_stmt                       shift and go to state 20
    loop_stmt                      shift and go to state 21
    condition                      shift and go to state 24
    func_call                      shift and go to state 26
    if_stmt                        shift and go to state 28
    expr                           shift and go to state 29
    while_stmt                     shift and go to state 31
    cond_list                      shift and go to state 34

state 1

    (5) simple_stmt -> small_stmt . END_STATEMENT

    END_STATEMENT   shift and go to state 35


state 2

    (18) assignment -> ARRAY_CELL . ASSIGN expr
    (19) assignment -> ARRAY_CELL . ASSIGN boolean
    (27) expr -> ARRAY_CELL .

    ASSIGN          shift and go to state 36
    ADD_OP          reduce using rule 27 (expr -> ARRAY_CELL .)
    SUB_OP          reduce using rule 27 (expr -> ARRAY_CELL .)
    MUL_OP          reduce using rule 27 (expr -> ARRAY_CELL .)
    DIV_OP          reduce using rule 27 (expr -> ARRAY_CELL .)
    MOD_OP          reduce using rule 27 (expr -> ARRAY_CELL .)
    CEQ             reduce using rule 27 (expr -> ARRAY_CELL .)
    CNE             reduce using rule 27 (expr -> ARRAY_CELL .)
    CLT             reduce using rule 27 (expr -> ARRAY_CELL .)
    CLE             reduce using rule 27 (expr -> ARRAY_CELL .)
    CGT             reduce using rule 27 (expr -> ARRAY_CELL .)
    CGE             reduce using rule 27 (expr -> ARRAY_CELL .)
    END_STATEMENT   reduce using rule 27 (expr -> ARRAY_CELL .)


state 3

    (60) while_stmt -> WHILE . cond_list COLON END_STATEMENT body END
    (61) cond_list -> . condition
    (62) cond_list -> . condition comb_op cond_list
    (63) cond_list -> . LPAREN cond_list RPAREN
    (64) condition -> . expr comp_op expr
    (65) condition -> . boolean
    (26) expr -> . IDENTIFIER
    (27) expr -> . ARRAY_CELL
    (28) expr -> . func_call
    (29) expr -> . arithmetic
    (30) expr -> . cond_list
    (31) expr -> . LPAREN expr RPAREN
    (32) expr -> . INTEGER
    (33) expr -> . DOUBLE
    (34) boolean -> . TRUE
    (35) boolean -> . FALSE
    (21) func_call -> . IDENTIFIER LPAREN call_args RPAREN
    (22) func_call -> . IDENTIFIER LPAREN RPAREN
    (36) arithmetic -> . expr ADD_OP expr
    (37) arithmetic -> . expr SUB_OP expr
    (38) arithmetic -> . expr MUL_OP expr
    (39) arithmetic -> . expr DIV_OP expr
    (40) arithmetic -> . expr MOD_OP expr

    LPAREN          shift and go to state 39
    IDENTIFIER      shift and go to state 38
    ARRAY_CELL      shift and go to state 37
    INTEGER         shift and go to state 11
    DOUBLE          shift and go to state 33
    TRUE            shift and go to state 7
    FALSE           shift and go to state 27

    func_call                      shift and go to state 26
    expr                           shift and go to state 40
    boolean                        shift and go to state 4
    arithmetic                     shift and go to state 14
    cond_list                      shift and go to state 41
    condition                      shift and go to state 24

state 4

    (65) condition -> boolean .

    OR              reduce using rule 65 (condition -> boolean .)
    AND             reduce using rule 65 (condition -> boolean .)
    ADD_OP          reduce using rule 65 (condition -> boolean .)
    SUB_OP          reduce using rule 65 (condition -> boolean .)
    MUL_OP          reduce using rule 65 (condition -> boolean .)
    DIV_OP          reduce using rule 65 (condition -> boolean .)
    MOD_OP          reduce using rule 65 (condition -> boolean .)
    CEQ             reduce using rule 65 (condition -> boolean .)
    CNE             reduce using rule 65 (condition -> boolean .)
    CLT             reduce using rule 65 (condition -> boolean .)
    CLE             reduce using rule 65 (condition -> boolean .)
    CGT             reduce using rule 65 (condition -> boolean .)
    CGE             reduce using rule 65 (condition -> boolean .)
    END_STATEMENT   reduce using rule 65 (condition -> boolean .)
    COLON           reduce using rule 65 (condition -> boolean .)
    RPAREN          reduce using rule 65 (condition -> boolean .)
    COMMA           reduce using rule 65 (condition -> boolean .)


state 5

    (9) small_stmt -> return_stmt .

    END_STATEMENT   reduce using rule 9 (small_stmt -> return_stmt .)


state 6

    (11) return_stmt -> RETURN .
    (12) return_stmt -> RETURN . expr
    (13) return_stmt -> RETURN . boolean
    (26) expr -> . IDENTIFIER
    (27) expr -> . ARRAY_CELL
    (28) expr -> . func_call
    (29) expr -> . arithmetic
    (30) expr -> . cond_list
    (31) expr -> . LPAREN expr RPAREN
    (32) expr -> . INTEGER
    (33) expr -> . DOUBLE
    (34) boolean -> . TRUE
    (35) boolean -> . FALSE
    (21) func_call -> . IDENTIFIER LPAREN call_args RPAREN
    (22) func_call -> . IDENTIFIER LPAREN RPAREN
    (36) arithmetic -> . expr ADD_OP expr
    (37) arithmetic -> . expr SUB_OP expr
    (38) arithmetic -> . expr MUL_OP expr
    (39) arithmetic -> . expr DIV_OP expr
    (40) arithmetic -> . expr MOD_OP expr
    (61) cond_list -> . condition
    (62) cond_list -> . condition comb_op cond_list
    (63) cond_list -> . LPAREN cond_list RPAREN
    (64) condition -> . expr comp_op expr
    (65) condition -> . boolean

    END_STATEMENT   reduce using rule 11 (return_stmt -> RETURN .)
    IDENTIFIER      shift and go to state 38
    ARRAY_CELL      shift and go to state 37
    LPAREN          shift and go to state 22
    INTEGER         shift and go to state 11
    DOUBLE          shift and go to state 33
    TRUE            shift and go to state 7
    FALSE           shift and go to state 27

    func_call                      shift and go to state 26
    expr                           shift and go to state 43
    condition                      shift and go to state 24
    boolean                        shift and go to state 42
    cond_list                      shift and go to state 34
    arithmetic                     shift and go to state 14

state 7

    (34) boolean -> TRUE .

    OR              reduce using rule 34 (boolean -> TRUE .)
    AND             reduce using rule 34 (boolean -> TRUE .)
    RPAREN          reduce using rule 34 (boolean -> TRUE .)
    ADD_OP          reduce using rule 34 (boolean -> TRUE .)
    SUB_OP          reduce using rule 34 (boolean -> TRUE .)
    MUL_OP          reduce using rule 34 (boolean -> TRUE .)
    DIV_OP          reduce using rule 34 (boolean -> TRUE .)
    MOD_OP          reduce using rule 34 (boolean -> TRUE .)
    CEQ             reduce using rule 34 (boolean -> TRUE .)
    CNE             reduce using rule 34 (boolean -> TRUE .)
    CLT             reduce using rule 34 (boolean -> TRUE .)
    CLE             reduce using rule 34 (boolean -> TRUE .)
    CGT             reduce using rule 34 (boolean -> TRUE .)
    CGE             reduce using rule 34 (boolean -> TRUE .)
    END_STATEMENT   reduce using rule 34 (boolean -> TRUE .)
    COLON           reduce using rule 34 (boolean -> TRUE .)
    COMMA           reduce using rule 34 (boolean -> TRUE .)


state 8

    (66) for_stmt -> FOR . IDENTIFIER IN RANGE LPAREN INTEGER COMMA INTEGER RPAREN COLON END_STATEMENT body END
    (67) for_stmt -> FOR . IDENTIFIER IN IDENTIFIER COLON END_STATEMENT body END

    IDENTIFIER      shift and go to state 44


state 9

    (7) small_stmt -> const_decl .

    END_STATEMENT   reduce using rule 7 (small_stmt -> const_decl .)


state 10

    (0) S' -> program .



state 11

    (32) expr -> INTEGER .

    ADD_OP          reduce using rule 32 (expr -> INTEGER .)
    SUB_OP          reduce using rule 32 (expr -> INTEGER .)
    MUL_OP          reduce using rule 32 (expr -> INTEGER .)
    DIV_OP          reduce using rule 32 (expr -> INTEGER .)
    MOD_OP          reduce using rule 32 (expr -> INTEGER .)
    CEQ             reduce using rule 32 (expr -> INTEGER .)
    CNE             reduce using rule 32 (expr -> INTEGER .)
    CLT             reduce using rule 32 (expr -> INTEGER .)
    CLE             reduce using rule 32 (expr -> INTEGER .)
    CGT             reduce using rule 32 (expr -> INTEGER .)
    CGE             reduce using rule 32 (expr -> INTEGER .)
    END_STATEMENT   reduce using rule 32 (expr -> INTEGER .)
    COLON           reduce using rule 32 (expr -> INTEGER .)
    RPAREN          reduce using rule 32 (expr -> INTEGER .)
    COMMA           reduce using rule 32 (expr -> INTEGER .)
    OR              reduce using rule 32 (expr -> INTEGER .)
    AND             reduce using rule 32 (expr -> INTEGER .)


state 12

    (16) assignment -> IDENTIFIER . ASSIGN expr
    (17) assignment -> IDENTIFIER . ASSIGN boolean
    (20) const_decl -> IDENTIFIER . CONST expr
    (26) expr -> IDENTIFIER .
    (21) func_call -> IDENTIFIER . LPAREN call_args RPAREN
    (22) func_call -> IDENTIFIER . LPAREN RPAREN

    ASSIGN          shift and go to state 47
    CONST           shift and go to state 45
    ADD_OP          reduce using rule 26 (expr -> IDENTIFIER .)
    SUB_OP          reduce using rule 26 (expr -> IDENTIFIER .)
    MUL_OP          reduce using rule 26 (expr -> IDENTIFIER .)
    DIV_OP          reduce using rule 26 (expr -> IDENTIFIER .)
    MOD_OP          reduce using rule 26 (expr -> IDENTIFIER .)
    CEQ             reduce using rule 26 (expr -> IDENTIFIER .)
    CNE             reduce using rule 26 (expr -> IDENTIFIER .)
    CLT             reduce using rule 26 (expr -> IDENTIFIER .)
    CLE             reduce using rule 26 (expr -> IDENTIFIER .)
    CGT             reduce using rule 26 (expr -> IDENTIFIER .)
    CGE             reduce using rule 26 (expr -> IDENTIFIER .)
    END_STATEMENT   reduce using rule 26 (expr -> IDENTIFIER .)
    LPAREN          shift and go to state 46


state 13

    (4) stmt -> compound_stmt .

    IF              reduce using rule 4 (stmt -> compound_stmt .)
    WHILE           reduce using rule 4 (stmt -> compound_stmt .)
    FOR             reduce using rule 4 (stmt -> compound_stmt .)
    IDENTIFIER      reduce using rule 4 (stmt -> compound_stmt .)
    ARRAY_CELL      reduce using rule 4 (stmt -> compound_stmt .)
    LPAREN          reduce using rule 4 (stmt -> compound_stmt .)
    INTEGER         reduce using rule 4 (stmt -> compound_stmt .)
    DOUBLE          reduce using rule 4 (stmt -> compound_stmt .)
    RETURN          reduce using rule 4 (stmt -> compound_stmt .)
    BREAK           reduce using rule 4 (stmt -> compound_stmt .)
    CONTINUE        reduce using rule 4 (stmt -> compound_stmt .)
    FUNCTION        reduce using rule 4 (stmt -> compound_stmt .)
    TRUE            reduce using rule 4 (stmt -> compound_stmt .)
    FALSE           reduce using rule 4 (stmt -> compound_stmt .)
    END             reduce using rule 4 (stmt -> compound_stmt .)
    $end            reduce using rule 4 (stmt -> compound_stmt .)


state 14

    (29) expr -> arithmetic .

    ADD_OP          reduce using rule 29 (expr -> arithmetic .)
    SUB_OP          reduce using rule 29 (expr -> arithmetic .)
    MUL_OP          reduce using rule 29 (expr -> arithmetic .)
    DIV_OP          reduce using rule 29 (expr -> arithmetic .)
    MOD_OP          reduce using rule 29 (expr -> arithmetic .)
    CEQ             reduce using rule 29 (expr -> arithmetic .)
    CNE             reduce using rule 29 (expr -> arithmetic .)
    CLT             reduce using rule 29 (expr -> arithmetic .)
    CLE             reduce using rule 29 (expr -> arithmetic .)
    CGT             reduce using rule 29 (expr -> arithmetic .)
    CGE             reduce using rule 29 (expr -> arithmetic .)
    END_STATEMENT   reduce using rule 29 (expr -> arithmetic .)
    COLON           reduce using rule 29 (expr -> arithmetic .)
    RPAREN          reduce using rule 29 (expr -> arithmetic .)
    COMMA           reduce using rule 29 (expr -> arithmetic .)
    OR              reduce using rule 29 (expr -> arithmetic .)
    AND             reduce using rule 29 (expr -> arithmetic .)


state 15

    (53) func_def -> head . END_STATEMENT body END

    END_STATEMENT   shift and go to state 48


state 16

    (49) compound_stmt -> func_def .

    IF              reduce using rule 49 (compound_stmt -> func_def .)
    WHILE           reduce using rule 49 (compound_stmt -> func_def .)
    FOR             reduce using rule 49 (compound_stmt -> func_def .)
    IDENTIFIER      reduce using rule 49 (compound_stmt -> func_def .)
    ARRAY_CELL      reduce using rule 49 (compound_stmt -> func_def .)
    LPAREN          reduce using rule 49 (compound_stmt -> func_def .)
    INTEGER         reduce using rule 49 (compound_stmt -> func_def .)
    DOUBLE          reduce using rule 49 (compound_stmt -> func_def .)
    RETURN          reduce using rule 49 (compound_stmt -> func_def .)
    BREAK           reduce using rule 49 (compound_stmt -> func_def .)
    CONTINUE        reduce using rule 49 (compound_stmt -> func_def .)
    FUNCTION        reduce using rule 49 (compound_stmt -> func_def .)
    TRUE            reduce using rule 49 (compound_stmt -> func_def .)
    FALSE           reduce using rule 49 (compound_stmt -> func_def .)
    $end            reduce using rule 49 (compound_stmt -> func_def .)
    END             reduce using rule 49 (compound_stmt -> func_def .)


state 17

    (3) stmt -> simple_stmt .

    IF              reduce using rule 3 (stmt -> simple_stmt .)
    WHILE           reduce using rule 3 (stmt -> simple_stmt .)
    FOR             reduce using rule 3 (stmt -> simple_stmt .)
    IDENTIFIER      reduce using rule 3 (stmt -> simple_stmt .)
    ARRAY_CELL      reduce using rule 3 (stmt -> simple_stmt .)
    LPAREN          reduce using rule 3 (stmt -> simple_stmt .)
    INTEGER         reduce using rule 3 (stmt -> simple_stmt .)
    DOUBLE          reduce using rule 3 (stmt -> simple_stmt .)
    RETURN          reduce using rule 3 (stmt -> simple_stmt .)
    BREAK           reduce using rule 3 (stmt -> simple_stmt .)
    CONTINUE        reduce using rule 3 (stmt -> simple_stmt .)
    FUNCTION        reduce using rule 3 (stmt -> simple_stmt .)
    TRUE            reduce using rule 3 (stmt -> simple_stmt .)
    FALSE           reduce using rule 3 (stmt -> simple_stmt .)
    END             reduce using rule 3 (stmt -> simple_stmt .)
    $end            reduce using rule 3 (stmt -> simple_stmt .)


state 18

    (6) small_stmt -> assignment .

    END_STATEMENT   reduce using rule 6 (small_stmt -> assignment .)


state 19

    (1) program -> stmt .
    (2) program -> stmt . program
    (1) program -> . stmt
    (2) program -> . stmt program
    (3) stmt -> . simple_stmt
    (4) stmt -> . compound_stmt
    (5) simple_stmt -> . small_stmt END_STATEMENT
    (49) compound_stmt -> . func_def
    (50) compound_stmt -> . if_stmt
    (51) compound_stmt -> . while_stmt
    (52) compound_stmt -> . for_stmt
    (6) small_stmt -> . assignment
    (7) small_stmt -> . const_decl
    (8) small_stmt -> . expr
    (9) small_stmt -> . return_stmt
    (10) small_stmt -> . loop_stmt
    (53) func_def -> . head END_STATEMENT body END
    (68) if_stmt -> . IF cond_list COLON END_STATEMENT body END
    (69) if_stmt -> . IF cond_list COLON END_STATEMENT body END elseif_list
    (70) if_stmt -> . IF cond_list COLON END_STATEMENT body END elseif_list ELSE COLON END_STATEMENT body END
    (71) if_stmt -> . IF cond_list COLON END_STATEMENT body END ELSE COLON END_STATEMENT body END
    (60) while_stmt -> . WHILE cond_list COLON END_STATEMENT body END
    (66) for_stmt -> . FOR IDENTIFIER IN RANGE LPAREN INTEGER COMMA INTEGER RPAREN COLON END_STATEMENT body END
    (67) for_stmt -> . FOR IDENTIFIER IN IDENTIFIER COLON END_STATEMENT body END
    (16) assignment -> . IDENTIFIER ASSIGN expr
    (17) assignment -> . IDENTIFIER ASSIGN boolean
    (18) assignment -> . ARRAY_CELL ASSIGN expr
    (19) assignment -> . ARRAY_CELL ASSIGN boolean
    (20) const_decl -> . IDENTIFIER CONST expr
    (26) expr -> . IDENTIFIER
    (27) expr -> . ARRAY_CELL
    (28) expr -> . func_call
    (29) expr -> . arithmetic
    (30) expr -> . cond_list
    (31) expr -> . LPAREN expr RPAREN
    (32) expr -> . INTEGER
    (33) expr -> . DOUBLE
    (11) return_stmt -> . RETURN
    (12) return_stmt -> . RETURN expr
    (13) return_stmt -> . RETURN boolean
    (14) loop_stmt -> . BREAK
    (15) loop_stmt -> . CONTINUE
    (54) head -> . FUNCTION IDENTIFIER LPAREN p_func_def_args RPAREN COLON
    (55) head -> . FUNCTION IDENTIFIER LPAREN RPAREN COLON
    (21) func_call -> . IDENTIFIER LPAREN call_args RPAREN
    (22) func_call -> . IDENTIFIER LPAREN RPAREN
    (36) arithmetic -> . expr ADD_OP expr
    (37) arithmetic -> . expr SUB_OP expr
    (38) arithmetic -> . expr MUL_OP expr
    (39) arithmetic -> . expr DIV_OP expr
    (40) arithmetic -> . expr MOD_OP expr
    (61) cond_list -> . condition
    (62) cond_list -> . condition comb_op cond_list
    (63) cond_list -> . LPAREN cond_list RPAREN
    (64) condition -> . expr comp_op expr
    (65) condition -> . boolean
    (34) boolean -> . TRUE
    (35) boolean -> . FALSE

    $end            reduce using rule 1 (program -> stmt .)
    IF              shift and go to state 25
    WHILE           shift and go to state 3
    FOR             shift and go to state 8
    IDENTIFIER      shift and go to state 12
    ARRAY_CELL      shift and go to state 2
    LPAREN          shift and go to state 22
    INTEGER         shift and go to state 11
    DOUBLE          shift and go to state 33
    RETURN          shift and go to state 6
    BREAK           shift and go to state 30
    CONTINUE        shift and go to state 32
    FUNCTION        shift and go to state 23
    TRUE            shift and go to state 7
    FALSE           shift and go to state 27

    small_stmt                     shift and go to state 1
    boolean                        shift and go to state 4
    return_stmt                    shift and go to state 5
    const_decl                     shift and go to state 9
    program                        shift and go to state 49
    compound_stmt                  shift and go to state 13
    arithmetic                     shift and go to state 14
    head                           shift and go to state 15
    func_def                       shift and go to state 16
    simple_stmt                    shift and go to state 17
    assignment                     shift and go to state 18
    stmt                           shift and go to state 19
    for_stmt                       shift and go to state 20
    loop_stmt                      shift and go to state 21
    condition                      shift and go to state 24
    func_call                      shift and go to state 26
    if_stmt                        shift and go to state 28
    expr                           shift and go to state 29
    while_stmt                     shift and go to state 31
    cond_list                      shift and go to state 34

state 20

    (52) compound_stmt -> for_stmt .

    IF              reduce using rule 52 (compound_stmt -> for_stmt .)
    WHILE           reduce using rule 52 (compound_stmt -> for_stmt .)
    FOR             reduce using rule 52 (compound_stmt -> for_stmt .)
    IDENTIFIER      reduce using rule 52 (compound_stmt -> for_stmt .)
    ARRAY_CELL      reduce using rule 52 (compound_stmt -> for_stmt .)
    LPAREN          reduce using rule 52 (compound_stmt -> for_stmt .)
    INTEGER         reduce using rule 52 (compound_stmt -> for_stmt .)
    DOUBLE          reduce using rule 52 (compound_stmt -> for_stmt .)
    RETURN          reduce using rule 52 (compound_stmt -> for_stmt .)
    BREAK           reduce using rule 52 (compound_stmt -> for_stmt .)
    CONTINUE        reduce using rule 52 (compound_stmt -> for_stmt .)
    FUNCTION        reduce using rule 52 (compound_stmt -> for_stmt .)
    TRUE            reduce using rule 52 (compound_stmt -> for_stmt .)
    FALSE           reduce using rule 52 (compound_stmt -> for_stmt .)
    $end            reduce using rule 52 (compound_stmt -> for_stmt .)
    END             reduce using rule 52 (compound_stmt -> for_stmt .)


state 21

    (10) small_stmt -> loop_stmt .

    END_STATEMENT   reduce using rule 10 (small_stmt -> loop_stmt .)


state 22

    (31) expr -> LPAREN . expr RPAREN
    (63) cond_list -> LPAREN . cond_list RPAREN
    (26) expr -> . IDENTIFIER
    (27) expr -> . ARRAY_CELL
    (28) expr -> . func_call
    (29) expr -> . arithmetic
    (30) expr -> . cond_list
    (31) expr -> . LPAREN expr RPAREN
    (32) expr -> . INTEGER
    (33) expr -> . DOUBLE
    (61) cond_list -> . condition
    (62) cond_list -> . condition comb_op cond_list
    (63) cond_list -> . LPAREN cond_list RPAREN
    (21) func_call -> . IDENTIFIER LPAREN call_args RPAREN
    (22) func_call -> . IDENTIFIER LPAREN RPAREN
    (36) arithmetic -> . expr ADD_OP expr
    (37) arithmetic -> . expr SUB_OP expr
    (38) arithmetic -> . expr MUL_OP expr
    (39) arithmetic -> . expr DIV_OP expr
    (40) arithmetic -> . expr MOD_OP expr
    (64) condition -> . expr comp_op expr
    (65) condition -> . boolean
    (34) boolean -> . TRUE
    (35) boolean -> . FALSE

    IDENTIFIER      shift and go to state 38
    ARRAY_CELL      shift and go to state 37
    LPAREN          shift and go to state 22
    INTEGER         shift and go to state 11
    DOUBLE          shift and go to state 33
    TRUE            shift and go to state 7
    FALSE           shift and go to state 27

    func_call                      shift and go to state 26
    expr                           shift and go to state 50
    boolean                        shift and go to state 4
    arithmetic                     shift and go to state 14
    cond_list                      shift and go to state 51
    condition                      shift and go to state 24

state 23

    (54) head -> FUNCTION . IDENTIFIER LPAREN p_func_def_args RPAREN COLON
    (55) head -> FUNCTION . IDENTIFIER LPAREN RPAREN COLON

    IDENTIFIER      shift and go to state 52


state 24

    (61) cond_list -> condition .
    (62) cond_list -> condition . comb_op cond_list
    (41) comb_op -> . OR
    (42) comb_op -> . AND

  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
    ADD_OP          reduce using rule 61 (cond_list -> condition .)
    SUB_OP          reduce using rule 61 (cond_list -> condition .)
    MUL_OP          reduce using rule 61 (cond_list -> condition .)
    DIV_OP          reduce using rule 61 (cond_list -> condition .)
    MOD_OP          reduce using rule 61 (cond_list -> condition .)
    CEQ             reduce using rule 61 (cond_list -> condition .)
    CNE             reduce using rule 61 (cond_list -> condition .)
    CLT             reduce using rule 61 (cond_list -> condition .)
    CLE             reduce using rule 61 (cond_list -> condition .)
    CGT             reduce using rule 61 (cond_list -> condition .)
    CGE             reduce using rule 61 (cond_list -> condition .)
    END_STATEMENT   reduce using rule 61 (cond_list -> condition .)
    COLON           reduce using rule 61 (cond_list -> condition .)
    RPAREN          reduce using rule 61 (cond_list -> condition .)
    COMMA           reduce using rule 61 (cond_list -> condition .)
    OR              shift and go to state 55
    AND             shift and go to state 53

  ! OR              [ reduce using rule 61 (cond_list -> condition .) ]
  ! AND             [ reduce using rule 61 (cond_list -> condition .) ]

    comb_op                        shift and go to state 54

state 25

    (68) if_stmt -> IF . cond_list COLON END_STATEMENT body END
    (69) if_stmt -> IF . cond_list COLON END_STATEMENT body END elseif_list
    (70) if_stmt -> IF . cond_list COLON END_STATEMENT body END elseif_list ELSE COLON END_STATEMENT body END
    (71) if_stmt -> IF . cond_list COLON END_STATEMENT body END ELSE COLON END_STATEMENT body END
    (61) cond_list -> . condition
    (62) cond_list -> . condition comb_op cond_list
    (63) cond_list -> . LPAREN cond_list RPAREN
    (64) condition -> . expr comp_op expr
    (65) condition -> . boolean
    (26) expr -> . IDENTIFIER
    (27) expr -> . ARRAY_CELL
    (28) expr -> . func_call
    (29) expr -> . arithmetic
    (30) expr -> . cond_list
    (31) expr -> . LPAREN expr RPAREN
    (32) expr -> . INTEGER
    (33) expr -> . DOUBLE
    (34) boolean -> . TRUE
    (35) boolean -> . FALSE
    (21) func_call -> . IDENTIFIER LPAREN call_args RPAREN
    (22) func_call -> . IDENTIFIER LPAREN RPAREN
    (36) arithmetic -> . expr ADD_OP expr
    (37) arithmetic -> . expr SUB_OP expr
    (38) arithmetic -> . expr MUL_OP expr
    (39) arithmetic -> . expr DIV_OP expr
    (40) arithmetic -> . expr MOD_OP expr

    LPAREN          shift and go to state 39
    IDENTIFIER      shift and go to state 38
    ARRAY_CELL      shift and go to state 37
    INTEGER         shift and go to state 11
    DOUBLE          shift and go to state 33
    TRUE            shift and go to state 7
    FALSE           shift and go to state 27

    func_call                      shift and go to state 26
    expr                           shift and go to state 40
    boolean                        shift and go to state 4
    arithmetic                     shift and go to state 14
    cond_list                      shift and go to state 56
    condition                      shift and go to state 24

state 26

    (28) expr -> func_call .

    ADD_OP          reduce using rule 28 (expr -> func_call .)
    SUB_OP          reduce using rule 28 (expr -> func_call .)
    MUL_OP          reduce using rule 28 (expr -> func_call .)
    DIV_OP          reduce using rule 28 (expr -> func_call .)
    MOD_OP          reduce using rule 28 (expr -> func_call .)
    CEQ             reduce using rule 28 (expr -> func_call .)
    CNE             reduce using rule 28 (expr -> func_call .)
    CLT             reduce using rule 28 (expr -> func_call .)
    CLE             reduce using rule 28 (expr -> func_call .)
    CGT             reduce using rule 28 (expr -> func_call .)
    CGE             reduce using rule 28 (expr -> func_call .)
    END_STATEMENT   reduce using rule 28 (expr -> func_call .)
    COLON           reduce using rule 28 (expr -> func_call .)
    RPAREN          reduce using rule 28 (expr -> func_call .)
    COMMA           reduce using rule 28 (expr -> func_call .)
    OR              reduce using rule 28 (expr -> func_call .)
    AND             reduce using rule 28 (expr -> func_call .)


state 27

    (35) boolean -> FALSE .

    OR              reduce using rule 35 (boolean -> FALSE .)
    AND             reduce using rule 35 (boolean -> FALSE .)
    RPAREN          reduce using rule 35 (boolean -> FALSE .)
    ADD_OP          reduce using rule 35 (boolean -> FALSE .)
    SUB_OP          reduce using rule 35 (boolean -> FALSE .)
    MUL_OP          reduce using rule 35 (boolean -> FALSE .)
    DIV_OP          reduce using rule 35 (boolean -> FALSE .)
    MOD_OP          reduce using rule 35 (boolean -> FALSE .)
    CEQ             reduce using rule 35 (boolean -> FALSE .)
    CNE             reduce using rule 35 (boolean -> FALSE .)
    CLT             reduce using rule 35 (boolean -> FALSE .)
    CLE             reduce using rule 35 (boolean -> FALSE .)
    CGT             reduce using rule 35 (boolean -> FALSE .)
    CGE             reduce using rule 35 (boolean -> FALSE .)
    END_STATEMENT   reduce using rule 35 (boolean -> FALSE .)
    COLON           reduce using rule 35 (boolean -> FALSE .)
    COMMA           reduce using rule 35 (boolean -> FALSE .)


state 28

    (50) compound_stmt -> if_stmt .

    IF              reduce using rule 50 (compound_stmt -> if_stmt .)
    WHILE           reduce using rule 50 (compound_stmt -> if_stmt .)
    FOR             reduce using rule 50 (compound_stmt -> if_stmt .)
    IDENTIFIER      reduce using rule 50 (compound_stmt -> if_stmt .)
    ARRAY_CELL      reduce using rule 50 (compound_stmt -> if_stmt .)
    LPAREN          reduce using rule 50 (compound_stmt -> if_stmt .)
    INTEGER         reduce using rule 50 (compound_stmt -> if_stmt .)
    DOUBLE          reduce using rule 50 (compound_stmt -> if_stmt .)
    RETURN          reduce using rule 50 (compound_stmt -> if_stmt .)
    BREAK           reduce using rule 50 (compound_stmt -> if_stmt .)
    CONTINUE        reduce using rule 50 (compound_stmt -> if_stmt .)
    FUNCTION        reduce using rule 50 (compound_stmt -> if_stmt .)
    TRUE            reduce using rule 50 (compound_stmt -> if_stmt .)
    FALSE           reduce using rule 50 (compound_stmt -> if_stmt .)
    $end            reduce using rule 50 (compound_stmt -> if_stmt .)
    END             reduce using rule 50 (compound_stmt -> if_stmt .)


state 29

    (8) small_stmt -> expr .
    (36) arithmetic -> expr . ADD_OP expr
    (37) arithmetic -> expr . SUB_OP expr
    (38) arithmetic -> expr . MUL_OP expr
    (39) arithmetic -> expr . DIV_OP expr
    (40) arithmetic -> expr . MOD_OP expr
    (64) condition -> expr . comp_op expr
    (43) comp_op -> . CEQ
    (44) comp_op -> . CNE
    (45) comp_op -> . CLT
    (46) comp_op -> . CLE
    (47) comp_op -> . CGT
    (48) comp_op -> . CGE

    END_STATEMENT   reduce using rule 8 (small_stmt -> expr .)
    ADD_OP          shift and go to state 65
    SUB_OP          shift and go to state 61
    MUL_OP          shift and go to state 58
    DIV_OP          shift and go to state 62
    MOD_OP          shift and go to state 67
    CEQ             shift and go to state 64
    CNE             shift and go to state 63
    CLT             shift and go to state 66
    CLE             shift and go to state 57
    CGT             shift and go to state 68
    CGE             shift and go to state 59

    comp_op                        shift and go to state 60

state 30

    (14) loop_stmt -> BREAK .

    END_STATEMENT   reduce using rule 14 (loop_stmt -> BREAK .)


state 31

    (51) compound_stmt -> while_stmt .

    IF              reduce using rule 51 (compound_stmt -> while_stmt .)
    WHILE           reduce using rule 51 (compound_stmt -> while_stmt .)
    FOR             reduce using rule 51 (compound_stmt -> while_stmt .)
    IDENTIFIER      reduce using rule 51 (compound_stmt -> while_stmt .)
    ARRAY_CELL      reduce using rule 51 (compound_stmt -> while_stmt .)
    LPAREN          reduce using rule 51 (compound_stmt -> while_stmt .)
    INTEGER         reduce using rule 51 (compound_stmt -> while_stmt .)
    DOUBLE          reduce using rule 51 (compound_stmt -> while_stmt .)
    RETURN          reduce using rule 51 (compound_stmt -> while_stmt .)
    BREAK           reduce using rule 51 (compound_stmt -> while_stmt .)
    CONTINUE        reduce using rule 51 (compound_stmt -> while_stmt .)
    FUNCTION        reduce using rule 51 (compound_stmt -> while_stmt .)
    TRUE            reduce using rule 51 (compound_stmt -> while_stmt .)
    FALSE           reduce using rule 51 (compound_stmt -> while_stmt .)
    $end            reduce using rule 51 (compound_stmt -> while_stmt .)
    END             reduce using rule 51 (compound_stmt -> while_stmt .)


state 32

    (15) loop_stmt -> CONTINUE .

    END_STATEMENT   reduce using rule 15 (loop_stmt -> CONTINUE .)


state 33

    (33) expr -> DOUBLE .

    ADD_OP          reduce using rule 33 (expr -> DOUBLE .)
    SUB_OP          reduce using rule 33 (expr -> DOUBLE .)
    MUL_OP          reduce using rule 33 (expr -> DOUBLE .)
    DIV_OP          reduce using rule 33 (expr -> DOUBLE .)
    MOD_OP          reduce using rule 33 (expr -> DOUBLE .)
    CEQ             reduce using rule 33 (expr -> DOUBLE .)
    CNE             reduce using rule 33 (expr -> DOUBLE .)
    CLT             reduce using rule 33 (expr -> DOUBLE .)
    CLE             reduce using rule 33 (expr -> DOUBLE .)
    CGT             reduce using rule 33 (expr -> DOUBLE .)
    CGE             reduce using rule 33 (expr -> DOUBLE .)
    END_STATEMENT   reduce using rule 33 (expr -> DOUBLE .)
    COLON           reduce using rule 33 (expr -> DOUBLE .)
    RPAREN          reduce using rule 33 (expr -> DOUBLE .)
    COMMA           reduce using rule 33 (expr -> DOUBLE .)
    OR              reduce using rule 33 (expr -> DOUBLE .)
    AND             reduce using rule 33 (expr -> DOUBLE .)


state 34

    (30) expr -> cond_list .

    ADD_OP          reduce using rule 30 (expr -> cond_list .)
    SUB_OP          reduce using rule 30 (expr -> cond_list .)
    MUL_OP          reduce using rule 30 (expr -> cond_list .)
    DIV_OP          reduce using rule 30 (expr -> cond_list .)
    MOD_OP          reduce using rule 30 (expr -> cond_list .)
    CEQ             reduce using rule 30 (expr -> cond_list .)
    CNE             reduce using rule 30 (expr -> cond_list .)
    CLT             reduce using rule 30 (expr -> cond_list .)
    CLE             reduce using rule 30 (expr -> cond_list .)
    CGT             reduce using rule 30 (expr -> cond_list .)
    CGE             reduce using rule 30 (expr -> cond_list .)
    END_STATEMENT   reduce using rule 30 (expr -> cond_list .)
    COLON           reduce using rule 30 (expr -> cond_list .)
    RPAREN          reduce using rule 30 (expr -> cond_list .)
    COMMA           reduce using rule 30 (expr -> cond_list .)
    OR              reduce using rule 30 (expr -> cond_list .)
    AND             reduce using rule 30 (expr -> cond_list .)


state 35

    (5) simple_stmt -> small_stmt END_STATEMENT .

    IF              reduce using rule 5 (simple_stmt -> small_stmt END_STATEMENT .)
    WHILE           reduce using rule 5 (simple_stmt -> small_stmt END_STATEMENT .)
    FOR             reduce using rule 5 (simple_stmt -> small_stmt END_STATEMENT .)
    IDENTIFIER      reduce using rule 5 (simple_stmt -> small_stmt END_STATEMENT .)
    ARRAY_CELL      reduce using rule 5 (simple_stmt -> small_stmt END_STATEMENT .)
    LPAREN          reduce using rule 5 (simple_stmt -> small_stmt END_STATEMENT .)
    INTEGER         reduce using rule 5 (simple_stmt -> small_stmt END_STATEMENT .)
    DOUBLE          reduce using rule 5 (simple_stmt -> small_stmt END_STATEMENT .)
    RETURN          reduce using rule 5 (simple_stmt -> small_stmt END_STATEMENT .)
    BREAK           reduce using rule 5 (simple_stmt -> small_stmt END_STATEMENT .)
    CONTINUE        reduce using rule 5 (simple_stmt -> small_stmt END_STATEMENT .)
    FUNCTION        reduce using rule 5 (simple_stmt -> small_stmt END_STATEMENT .)
    TRUE            reduce using rule 5 (simple_stmt -> small_stmt END_STATEMENT .)
    FALSE           reduce using rule 5 (simple_stmt -> small_stmt END_STATEMENT .)
    END             reduce using rule 5 (simple_stmt -> small_stmt END_STATEMENT .)
    $end            reduce using rule 5 (simple_stmt -> small_stmt END_STATEMENT .)


state 36

    (18) assignment -> ARRAY_CELL ASSIGN . expr
    (19) assignment -> ARRAY_CELL ASSIGN . boolean
    (26) expr -> . IDENTIFIER
    (27) expr -> . ARRAY_CELL
    (28) expr -> . func_call
    (29) expr -> . arithmetic
    (30) expr -> . cond_list
    (31) expr -> . LPAREN expr RPAREN
    (32) expr -> . INTEGER
    (33) expr -> . DOUBLE
    (34) boolean -> . TRUE
    (35) boolean -> . FALSE
    (21) func_call -> . IDENTIFIER LPAREN call_args RPAREN
    (22) func_call -> . IDENTIFIER LPAREN RPAREN
    (36) arithmetic -> . expr ADD_OP expr
    (37) arithmetic -> . expr SUB_OP expr
    (38) arithmetic -> . expr MUL_OP expr
    (39) arithmetic -> . expr DIV_OP expr
    (40) arithmetic -> . expr MOD_OP expr
    (61) cond_list -> . condition
    (62) cond_list -> . condition comb_op cond_list
    (63) cond_list -> . LPAREN cond_list RPAREN
    (64) condition -> . expr comp_op expr
    (65) condition -> . boolean

    IDENTIFIER      shift and go to state 38
    ARRAY_CELL      shift and go to state 37
    LPAREN          shift and go to state 22
    INTEGER         shift and go to state 11
    DOUBLE          shift and go to state 33
    TRUE            shift and go to state 7
    FALSE           shift and go to state 27

    func_call                      shift and go to state 26
    expr                           shift and go to state 70
    condition                      shift and go to state 24
    boolean                        shift and go to state 69
    cond_list                      shift and go to state 34
    arithmetic                     shift and go to state 14

state 37

    (27) expr -> ARRAY_CELL .

    ADD_OP          reduce using rule 27 (expr -> ARRAY_CELL .)
    SUB_OP          reduce using rule 27 (expr -> ARRAY_CELL .)
    MUL_OP          reduce using rule 27 (expr -> ARRAY_CELL .)
    DIV_OP          reduce using rule 27 (expr -> ARRAY_CELL .)
    MOD_OP          reduce using rule 27 (expr -> ARRAY_CELL .)
    CEQ             reduce using rule 27 (expr -> ARRAY_CELL .)
    CNE             reduce using rule 27 (expr -> ARRAY_CELL .)
    CLT             reduce using rule 27 (expr -> ARRAY_CELL .)
    CLE             reduce using rule 27 (expr -> ARRAY_CELL .)
    CGT             reduce using rule 27 (expr -> ARRAY_CELL .)
    CGE             reduce using rule 27 (expr -> ARRAY_CELL .)
    END_STATEMENT   reduce using rule 27 (expr -> ARRAY_CELL .)
    COLON           reduce using rule 27 (expr -> ARRAY_CELL .)
    RPAREN          reduce using rule 27 (expr -> ARRAY_CELL .)
    COMMA           reduce using rule 27 (expr -> ARRAY_CELL .)
    OR              reduce using rule 27 (expr -> ARRAY_CELL .)
    AND             reduce using rule 27 (expr -> ARRAY_CELL .)


state 38

    (26) expr -> IDENTIFIER .
    (21) func_call -> IDENTIFIER . LPAREN call_args RPAREN
    (22) func_call -> IDENTIFIER . LPAREN RPAREN

    ADD_OP          reduce using rule 26 (expr -> IDENTIFIER .)
    SUB_OP          reduce using rule 26 (expr -> IDENTIFIER .)
    MUL_OP          reduce using rule 26 (expr -> IDENTIFIER .)
    DIV_OP          reduce using rule 26 (expr -> IDENTIFIER .)
    MOD_OP          reduce using rule 26 (expr -> IDENTIFIER .)
    CEQ             reduce using rule 26 (expr -> IDENTIFIER .)
    CNE             reduce using rule 26 (expr -> IDENTIFIER .)
    CLT             reduce using rule 26 (expr -> IDENTIFIER .)
    CLE             reduce using rule 26 (expr -> IDENTIFIER .)
    CGT             reduce using rule 26 (expr -> IDENTIFIER .)
    CGE             reduce using rule 26 (expr -> IDENTIFIER .)
    END_STATEMENT   reduce using rule 26 (expr -> IDENTIFIER .)
    COLON           reduce using rule 26 (expr -> IDENTIFIER .)
    RPAREN          reduce using rule 26 (expr -> IDENTIFIER .)
    COMMA           reduce using rule 26 (expr -> IDENTIFIER .)
    OR              reduce using rule 26 (expr -> IDENTIFIER .)
    AND             reduce using rule 26 (expr -> IDENTIFIER .)
    LPAREN          shift and go to state 46


state 39

    (63) cond_list -> LPAREN . cond_list RPAREN
    (31) expr -> LPAREN . expr RPAREN
    (61) cond_list -> . condition
    (62) cond_list -> . condition comb_op cond_list
    (63) cond_list -> . LPAREN cond_list RPAREN
    (26) expr -> . IDENTIFIER
    (27) expr -> . ARRAY_CELL
    (28) expr -> . func_call
    (29) expr -> . arithmetic
    (30) expr -> . cond_list
    (31) expr -> . LPAREN expr RPAREN
    (32) expr -> . INTEGER
    (33) expr -> . DOUBLE
    (64) condition -> . expr comp_op expr
    (65) condition -> . boolean
    (21) func_call -> . IDENTIFIER LPAREN call_args RPAREN
    (22) func_call -> . IDENTIFIER LPAREN RPAREN
    (36) arithmetic -> . expr ADD_OP expr
    (37) arithmetic -> . expr SUB_OP expr
    (38) arithmetic -> . expr MUL_OP expr
    (39) arithmetic -> . expr DIV_OP expr
    (40) arithmetic -> . expr MOD_OP expr
    (34) boolean -> . TRUE
    (35) boolean -> . FALSE

    LPAREN          shift and go to state 39
    IDENTIFIER      shift and go to state 38
    ARRAY_CELL      shift and go to state 37
    INTEGER         shift and go to state 11
    DOUBLE          shift and go to state 33
    TRUE            shift and go to state 7
    FALSE           shift and go to state 27

    func_call                      shift and go to state 26
    expr                           shift and go to state 71
    boolean                        shift and go to state 4
    condition                      shift and go to state 24
    cond_list                      shift and go to state 51
    arithmetic                     shift and go to state 14

state 40

    (64) condition -> expr . comp_op expr
    (36) arithmetic -> expr . ADD_OP expr
    (37) arithmetic -> expr . SUB_OP expr
    (38) arithmetic -> expr . MUL_OP expr
    (39) arithmetic -> expr . DIV_OP expr
    (40) arithmetic -> expr . MOD_OP expr
    (43) comp_op -> . CEQ
    (44) comp_op -> . CNE
    (45) comp_op -> . CLT
    (46) comp_op -> . CLE
    (47) comp_op -> . CGT
    (48) comp_op -> . CGE

    ADD_OP          shift and go to state 65
    SUB_OP          shift and go to state 61
    MUL_OP          shift and go to state 58
    DIV_OP          shift and go to state 62
    MOD_OP          shift and go to state 67
    CEQ             shift and go to state 64
    CNE             shift and go to state 63
    CLT             shift and go to state 66
    CLE             shift and go to state 57
    CGT             shift and go to state 68
    CGE             shift and go to state 59

    comp_op                        shift and go to state 60

state 41

    (60) while_stmt -> WHILE cond_list . COLON END_STATEMENT body END
    (30) expr -> cond_list .

    COLON           shift and go to state 72
    ADD_OP          reduce using rule 30 (expr -> cond_list .)
    SUB_OP          reduce using rule 30 (expr -> cond_list .)
    MUL_OP          reduce using rule 30 (expr -> cond_list .)
    DIV_OP          reduce using rule 30 (expr -> cond_list .)
    MOD_OP          reduce using rule 30 (expr -> cond_list .)
    CEQ             reduce using rule 30 (expr -> cond_list .)
    CNE             reduce using rule 30 (expr -> cond_list .)
    CLT             reduce using rule 30 (expr -> cond_list .)
    CLE             reduce using rule 30 (expr -> cond_list .)
    CGT             reduce using rule 30 (expr -> cond_list .)
    CGE             reduce using rule 30 (expr -> cond_list .)


state 42

    (13) return_stmt -> RETURN boolean .
    (65) condition -> boolean .

  ! reduce/reduce conflict for END_STATEMENT resolved using rule 13 (return_stmt -> RETURN boolean .)
    END_STATEMENT   reduce using rule 13 (return_stmt -> RETURN boolean .)
    OR              reduce using rule 65 (condition -> boolean .)
    AND             reduce using rule 65 (condition -> boolean .)
    ADD_OP          reduce using rule 65 (condition -> boolean .)
    SUB_OP          reduce using rule 65 (condition -> boolean .)
    MUL_OP          reduce using rule 65 (condition -> boolean .)
    DIV_OP          reduce using rule 65 (condition -> boolean .)
    MOD_OP          reduce using rule 65 (condition -> boolean .)
    CEQ             reduce using rule 65 (condition -> boolean .)
    CNE             reduce using rule 65 (condition -> boolean .)
    CLT             reduce using rule 65 (condition -> boolean .)
    CLE             reduce using rule 65 (condition -> boolean .)
    CGT             reduce using rule 65 (condition -> boolean .)
    CGE             reduce using rule 65 (condition -> boolean .)

  ! END_STATEMENT   [ reduce using rule 65 (condition -> boolean .) ]


state 43

    (12) return_stmt -> RETURN expr .
    (36) arithmetic -> expr . ADD_OP expr
    (37) arithmetic -> expr . SUB_OP expr
    (38) arithmetic -> expr . MUL_OP expr
    (39) arithmetic -> expr . DIV_OP expr
    (40) arithmetic -> expr . MOD_OP expr
    (64) condition -> expr . comp_op expr
    (43) comp_op -> . CEQ
    (44) comp_op -> . CNE
    (45) comp_op -> . CLT
    (46) comp_op -> . CLE
    (47) comp_op -> . CGT
    (48) comp_op -> . CGE

    END_STATEMENT   reduce using rule 12 (return_stmt -> RETURN expr .)
    ADD_OP          shift and go to state 65
    SUB_OP          shift and go to state 61
    MUL_OP          shift and go to state 58
    DIV_OP          shift and go to state 62
    MOD_OP          shift and go to state 67
    CEQ             shift and go to state 64
    CNE             shift and go to state 63
    CLT             shift and go to state 66
    CLE             shift and go to state 57
    CGT             shift and go to state 68
    CGE             shift and go to state 59

    comp_op                        shift and go to state 60

state 44

    (66) for_stmt -> FOR IDENTIFIER . IN RANGE LPAREN INTEGER COMMA INTEGER RPAREN COLON END_STATEMENT body END
    (67) for_stmt -> FOR IDENTIFIER . IN IDENTIFIER COLON END_STATEMENT body END

    IN              shift and go to state 73


state 45

    (20) const_decl -> IDENTIFIER CONST . expr
    (26) expr -> . IDENTIFIER
    (27) expr -> . ARRAY_CELL
    (28) expr -> . func_call
    (29) expr -> . arithmetic
    (30) expr -> . cond_list
    (31) expr -> . LPAREN expr RPAREN
    (32) expr -> . INTEGER
    (33) expr -> . DOUBLE
    (21) func_call -> . IDENTIFIER LPAREN call_args RPAREN
    (22) func_call -> . IDENTIFIER LPAREN RPAREN
    (36) arithmetic -> . expr ADD_OP expr
    (37) arithmetic -> . expr SUB_OP expr
    (38) arithmetic -> . expr MUL_OP expr
    (39) arithmetic -> . expr DIV_OP expr
    (40) arithmetic -> . expr MOD_OP expr
    (61) cond_list -> . condition
    (62) cond_list -> . condition comb_op cond_list
    (63) cond_list -> . LPAREN cond_list RPAREN
    (64) condition -> . expr comp_op expr
    (65) condition -> . boolean
    (34) boolean -> . TRUE
    (35) boolean -> . FALSE

    IDENTIFIER      shift and go to state 38
    ARRAY_CELL      shift and go to state 37
    LPAREN          shift and go to state 22
    INTEGER         shift and go to state 11
    DOUBLE          shift and go to state 33
    TRUE            shift and go to state 7
    FALSE           shift and go to state 27

    func_call                      shift and go to state 26
    arithmetic                     shift and go to state 14
    expr                           shift and go to state 74
    boolean                        shift and go to state 4
    cond_list                      shift and go to state 34
    condition                      shift and go to state 24

state 46

    (21) func_call -> IDENTIFIER LPAREN . call_args RPAREN
    (22) func_call -> IDENTIFIER LPAREN . RPAREN
    (23) call_args -> . arg
    (24) call_args -> . arg COMMA call_args
    (25) arg -> . expr
    (26) expr -> . IDENTIFIER
    (27) expr -> . ARRAY_CELL
    (28) expr -> . func_call
    (29) expr -> . arithmetic
    (30) expr -> . cond_list
    (31) expr -> . LPAREN expr RPAREN
    (32) expr -> . INTEGER
    (33) expr -> . DOUBLE
    (21) func_call -> . IDENTIFIER LPAREN call_args RPAREN
    (22) func_call -> . IDENTIFIER LPAREN RPAREN
    (36) arithmetic -> . expr ADD_OP expr
    (37) arithmetic -> . expr SUB_OP expr
    (38) arithmetic -> . expr MUL_OP expr
    (39) arithmetic -> . expr DIV_OP expr
    (40) arithmetic -> . expr MOD_OP expr
    (61) cond_list -> . condition
    (62) cond_list -> . condition comb_op cond_list
    (63) cond_list -> . LPAREN cond_list RPAREN
    (64) condition -> . expr comp_op expr
    (65) condition -> . boolean
    (34) boolean -> . TRUE
    (35) boolean -> . FALSE

    RPAREN          shift and go to state 76
    IDENTIFIER      shift and go to state 38
    ARRAY_CELL      shift and go to state 37
    LPAREN          shift and go to state 22
    INTEGER         shift and go to state 11
    DOUBLE          shift and go to state 33
    TRUE            shift and go to state 7
    FALSE           shift and go to state 27

    func_call                      shift and go to state 26
    expr                           shift and go to state 78
    condition                      shift and go to state 24
    boolean                        shift and go to state 4
    call_args                      shift and go to state 77
    arg                            shift and go to state 75
    cond_list                      shift and go to state 34
    arithmetic                     shift and go to state 14

state 47

    (16) assignment -> IDENTIFIER ASSIGN . expr
    (17) assignment -> IDENTIFIER ASSIGN . boolean
    (26) expr -> . IDENTIFIER
    (27) expr -> . ARRAY_CELL
    (28) expr -> . func_call
    (29) expr -> . arithmetic
    (30) expr -> . cond_list
    (31) expr -> . LPAREN expr RPAREN
    (32) expr -> . INTEGER
    (33) expr -> . DOUBLE
    (34) boolean -> . TRUE
    (35) boolean -> . FALSE
    (21) func_call -> . IDENTIFIER LPAREN call_args RPAREN
    (22) func_call -> . IDENTIFIER LPAREN RPAREN
    (36) arithmetic -> . expr ADD_OP expr
    (37) arithmetic -> . expr SUB_OP expr
    (38) arithmetic -> . expr MUL_OP expr
    (39) arithmetic -> . expr DIV_OP expr
    (40) arithmetic -> . expr MOD_OP expr
    (61) cond_list -> . condition
    (62) cond_list -> . condition comb_op cond_list
    (63) cond_list -> . LPAREN cond_list RPAREN
    (64) condition -> . expr comp_op expr
    (65) condition -> . boolean

    IDENTIFIER      shift and go to state 38
    ARRAY_CELL      shift and go to state 37
    LPAREN          shift and go to state 22
    INTEGER         shift and go to state 11
    DOUBLE          shift and go to state 33
    TRUE            shift and go to state 7
    FALSE           shift and go to state 27

    func_call                      shift and go to state 26
    expr                           shift and go to state 80
    condition                      shift and go to state 24
    boolean                        shift and go to state 79
    cond_list                      shift and go to state 34
    arithmetic                     shift and go to state 14

state 48

    (53) func_def -> head END_STATEMENT . body END
    (58) body -> . stmt
    (59) body -> . stmt body
    (3) stmt -> . simple_stmt
    (4) stmt -> . compound_stmt
    (5) simple_stmt -> . small_stmt END_STATEMENT
    (49) compound_stmt -> . func_def
    (50) compound_stmt -> . if_stmt
    (51) compound_stmt -> . while_stmt
    (52) compound_stmt -> . for_stmt
    (6) small_stmt -> . assignment
    (7) small_stmt -> . const_decl
    (8) small_stmt -> . expr
    (9) small_stmt -> . return_stmt
    (10) small_stmt -> . loop_stmt
    (53) func_def -> . head END_STATEMENT body END
    (68) if_stmt -> . IF cond_list COLON END_STATEMENT body END
    (69) if_stmt -> . IF cond_list COLON END_STATEMENT body END elseif_list
    (70) if_stmt -> . IF cond_list COLON END_STATEMENT body END elseif_list ELSE COLON END_STATEMENT body END
    (71) if_stmt -> . IF cond_list COLON END_STATEMENT body END ELSE COLON END_STATEMENT body END
    (60) while_stmt -> . WHILE cond_list COLON END_STATEMENT body END
    (66) for_stmt -> . FOR IDENTIFIER IN RANGE LPAREN INTEGER COMMA INTEGER RPAREN COLON END_STATEMENT body END
    (67) for_stmt -> . FOR IDENTIFIER IN IDENTIFIER COLON END_STATEMENT body END
    (16) assignment -> . IDENTIFIER ASSIGN expr
    (17) assignment -> . IDENTIFIER ASSIGN boolean
    (18) assignment -> . ARRAY_CELL ASSIGN expr
    (19) assignment -> . ARRAY_CELL ASSIGN boolean
    (20) const_decl -> . IDENTIFIER CONST expr
    (26) expr -> . IDENTIFIER
    (27) expr -> . ARRAY_CELL
    (28) expr -> . func_call
    (29) expr -> . arithmetic
    (30) expr -> . cond_list
    (31) expr -> . LPAREN expr RPAREN
    (32) expr -> . INTEGER
    (33) expr -> . DOUBLE
    (11) return_stmt -> . RETURN
    (12) return_stmt -> . RETURN expr
    (13) return_stmt -> . RETURN boolean
    (14) loop_stmt -> . BREAK
    (15) loop_stmt -> . CONTINUE
    (54) head -> . FUNCTION IDENTIFIER LPAREN p_func_def_args RPAREN COLON
    (55) head -> . FUNCTION IDENTIFIER LPAREN RPAREN COLON
    (21) func_call -> . IDENTIFIER LPAREN call_args RPAREN
    (22) func_call -> . IDENTIFIER LPAREN RPAREN
    (36) arithmetic -> . expr ADD_OP expr
    (37) arithmetic -> . expr SUB_OP expr
    (38) arithmetic -> . expr MUL_OP expr
    (39) arithmetic -> . expr DIV_OP expr
    (40) arithmetic -> . expr MOD_OP expr
    (61) cond_list -> . condition
    (62) cond_list -> . condition comb_op cond_list
    (63) cond_list -> . LPAREN cond_list RPAREN
    (64) condition -> . expr comp_op expr
    (65) condition -> . boolean
    (34) boolean -> . TRUE
    (35) boolean -> . FALSE

    IF              shift and go to state 25
    WHILE           shift and go to state 3
    FOR             shift and go to state 8
    IDENTIFIER      shift and go to state 12
    ARRAY_CELL      shift and go to state 2
    LPAREN          shift and go to state 22
    INTEGER         shift and go to state 11
    DOUBLE          shift and go to state 33
    RETURN          shift and go to state 6
    BREAK           shift and go to state 30
    CONTINUE        shift and go to state 32
    FUNCTION        shift and go to state 23
    TRUE            shift and go to state 7
    FALSE           shift and go to state 27

    small_stmt                     shift and go to state 1
    boolean                        shift and go to state 4
    return_stmt                    shift and go to state 5
    const_decl                     shift and go to state 9
    compound_stmt                  shift and go to state 13
    arithmetic                     shift and go to state 14
    body                           shift and go to state 81
    head                           shift and go to state 15
    func_def                       shift and go to state 16
    simple_stmt                    shift and go to state 17
    assignment                     shift and go to state 18
    stmt                           shift and go to state 82
    for_stmt                       shift and go to state 20
    loop_stmt                      shift and go to state 21
    condition                      shift and go to state 24
    func_call                      shift and go to state 26
    if_stmt                        shift and go to state 28
    expr                           shift and go to state 29
    while_stmt                     shift and go to state 31
    cond_list                      shift and go to state 34

state 49

    (2) program -> stmt program .

    $end            reduce using rule 2 (program -> stmt program .)


state 50

    (31) expr -> LPAREN expr . RPAREN
    (36) arithmetic -> expr . ADD_OP expr
    (37) arithmetic -> expr . SUB_OP expr
    (38) arithmetic -> expr . MUL_OP expr
    (39) arithmetic -> expr . DIV_OP expr
    (40) arithmetic -> expr . MOD_OP expr
    (64) condition -> expr . comp_op expr
    (43) comp_op -> . CEQ
    (44) comp_op -> . CNE
    (45) comp_op -> . CLT
    (46) comp_op -> . CLE
    (47) comp_op -> . CGT
    (48) comp_op -> . CGE

    RPAREN          shift and go to state 83
    ADD_OP          shift and go to state 65
    SUB_OP          shift and go to state 61
    MUL_OP          shift and go to state 58
    DIV_OP          shift and go to state 62
    MOD_OP          shift and go to state 67
    CEQ             shift and go to state 64
    CNE             shift and go to state 63
    CLT             shift and go to state 66
    CLE             shift and go to state 57
    CGT             shift and go to state 68
    CGE             shift and go to state 59

    comp_op                        shift and go to state 60

state 51

    (63) cond_list -> LPAREN cond_list . RPAREN
    (30) expr -> cond_list .

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 84
    ADD_OP          reduce using rule 30 (expr -> cond_list .)
    SUB_OP          reduce using rule 30 (expr -> cond_list .)
    MUL_OP          reduce using rule 30 (expr -> cond_list .)
    DIV_OP          reduce using rule 30 (expr -> cond_list .)
    MOD_OP          reduce using rule 30 (expr -> cond_list .)
    CEQ             reduce using rule 30 (expr -> cond_list .)
    CNE             reduce using rule 30 (expr -> cond_list .)
    CLT             reduce using rule 30 (expr -> cond_list .)
    CLE             reduce using rule 30 (expr -> cond_list .)
    CGT             reduce using rule 30 (expr -> cond_list .)
    CGE             reduce using rule 30 (expr -> cond_list .)

  ! RPAREN          [ reduce using rule 30 (expr -> cond_list .) ]


state 52

    (54) head -> FUNCTION IDENTIFIER . LPAREN p_func_def_args RPAREN COLON
    (55) head -> FUNCTION IDENTIFIER . LPAREN RPAREN COLON

    LPAREN          shift and go to state 85


state 53

    (42) comb_op -> AND .

    LPAREN          reduce using rule 42 (comb_op -> AND .)
    IDENTIFIER      reduce using rule 42 (comb_op -> AND .)
    ARRAY_CELL      reduce using rule 42 (comb_op -> AND .)
    INTEGER         reduce using rule 42 (comb_op -> AND .)
    DOUBLE          reduce using rule 42 (comb_op -> AND .)
    TRUE            reduce using rule 42 (comb_op -> AND .)
    FALSE           reduce using rule 42 (comb_op -> AND .)


state 54

    (62) cond_list -> condition comb_op . cond_list
    (61) cond_list -> . condition
    (62) cond_list -> . condition comb_op cond_list
    (63) cond_list -> . LPAREN cond_list RPAREN
    (64) condition -> . expr comp_op expr
    (65) condition -> . boolean
    (26) expr -> . IDENTIFIER
    (27) expr -> . ARRAY_CELL
    (28) expr -> . func_call
    (29) expr -> . arithmetic
    (30) expr -> . cond_list
    (31) expr -> . LPAREN expr RPAREN
    (32) expr -> . INTEGER
    (33) expr -> . DOUBLE
    (34) boolean -> . TRUE
    (35) boolean -> . FALSE
    (21) func_call -> . IDENTIFIER LPAREN call_args RPAREN
    (22) func_call -> . IDENTIFIER LPAREN RPAREN
    (36) arithmetic -> . expr ADD_OP expr
    (37) arithmetic -> . expr SUB_OP expr
    (38) arithmetic -> . expr MUL_OP expr
    (39) arithmetic -> . expr DIV_OP expr
    (40) arithmetic -> . expr MOD_OP expr

    LPAREN          shift and go to state 39
    IDENTIFIER      shift and go to state 38
    ARRAY_CELL      shift and go to state 37
    INTEGER         shift and go to state 11
    DOUBLE          shift and go to state 33
    TRUE            shift and go to state 7
    FALSE           shift and go to state 27

    func_call                      shift and go to state 26
    expr                           shift and go to state 40
    boolean                        shift and go to state 4
    arithmetic                     shift and go to state 14
    cond_list                      shift and go to state 86
    condition                      shift and go to state 24

state 55

    (41) comb_op -> OR .

    LPAREN          reduce using rule 41 (comb_op -> OR .)
    IDENTIFIER      reduce using rule 41 (comb_op -> OR .)
    ARRAY_CELL      reduce using rule 41 (comb_op -> OR .)
    INTEGER         reduce using rule 41 (comb_op -> OR .)
    DOUBLE          reduce using rule 41 (comb_op -> OR .)
    TRUE            reduce using rule 41 (comb_op -> OR .)
    FALSE           reduce using rule 41 (comb_op -> OR .)


state 56

    (68) if_stmt -> IF cond_list . COLON END_STATEMENT body END
    (69) if_stmt -> IF cond_list . COLON END_STATEMENT body END elseif_list
    (70) if_stmt -> IF cond_list . COLON END_STATEMENT body END elseif_list ELSE COLON END_STATEMENT body END
    (71) if_stmt -> IF cond_list . COLON END_STATEMENT body END ELSE COLON END_STATEMENT body END
    (30) expr -> cond_list .

    COLON           shift and go to state 87
    ADD_OP          reduce using rule 30 (expr -> cond_list .)
    SUB_OP          reduce using rule 30 (expr -> cond_list .)
    MUL_OP          reduce using rule 30 (expr -> cond_list .)
    DIV_OP          reduce using rule 30 (expr -> cond_list .)
    MOD_OP          reduce using rule 30 (expr -> cond_list .)
    CEQ             reduce using rule 30 (expr -> cond_list .)
    CNE             reduce using rule 30 (expr -> cond_list .)
    CLT             reduce using rule 30 (expr -> cond_list .)
    CLE             reduce using rule 30 (expr -> cond_list .)
    CGT             reduce using rule 30 (expr -> cond_list .)
    CGE             reduce using rule 30 (expr -> cond_list .)


state 57

    (46) comp_op -> CLE .

    IDENTIFIER      reduce using rule 46 (comp_op -> CLE .)
    ARRAY_CELL      reduce using rule 46 (comp_op -> CLE .)
    LPAREN          reduce using rule 46 (comp_op -> CLE .)
    INTEGER         reduce using rule 46 (comp_op -> CLE .)
    DOUBLE          reduce using rule 46 (comp_op -> CLE .)
    TRUE            reduce using rule 46 (comp_op -> CLE .)
    FALSE           reduce using rule 46 (comp_op -> CLE .)


state 58

    (38) arithmetic -> expr MUL_OP . expr
    (26) expr -> . IDENTIFIER
    (27) expr -> . ARRAY_CELL
    (28) expr -> . func_call
    (29) expr -> . arithmetic
    (30) expr -> . cond_list
    (31) expr -> . LPAREN expr RPAREN
    (32) expr -> . INTEGER
    (33) expr -> . DOUBLE
    (21) func_call -> . IDENTIFIER LPAREN call_args RPAREN
    (22) func_call -> . IDENTIFIER LPAREN RPAREN
    (36) arithmetic -> . expr ADD_OP expr
    (37) arithmetic -> . expr SUB_OP expr
    (38) arithmetic -> . expr MUL_OP expr
    (39) arithmetic -> . expr DIV_OP expr
    (40) arithmetic -> . expr MOD_OP expr
    (61) cond_list -> . condition
    (62) cond_list -> . condition comb_op cond_list
    (63) cond_list -> . LPAREN cond_list RPAREN
    (64) condition -> . expr comp_op expr
    (65) condition -> . boolean
    (34) boolean -> . TRUE
    (35) boolean -> . FALSE

    IDENTIFIER      shift and go to state 38
    ARRAY_CELL      shift and go to state 37
    LPAREN          shift and go to state 22
    INTEGER         shift and go to state 11
    DOUBLE          shift and go to state 33
    TRUE            shift and go to state 7
    FALSE           shift and go to state 27

    func_call                      shift and go to state 26
    arithmetic                     shift and go to state 14
    expr                           shift and go to state 88
    boolean                        shift and go to state 4
    cond_list                      shift and go to state 34
    condition                      shift and go to state 24

state 59

    (48) comp_op -> CGE .

    IDENTIFIER      reduce using rule 48 (comp_op -> CGE .)
    ARRAY_CELL      reduce using rule 48 (comp_op -> CGE .)
    LPAREN          reduce using rule 48 (comp_op -> CGE .)
    INTEGER         reduce using rule 48 (comp_op -> CGE .)
    DOUBLE          reduce using rule 48 (comp_op -> CGE .)
    TRUE            reduce using rule 48 (comp_op -> CGE .)
    FALSE           reduce using rule 48 (comp_op -> CGE .)


state 60

    (64) condition -> expr comp_op . expr
    (26) expr -> . IDENTIFIER
    (27) expr -> . ARRAY_CELL
    (28) expr -> . func_call
    (29) expr -> . arithmetic
    (30) expr -> . cond_list
    (31) expr -> . LPAREN expr RPAREN
    (32) expr -> . INTEGER
    (33) expr -> . DOUBLE
    (21) func_call -> . IDENTIFIER LPAREN call_args RPAREN
    (22) func_call -> . IDENTIFIER LPAREN RPAREN
    (36) arithmetic -> . expr ADD_OP expr
    (37) arithmetic -> . expr SUB_OP expr
    (38) arithmetic -> . expr MUL_OP expr
    (39) arithmetic -> . expr DIV_OP expr
    (40) arithmetic -> . expr MOD_OP expr
    (61) cond_list -> . condition
    (62) cond_list -> . condition comb_op cond_list
    (63) cond_list -> . LPAREN cond_list RPAREN
    (64) condition -> . expr comp_op expr
    (65) condition -> . boolean
    (34) boolean -> . TRUE
    (35) boolean -> . FALSE

    IDENTIFIER      shift and go to state 38
    ARRAY_CELL      shift and go to state 37
    LPAREN          shift and go to state 22
    INTEGER         shift and go to state 11
    DOUBLE          shift and go to state 33
    TRUE            shift and go to state 7
    FALSE           shift and go to state 27

    func_call                      shift and go to state 26
    expr                           shift and go to state 89
    condition                      shift and go to state 24
    boolean                        shift and go to state 4
    cond_list                      shift and go to state 34
    arithmetic                     shift and go to state 14

state 61

    (37) arithmetic -> expr SUB_OP . expr
    (26) expr -> . IDENTIFIER
    (27) expr -> . ARRAY_CELL
    (28) expr -> . func_call
    (29) expr -> . arithmetic
    (30) expr -> . cond_list
    (31) expr -> . LPAREN expr RPAREN
    (32) expr -> . INTEGER
    (33) expr -> . DOUBLE
    (21) func_call -> . IDENTIFIER LPAREN call_args RPAREN
    (22) func_call -> . IDENTIFIER LPAREN RPAREN
    (36) arithmetic -> . expr ADD_OP expr
    (37) arithmetic -> . expr SUB_OP expr
    (38) arithmetic -> . expr MUL_OP expr
    (39) arithmetic -> . expr DIV_OP expr
    (40) arithmetic -> . expr MOD_OP expr
    (61) cond_list -> . condition
    (62) cond_list -> . condition comb_op cond_list
    (63) cond_list -> . LPAREN cond_list RPAREN
    (64) condition -> . expr comp_op expr
    (65) condition -> . boolean
    (34) boolean -> . TRUE
    (35) boolean -> . FALSE

    IDENTIFIER      shift and go to state 38
    ARRAY_CELL      shift and go to state 37
    LPAREN          shift and go to state 22
    INTEGER         shift and go to state 11
    DOUBLE          shift and go to state 33
    TRUE            shift and go to state 7
    FALSE           shift and go to state 27

    func_call                      shift and go to state 26
    arithmetic                     shift and go to state 14
    expr                           shift and go to state 90
    boolean                        shift and go to state 4
    cond_list                      shift and go to state 34
    condition                      shift and go to state 24

state 62

    (39) arithmetic -> expr DIV_OP . expr
    (26) expr -> . IDENTIFIER
    (27) expr -> . ARRAY_CELL
    (28) expr -> . func_call
    (29) expr -> . arithmetic
    (30) expr -> . cond_list
    (31) expr -> . LPAREN expr RPAREN
    (32) expr -> . INTEGER
    (33) expr -> . DOUBLE
    (21) func_call -> . IDENTIFIER LPAREN call_args RPAREN
    (22) func_call -> . IDENTIFIER LPAREN RPAREN
    (36) arithmetic -> . expr ADD_OP expr
    (37) arithmetic -> . expr SUB_OP expr
    (38) arithmetic -> . expr MUL_OP expr
    (39) arithmetic -> . expr DIV_OP expr
    (40) arithmetic -> . expr MOD_OP expr
    (61) cond_list -> . condition
    (62) cond_list -> . condition comb_op cond_list
    (63) cond_list -> . LPAREN cond_list RPAREN
    (64) condition -> . expr comp_op expr
    (65) condition -> . boolean
    (34) boolean -> . TRUE
    (35) boolean -> . FALSE

    IDENTIFIER      shift and go to state 38
    ARRAY_CELL      shift and go to state 37
    LPAREN          shift and go to state 22
    INTEGER         shift and go to state 11
    DOUBLE          shift and go to state 33
    TRUE            shift and go to state 7
    FALSE           shift and go to state 27

    func_call                      shift and go to state 26
    arithmetic                     shift and go to state 14
    expr                           shift and go to state 91
    boolean                        shift and go to state 4
    cond_list                      shift and go to state 34
    condition                      shift and go to state 24

state 63

    (44) comp_op -> CNE .

    IDENTIFIER      reduce using rule 44 (comp_op -> CNE .)
    ARRAY_CELL      reduce using rule 44 (comp_op -> CNE .)
    LPAREN          reduce using rule 44 (comp_op -> CNE .)
    INTEGER         reduce using rule 44 (comp_op -> CNE .)
    DOUBLE          reduce using rule 44 (comp_op -> CNE .)
    TRUE            reduce using rule 44 (comp_op -> CNE .)
    FALSE           reduce using rule 44 (comp_op -> CNE .)


state 64

    (43) comp_op -> CEQ .

    IDENTIFIER      reduce using rule 43 (comp_op -> CEQ .)
    ARRAY_CELL      reduce using rule 43 (comp_op -> CEQ .)
    LPAREN          reduce using rule 43 (comp_op -> CEQ .)
    INTEGER         reduce using rule 43 (comp_op -> CEQ .)
    DOUBLE          reduce using rule 43 (comp_op -> CEQ .)
    TRUE            reduce using rule 43 (comp_op -> CEQ .)
    FALSE           reduce using rule 43 (comp_op -> CEQ .)


state 65

    (36) arithmetic -> expr ADD_OP . expr
    (26) expr -> . IDENTIFIER
    (27) expr -> . ARRAY_CELL
    (28) expr -> . func_call
    (29) expr -> . arithmetic
    (30) expr -> . cond_list
    (31) expr -> . LPAREN expr RPAREN
    (32) expr -> . INTEGER
    (33) expr -> . DOUBLE
    (21) func_call -> . IDENTIFIER LPAREN call_args RPAREN
    (22) func_call -> . IDENTIFIER LPAREN RPAREN
    (36) arithmetic -> . expr ADD_OP expr
    (37) arithmetic -> . expr SUB_OP expr
    (38) arithmetic -> . expr MUL_OP expr
    (39) arithmetic -> . expr DIV_OP expr
    (40) arithmetic -> . expr MOD_OP expr
    (61) cond_list -> . condition
    (62) cond_list -> . condition comb_op cond_list
    (63) cond_list -> . LPAREN cond_list RPAREN
    (64) condition -> . expr comp_op expr
    (65) condition -> . boolean
    (34) boolean -> . TRUE
    (35) boolean -> . FALSE

    IDENTIFIER      shift and go to state 38
    ARRAY_CELL      shift and go to state 37
    LPAREN          shift and go to state 22
    INTEGER         shift and go to state 11
    DOUBLE          shift and go to state 33
    TRUE            shift and go to state 7
    FALSE           shift and go to state 27

    func_call                      shift and go to state 26
    arithmetic                     shift and go to state 14
    expr                           shift and go to state 92
    boolean                        shift and go to state 4
    cond_list                      shift and go to state 34
    condition                      shift and go to state 24

state 66

    (45) comp_op -> CLT .

    IDENTIFIER      reduce using rule 45 (comp_op -> CLT .)
    ARRAY_CELL      reduce using rule 45 (comp_op -> CLT .)
    LPAREN          reduce using rule 45 (comp_op -> CLT .)
    INTEGER         reduce using rule 45 (comp_op -> CLT .)
    DOUBLE          reduce using rule 45 (comp_op -> CLT .)
    TRUE            reduce using rule 45 (comp_op -> CLT .)
    FALSE           reduce using rule 45 (comp_op -> CLT .)


state 67

    (40) arithmetic -> expr MOD_OP . expr
    (26) expr -> . IDENTIFIER
    (27) expr -> . ARRAY_CELL
    (28) expr -> . func_call
    (29) expr -> . arithmetic
    (30) expr -> . cond_list
    (31) expr -> . LPAREN expr RPAREN
    (32) expr -> . INTEGER
    (33) expr -> . DOUBLE
    (21) func_call -> . IDENTIFIER LPAREN call_args RPAREN
    (22) func_call -> . IDENTIFIER LPAREN RPAREN
    (36) arithmetic -> . expr ADD_OP expr
    (37) arithmetic -> . expr SUB_OP expr
    (38) arithmetic -> . expr MUL_OP expr
    (39) arithmetic -> . expr DIV_OP expr
    (40) arithmetic -> . expr MOD_OP expr
    (61) cond_list -> . condition
    (62) cond_list -> . condition comb_op cond_list
    (63) cond_list -> . LPAREN cond_list RPAREN
    (64) condition -> . expr comp_op expr
    (65) condition -> . boolean
    (34) boolean -> . TRUE
    (35) boolean -> . FALSE

    IDENTIFIER      shift and go to state 38
    ARRAY_CELL      shift and go to state 37
    LPAREN          shift and go to state 22
    INTEGER         shift and go to state 11
    DOUBLE          shift and go to state 33
    TRUE            shift and go to state 7
    FALSE           shift and go to state 27

    func_call                      shift and go to state 26
    arithmetic                     shift and go to state 14
    expr                           shift and go to state 93
    boolean                        shift and go to state 4
    cond_list                      shift and go to state 34
    condition                      shift and go to state 24

state 68

    (47) comp_op -> CGT .

    IDENTIFIER      reduce using rule 47 (comp_op -> CGT .)
    ARRAY_CELL      reduce using rule 47 (comp_op -> CGT .)
    LPAREN          reduce using rule 47 (comp_op -> CGT .)
    INTEGER         reduce using rule 47 (comp_op -> CGT .)
    DOUBLE          reduce using rule 47 (comp_op -> CGT .)
    TRUE            reduce using rule 47 (comp_op -> CGT .)
    FALSE           reduce using rule 47 (comp_op -> CGT .)


state 69

    (19) assignment -> ARRAY_CELL ASSIGN boolean .
    (65) condition -> boolean .

  ! reduce/reduce conflict for END_STATEMENT resolved using rule 19 (assignment -> ARRAY_CELL ASSIGN boolean .)
    END_STATEMENT   reduce using rule 19 (assignment -> ARRAY_CELL ASSIGN boolean .)
    OR              reduce using rule 65 (condition -> boolean .)
    AND             reduce using rule 65 (condition -> boolean .)
    ADD_OP          reduce using rule 65 (condition -> boolean .)
    SUB_OP          reduce using rule 65 (condition -> boolean .)
    MUL_OP          reduce using rule 65 (condition -> boolean .)
    DIV_OP          reduce using rule 65 (condition -> boolean .)
    MOD_OP          reduce using rule 65 (condition -> boolean .)
    CEQ             reduce using rule 65 (condition -> boolean .)
    CNE             reduce using rule 65 (condition -> boolean .)
    CLT             reduce using rule 65 (condition -> boolean .)
    CLE             reduce using rule 65 (condition -> boolean .)
    CGT             reduce using rule 65 (condition -> boolean .)
    CGE             reduce using rule 65 (condition -> boolean .)

  ! END_STATEMENT   [ reduce using rule 65 (condition -> boolean .) ]


state 70

    (18) assignment -> ARRAY_CELL ASSIGN expr .
    (36) arithmetic -> expr . ADD_OP expr
    (37) arithmetic -> expr . SUB_OP expr
    (38) arithmetic -> expr . MUL_OP expr
    (39) arithmetic -> expr . DIV_OP expr
    (40) arithmetic -> expr . MOD_OP expr
    (64) condition -> expr . comp_op expr
    (43) comp_op -> . CEQ
    (44) comp_op -> . CNE
    (45) comp_op -> . CLT
    (46) comp_op -> . CLE
    (47) comp_op -> . CGT
    (48) comp_op -> . CGE

    END_STATEMENT   reduce using rule 18 (assignment -> ARRAY_CELL ASSIGN expr .)
    ADD_OP          shift and go to state 65
    SUB_OP          shift and go to state 61
    MUL_OP          shift and go to state 58
    DIV_OP          shift and go to state 62
    MOD_OP          shift and go to state 67
    CEQ             shift and go to state 64
    CNE             shift and go to state 63
    CLT             shift and go to state 66
    CLE             shift and go to state 57
    CGT             shift and go to state 68
    CGE             shift and go to state 59

    comp_op                        shift and go to state 60

state 71

    (31) expr -> LPAREN expr . RPAREN
    (64) condition -> expr . comp_op expr
    (36) arithmetic -> expr . ADD_OP expr
    (37) arithmetic -> expr . SUB_OP expr
    (38) arithmetic -> expr . MUL_OP expr
    (39) arithmetic -> expr . DIV_OP expr
    (40) arithmetic -> expr . MOD_OP expr
    (43) comp_op -> . CEQ
    (44) comp_op -> . CNE
    (45) comp_op -> . CLT
    (46) comp_op -> . CLE
    (47) comp_op -> . CGT
    (48) comp_op -> . CGE

    RPAREN          shift and go to state 83
    ADD_OP          shift and go to state 65
    SUB_OP          shift and go to state 61
    MUL_OP          shift and go to state 58
    DIV_OP          shift and go to state 62
    MOD_OP          shift and go to state 67
    CEQ             shift and go to state 64
    CNE             shift and go to state 63
    CLT             shift and go to state 66
    CLE             shift and go to state 57
    CGT             shift and go to state 68
    CGE             shift and go to state 59

    comp_op                        shift and go to state 60

state 72

    (60) while_stmt -> WHILE cond_list COLON . END_STATEMENT body END

    END_STATEMENT   shift and go to state 94


state 73

    (66) for_stmt -> FOR IDENTIFIER IN . RANGE LPAREN INTEGER COMMA INTEGER RPAREN COLON END_STATEMENT body END
    (67) for_stmt -> FOR IDENTIFIER IN . IDENTIFIER COLON END_STATEMENT body END

    RANGE           shift and go to state 95
    IDENTIFIER      shift and go to state 96


state 74

    (20) const_decl -> IDENTIFIER CONST expr .
    (36) arithmetic -> expr . ADD_OP expr
    (37) arithmetic -> expr . SUB_OP expr
    (38) arithmetic -> expr . MUL_OP expr
    (39) arithmetic -> expr . DIV_OP expr
    (40) arithmetic -> expr . MOD_OP expr
    (64) condition -> expr . comp_op expr
    (43) comp_op -> . CEQ
    (44) comp_op -> . CNE
    (45) comp_op -> . CLT
    (46) comp_op -> . CLE
    (47) comp_op -> . CGT
    (48) comp_op -> . CGE

    END_STATEMENT   reduce using rule 20 (const_decl -> IDENTIFIER CONST expr .)
    ADD_OP          shift and go to state 65
    SUB_OP          shift and go to state 61
    MUL_OP          shift and go to state 58
    DIV_OP          shift and go to state 62
    MOD_OP          shift and go to state 67
    CEQ             shift and go to state 64
    CNE             shift and go to state 63
    CLT             shift and go to state 66
    CLE             shift and go to state 57
    CGT             shift and go to state 68
    CGE             shift and go to state 59

    comp_op                        shift and go to state 60

state 75

    (23) call_args -> arg .
    (24) call_args -> arg . COMMA call_args

    RPAREN          reduce using rule 23 (call_args -> arg .)
    COMMA           shift and go to state 97


state 76

    (22) func_call -> IDENTIFIER LPAREN RPAREN .

    ADD_OP          reduce using rule 22 (func_call -> IDENTIFIER LPAREN RPAREN .)
    SUB_OP          reduce using rule 22 (func_call -> IDENTIFIER LPAREN RPAREN .)
    MUL_OP          reduce using rule 22 (func_call -> IDENTIFIER LPAREN RPAREN .)
    DIV_OP          reduce using rule 22 (func_call -> IDENTIFIER LPAREN RPAREN .)
    MOD_OP          reduce using rule 22 (func_call -> IDENTIFIER LPAREN RPAREN .)
    CEQ             reduce using rule 22 (func_call -> IDENTIFIER LPAREN RPAREN .)
    CNE             reduce using rule 22 (func_call -> IDENTIFIER LPAREN RPAREN .)
    CLT             reduce using rule 22 (func_call -> IDENTIFIER LPAREN RPAREN .)
    CLE             reduce using rule 22 (func_call -> IDENTIFIER LPAREN RPAREN .)
    CGT             reduce using rule 22 (func_call -> IDENTIFIER LPAREN RPAREN .)
    CGE             reduce using rule 22 (func_call -> IDENTIFIER LPAREN RPAREN .)
    END_STATEMENT   reduce using rule 22 (func_call -> IDENTIFIER LPAREN RPAREN .)
    COLON           reduce using rule 22 (func_call -> IDENTIFIER LPAREN RPAREN .)
    RPAREN          reduce using rule 22 (func_call -> IDENTIFIER LPAREN RPAREN .)
    COMMA           reduce using rule 22 (func_call -> IDENTIFIER LPAREN RPAREN .)
    OR              reduce using rule 22 (func_call -> IDENTIFIER LPAREN RPAREN .)
    AND             reduce using rule 22 (func_call -> IDENTIFIER LPAREN RPAREN .)


state 77

    (21) func_call -> IDENTIFIER LPAREN call_args . RPAREN

    RPAREN          shift and go to state 98


state 78

    (25) arg -> expr .
    (36) arithmetic -> expr . ADD_OP expr
    (37) arithmetic -> expr . SUB_OP expr
    (38) arithmetic -> expr . MUL_OP expr
    (39) arithmetic -> expr . DIV_OP expr
    (40) arithmetic -> expr . MOD_OP expr
    (64) condition -> expr . comp_op expr
    (43) comp_op -> . CEQ
    (44) comp_op -> . CNE
    (45) comp_op -> . CLT
    (46) comp_op -> . CLE
    (47) comp_op -> . CGT
    (48) comp_op -> . CGE

    COMMA           reduce using rule 25 (arg -> expr .)
    RPAREN          reduce using rule 25 (arg -> expr .)
    ADD_OP          shift and go to state 65
    SUB_OP          shift and go to state 61
    MUL_OP          shift and go to state 58
    DIV_OP          shift and go to state 62
    MOD_OP          shift and go to state 67
    CEQ             shift and go to state 64
    CNE             shift and go to state 63
    CLT             shift and go to state 66
    CLE             shift and go to state 57
    CGT             shift and go to state 68
    CGE             shift and go to state 59

    comp_op                        shift and go to state 60

state 79

    (17) assignment -> IDENTIFIER ASSIGN boolean .
    (65) condition -> boolean .

  ! reduce/reduce conflict for END_STATEMENT resolved using rule 17 (assignment -> IDENTIFIER ASSIGN boolean .)
    END_STATEMENT   reduce using rule 17 (assignment -> IDENTIFIER ASSIGN boolean .)
    OR              reduce using rule 65 (condition -> boolean .)
    AND             reduce using rule 65 (condition -> boolean .)
    ADD_OP          reduce using rule 65 (condition -> boolean .)
    SUB_OP          reduce using rule 65 (condition -> boolean .)
    MUL_OP          reduce using rule 65 (condition -> boolean .)
    DIV_OP          reduce using rule 65 (condition -> boolean .)
    MOD_OP          reduce using rule 65 (condition -> boolean .)
    CEQ             reduce using rule 65 (condition -> boolean .)
    CNE             reduce using rule 65 (condition -> boolean .)
    CLT             reduce using rule 65 (condition -> boolean .)
    CLE             reduce using rule 65 (condition -> boolean .)
    CGT             reduce using rule 65 (condition -> boolean .)
    CGE             reduce using rule 65 (condition -> boolean .)

  ! END_STATEMENT   [ reduce using rule 65 (condition -> boolean .) ]


state 80

    (16) assignment -> IDENTIFIER ASSIGN expr .
    (36) arithmetic -> expr . ADD_OP expr
    (37) arithmetic -> expr . SUB_OP expr
    (38) arithmetic -> expr . MUL_OP expr
    (39) arithmetic -> expr . DIV_OP expr
    (40) arithmetic -> expr . MOD_OP expr
    (64) condition -> expr . comp_op expr
    (43) comp_op -> . CEQ
    (44) comp_op -> . CNE
    (45) comp_op -> . CLT
    (46) comp_op -> . CLE
    (47) comp_op -> . CGT
    (48) comp_op -> . CGE

    END_STATEMENT   reduce using rule 16 (assignment -> IDENTIFIER ASSIGN expr .)
    ADD_OP          shift and go to state 65
    SUB_OP          shift and go to state 61
    MUL_OP          shift and go to state 58
    DIV_OP          shift and go to state 62
    MOD_OP          shift and go to state 67
    CEQ             shift and go to state 64
    CNE             shift and go to state 63
    CLT             shift and go to state 66
    CLE             shift and go to state 57
    CGT             shift and go to state 68
    CGE             shift and go to state 59

    comp_op                        shift and go to state 60

state 81

    (53) func_def -> head END_STATEMENT body . END

    END             shift and go to state 99


state 82

    (58) body -> stmt .
    (59) body -> stmt . body
    (58) body -> . stmt
    (59) body -> . stmt body
    (3) stmt -> . simple_stmt
    (4) stmt -> . compound_stmt
    (5) simple_stmt -> . small_stmt END_STATEMENT
    (49) compound_stmt -> . func_def
    (50) compound_stmt -> . if_stmt
    (51) compound_stmt -> . while_stmt
    (52) compound_stmt -> . for_stmt
    (6) small_stmt -> . assignment
    (7) small_stmt -> . const_decl
    (8) small_stmt -> . expr
    (9) small_stmt -> . return_stmt
    (10) small_stmt -> . loop_stmt
    (53) func_def -> . head END_STATEMENT body END
    (68) if_stmt -> . IF cond_list COLON END_STATEMENT body END
    (69) if_stmt -> . IF cond_list COLON END_STATEMENT body END elseif_list
    (70) if_stmt -> . IF cond_list COLON END_STATEMENT body END elseif_list ELSE COLON END_STATEMENT body END
    (71) if_stmt -> . IF cond_list COLON END_STATEMENT body END ELSE COLON END_STATEMENT body END
    (60) while_stmt -> . WHILE cond_list COLON END_STATEMENT body END
    (66) for_stmt -> . FOR IDENTIFIER IN RANGE LPAREN INTEGER COMMA INTEGER RPAREN COLON END_STATEMENT body END
    (67) for_stmt -> . FOR IDENTIFIER IN IDENTIFIER COLON END_STATEMENT body END
    (16) assignment -> . IDENTIFIER ASSIGN expr
    (17) assignment -> . IDENTIFIER ASSIGN boolean
    (18) assignment -> . ARRAY_CELL ASSIGN expr
    (19) assignment -> . ARRAY_CELL ASSIGN boolean
    (20) const_decl -> . IDENTIFIER CONST expr
    (26) expr -> . IDENTIFIER
    (27) expr -> . ARRAY_CELL
    (28) expr -> . func_call
    (29) expr -> . arithmetic
    (30) expr -> . cond_list
    (31) expr -> . LPAREN expr RPAREN
    (32) expr -> . INTEGER
    (33) expr -> . DOUBLE
    (11) return_stmt -> . RETURN
    (12) return_stmt -> . RETURN expr
    (13) return_stmt -> . RETURN boolean
    (14) loop_stmt -> . BREAK
    (15) loop_stmt -> . CONTINUE
    (54) head -> . FUNCTION IDENTIFIER LPAREN p_func_def_args RPAREN COLON
    (55) head -> . FUNCTION IDENTIFIER LPAREN RPAREN COLON
    (21) func_call -> . IDENTIFIER LPAREN call_args RPAREN
    (22) func_call -> . IDENTIFIER LPAREN RPAREN
    (36) arithmetic -> . expr ADD_OP expr
    (37) arithmetic -> . expr SUB_OP expr
    (38) arithmetic -> . expr MUL_OP expr
    (39) arithmetic -> . expr DIV_OP expr
    (40) arithmetic -> . expr MOD_OP expr
    (61) cond_list -> . condition
    (62) cond_list -> . condition comb_op cond_list
    (63) cond_list -> . LPAREN cond_list RPAREN
    (64) condition -> . expr comp_op expr
    (65) condition -> . boolean
    (34) boolean -> . TRUE
    (35) boolean -> . FALSE

    END             reduce using rule 58 (body -> stmt .)
    IF              shift and go to state 25
    WHILE           shift and go to state 3
    FOR             shift and go to state 8
    IDENTIFIER      shift and go to state 12
    ARRAY_CELL      shift and go to state 2
    LPAREN          shift and go to state 22
    INTEGER         shift and go to state 11
    DOUBLE          shift and go to state 33
    RETURN          shift and go to state 6
    BREAK           shift and go to state 30
    CONTINUE        shift and go to state 32
    FUNCTION        shift and go to state 23
    TRUE            shift and go to state 7
    FALSE           shift and go to state 27

    small_stmt                     shift and go to state 1
    boolean                        shift and go to state 4
    return_stmt                    shift and go to state 5
    const_decl                     shift and go to state 9
    compound_stmt                  shift and go to state 13
    arithmetic                     shift and go to state 14
    body                           shift and go to state 100
    head                           shift and go to state 15
    func_def                       shift and go to state 16
    simple_stmt                    shift and go to state 17
    assignment                     shift and go to state 18
    stmt                           shift and go to state 82
    for_stmt                       shift and go to state 20
    loop_stmt                      shift and go to state 21
    condition                      shift and go to state 24
    func_call                      shift and go to state 26
    if_stmt                        shift and go to state 28
    expr                           shift and go to state 29
    while_stmt                     shift and go to state 31
    cond_list                      shift and go to state 34

state 83

    (31) expr -> LPAREN expr RPAREN .

    ADD_OP          reduce using rule 31 (expr -> LPAREN expr RPAREN .)
    SUB_OP          reduce using rule 31 (expr -> LPAREN expr RPAREN .)
    MUL_OP          reduce using rule 31 (expr -> LPAREN expr RPAREN .)
    DIV_OP          reduce using rule 31 (expr -> LPAREN expr RPAREN .)
    MOD_OP          reduce using rule 31 (expr -> LPAREN expr RPAREN .)
    CEQ             reduce using rule 31 (expr -> LPAREN expr RPAREN .)
    CNE             reduce using rule 31 (expr -> LPAREN expr RPAREN .)
    CLT             reduce using rule 31 (expr -> LPAREN expr RPAREN .)
    CLE             reduce using rule 31 (expr -> LPAREN expr RPAREN .)
    CGT             reduce using rule 31 (expr -> LPAREN expr RPAREN .)
    CGE             reduce using rule 31 (expr -> LPAREN expr RPAREN .)
    END_STATEMENT   reduce using rule 31 (expr -> LPAREN expr RPAREN .)
    COLON           reduce using rule 31 (expr -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 31 (expr -> LPAREN expr RPAREN .)
    COMMA           reduce using rule 31 (expr -> LPAREN expr RPAREN .)
    OR              reduce using rule 31 (expr -> LPAREN expr RPAREN .)
    AND             reduce using rule 31 (expr -> LPAREN expr RPAREN .)


state 84

    (63) cond_list -> LPAREN cond_list RPAREN .

    ADD_OP          reduce using rule 63 (cond_list -> LPAREN cond_list RPAREN .)
    SUB_OP          reduce using rule 63 (cond_list -> LPAREN cond_list RPAREN .)
    MUL_OP          reduce using rule 63 (cond_list -> LPAREN cond_list RPAREN .)
    DIV_OP          reduce using rule 63 (cond_list -> LPAREN cond_list RPAREN .)
    MOD_OP          reduce using rule 63 (cond_list -> LPAREN cond_list RPAREN .)
    CEQ             reduce using rule 63 (cond_list -> LPAREN cond_list RPAREN .)
    CNE             reduce using rule 63 (cond_list -> LPAREN cond_list RPAREN .)
    CLT             reduce using rule 63 (cond_list -> LPAREN cond_list RPAREN .)
    CLE             reduce using rule 63 (cond_list -> LPAREN cond_list RPAREN .)
    CGT             reduce using rule 63 (cond_list -> LPAREN cond_list RPAREN .)
    CGE             reduce using rule 63 (cond_list -> LPAREN cond_list RPAREN .)
    END_STATEMENT   reduce using rule 63 (cond_list -> LPAREN cond_list RPAREN .)
    COLON           reduce using rule 63 (cond_list -> LPAREN cond_list RPAREN .)
    RPAREN          reduce using rule 63 (cond_list -> LPAREN cond_list RPAREN .)
    COMMA           reduce using rule 63 (cond_list -> LPAREN cond_list RPAREN .)
    OR              reduce using rule 63 (cond_list -> LPAREN cond_list RPAREN .)
    AND             reduce using rule 63 (cond_list -> LPAREN cond_list RPAREN .)


state 85

    (54) head -> FUNCTION IDENTIFIER LPAREN . p_func_def_args RPAREN COLON
    (55) head -> FUNCTION IDENTIFIER LPAREN . RPAREN COLON
    (56) p_func_def_args -> . IDENTIFIER
    (57) p_func_def_args -> . IDENTIFIER COMMA p_func_def_args

    RPAREN          shift and go to state 101
    IDENTIFIER      shift and go to state 103

    p_func_def_args                shift and go to state 102

state 86

    (62) cond_list -> condition comb_op cond_list .
    (30) expr -> cond_list .

  ! reduce/reduce conflict for ADD_OP resolved using rule 30 (expr -> cond_list .)
  ! reduce/reduce conflict for SUB_OP resolved using rule 30 (expr -> cond_list .)
  ! reduce/reduce conflict for MUL_OP resolved using rule 30 (expr -> cond_list .)
  ! reduce/reduce conflict for DIV_OP resolved using rule 30 (expr -> cond_list .)
  ! reduce/reduce conflict for MOD_OP resolved using rule 30 (expr -> cond_list .)
  ! reduce/reduce conflict for CEQ resolved using rule 30 (expr -> cond_list .)
  ! reduce/reduce conflict for CNE resolved using rule 30 (expr -> cond_list .)
  ! reduce/reduce conflict for CLT resolved using rule 30 (expr -> cond_list .)
  ! reduce/reduce conflict for CLE resolved using rule 30 (expr -> cond_list .)
  ! reduce/reduce conflict for CGT resolved using rule 30 (expr -> cond_list .)
  ! reduce/reduce conflict for CGE resolved using rule 30 (expr -> cond_list .)
    END_STATEMENT   reduce using rule 62 (cond_list -> condition comb_op cond_list .)
    COLON           reduce using rule 62 (cond_list -> condition comb_op cond_list .)
    RPAREN          reduce using rule 62 (cond_list -> condition comb_op cond_list .)
    COMMA           reduce using rule 62 (cond_list -> condition comb_op cond_list .)
    OR              reduce using rule 62 (cond_list -> condition comb_op cond_list .)
    AND             reduce using rule 62 (cond_list -> condition comb_op cond_list .)
    ADD_OP          reduce using rule 30 (expr -> cond_list .)
    SUB_OP          reduce using rule 30 (expr -> cond_list .)
    MUL_OP          reduce using rule 30 (expr -> cond_list .)
    DIV_OP          reduce using rule 30 (expr -> cond_list .)
    MOD_OP          reduce using rule 30 (expr -> cond_list .)
    CEQ             reduce using rule 30 (expr -> cond_list .)
    CNE             reduce using rule 30 (expr -> cond_list .)
    CLT             reduce using rule 30 (expr -> cond_list .)
    CLE             reduce using rule 30 (expr -> cond_list .)
    CGT             reduce using rule 30 (expr -> cond_list .)
    CGE             reduce using rule 30 (expr -> cond_list .)

  ! ADD_OP          [ reduce using rule 62 (cond_list -> condition comb_op cond_list .) ]
  ! SUB_OP          [ reduce using rule 62 (cond_list -> condition comb_op cond_list .) ]
  ! MUL_OP          [ reduce using rule 62 (cond_list -> condition comb_op cond_list .) ]
  ! DIV_OP          [ reduce using rule 62 (cond_list -> condition comb_op cond_list .) ]
  ! MOD_OP          [ reduce using rule 62 (cond_list -> condition comb_op cond_list .) ]
  ! CEQ             [ reduce using rule 62 (cond_list -> condition comb_op cond_list .) ]
  ! CNE             [ reduce using rule 62 (cond_list -> condition comb_op cond_list .) ]
  ! CLT             [ reduce using rule 62 (cond_list -> condition comb_op cond_list .) ]
  ! CLE             [ reduce using rule 62 (cond_list -> condition comb_op cond_list .) ]
  ! CGT             [ reduce using rule 62 (cond_list -> condition comb_op cond_list .) ]
  ! CGE             [ reduce using rule 62 (cond_list -> condition comb_op cond_list .) ]


state 87

    (68) if_stmt -> IF cond_list COLON . END_STATEMENT body END
    (69) if_stmt -> IF cond_list COLON . END_STATEMENT body END elseif_list
    (70) if_stmt -> IF cond_list COLON . END_STATEMENT body END elseif_list ELSE COLON END_STATEMENT body END
    (71) if_stmt -> IF cond_list COLON . END_STATEMENT body END ELSE COLON END_STATEMENT body END

    END_STATEMENT   shift and go to state 104


state 88

    (38) arithmetic -> expr MUL_OP expr .
    (36) arithmetic -> expr . ADD_OP expr
    (37) arithmetic -> expr . SUB_OP expr
    (38) arithmetic -> expr . MUL_OP expr
    (39) arithmetic -> expr . DIV_OP expr
    (40) arithmetic -> expr . MOD_OP expr
    (64) condition -> expr . comp_op expr
    (43) comp_op -> . CEQ
    (44) comp_op -> . CNE
    (45) comp_op -> . CLT
    (46) comp_op -> . CLE
    (47) comp_op -> . CGT
    (48) comp_op -> . CGE

    ADD_OP          reduce using rule 38 (arithmetic -> expr MUL_OP expr .)
    SUB_OP          reduce using rule 38 (arithmetic -> expr MUL_OP expr .)
    MUL_OP          reduce using rule 38 (arithmetic -> expr MUL_OP expr .)
    DIV_OP          reduce using rule 38 (arithmetic -> expr MUL_OP expr .)
    MOD_OP          reduce using rule 38 (arithmetic -> expr MUL_OP expr .)
    CEQ             reduce using rule 38 (arithmetic -> expr MUL_OP expr .)
    CNE             reduce using rule 38 (arithmetic -> expr MUL_OP expr .)
    CLT             reduce using rule 38 (arithmetic -> expr MUL_OP expr .)
    CLE             reduce using rule 38 (arithmetic -> expr MUL_OP expr .)
    CGT             reduce using rule 38 (arithmetic -> expr MUL_OP expr .)
    CGE             reduce using rule 38 (arithmetic -> expr MUL_OP expr .)
    END_STATEMENT   reduce using rule 38 (arithmetic -> expr MUL_OP expr .)
    RPAREN          reduce using rule 38 (arithmetic -> expr MUL_OP expr .)
    COLON           reduce using rule 38 (arithmetic -> expr MUL_OP expr .)
    COMMA           reduce using rule 38 (arithmetic -> expr MUL_OP expr .)
    OR              reduce using rule 38 (arithmetic -> expr MUL_OP expr .)
    AND             reduce using rule 38 (arithmetic -> expr MUL_OP expr .)

  ! ADD_OP          [ shift and go to state 65 ]
  ! SUB_OP          [ shift and go to state 61 ]
  ! MUL_OP          [ shift and go to state 58 ]
  ! DIV_OP          [ shift and go to state 62 ]
  ! MOD_OP          [ shift and go to state 67 ]
  ! CEQ             [ shift and go to state 64 ]
  ! CNE             [ shift and go to state 63 ]
  ! CLT             [ shift and go to state 66 ]
  ! CLE             [ shift and go to state 57 ]
  ! CGT             [ shift and go to state 68 ]
  ! CGE             [ shift and go to state 59 ]

    comp_op                        shift and go to state 60

state 89

    (64) condition -> expr comp_op expr .
    (36) arithmetic -> expr . ADD_OP expr
    (37) arithmetic -> expr . SUB_OP expr
    (38) arithmetic -> expr . MUL_OP expr
    (39) arithmetic -> expr . DIV_OP expr
    (40) arithmetic -> expr . MOD_OP expr
    (64) condition -> expr . comp_op expr
    (43) comp_op -> . CEQ
    (44) comp_op -> . CNE
    (45) comp_op -> . CLT
    (46) comp_op -> . CLE
    (47) comp_op -> . CGT
    (48) comp_op -> . CGE

  ! shift/reduce conflict for ADD_OP resolved as shift
  ! shift/reduce conflict for SUB_OP resolved as shift
  ! shift/reduce conflict for MUL_OP resolved as shift
  ! shift/reduce conflict for DIV_OP resolved as shift
  ! shift/reduce conflict for MOD_OP resolved as shift
  ! shift/reduce conflict for CEQ resolved as shift
  ! shift/reduce conflict for CNE resolved as shift
  ! shift/reduce conflict for CLT resolved as shift
  ! shift/reduce conflict for CLE resolved as shift
  ! shift/reduce conflict for CGT resolved as shift
  ! shift/reduce conflict for CGE resolved as shift
    OR              reduce using rule 64 (condition -> expr comp_op expr .)
    AND             reduce using rule 64 (condition -> expr comp_op expr .)
    END_STATEMENT   reduce using rule 64 (condition -> expr comp_op expr .)
    COLON           reduce using rule 64 (condition -> expr comp_op expr .)
    RPAREN          reduce using rule 64 (condition -> expr comp_op expr .)
    COMMA           reduce using rule 64 (condition -> expr comp_op expr .)
    ADD_OP          shift and go to state 65
    SUB_OP          shift and go to state 61
    MUL_OP          shift and go to state 58
    DIV_OP          shift and go to state 62
    MOD_OP          shift and go to state 67
    CEQ             shift and go to state 64
    CNE             shift and go to state 63
    CLT             shift and go to state 66
    CLE             shift and go to state 57
    CGT             shift and go to state 68
    CGE             shift and go to state 59

  ! ADD_OP          [ reduce using rule 64 (condition -> expr comp_op expr .) ]
  ! SUB_OP          [ reduce using rule 64 (condition -> expr comp_op expr .) ]
  ! MUL_OP          [ reduce using rule 64 (condition -> expr comp_op expr .) ]
  ! DIV_OP          [ reduce using rule 64 (condition -> expr comp_op expr .) ]
  ! MOD_OP          [ reduce using rule 64 (condition -> expr comp_op expr .) ]
  ! CEQ             [ reduce using rule 64 (condition -> expr comp_op expr .) ]
  ! CNE             [ reduce using rule 64 (condition -> expr comp_op expr .) ]
  ! CLT             [ reduce using rule 64 (condition -> expr comp_op expr .) ]
  ! CLE             [ reduce using rule 64 (condition -> expr comp_op expr .) ]
  ! CGT             [ reduce using rule 64 (condition -> expr comp_op expr .) ]
  ! CGE             [ reduce using rule 64 (condition -> expr comp_op expr .) ]

    comp_op                        shift and go to state 60

state 90

    (37) arithmetic -> expr SUB_OP expr .
    (36) arithmetic -> expr . ADD_OP expr
    (37) arithmetic -> expr . SUB_OP expr
    (38) arithmetic -> expr . MUL_OP expr
    (39) arithmetic -> expr . DIV_OP expr
    (40) arithmetic -> expr . MOD_OP expr
    (64) condition -> expr . comp_op expr
    (43) comp_op -> . CEQ
    (44) comp_op -> . CNE
    (45) comp_op -> . CLT
    (46) comp_op -> . CLE
    (47) comp_op -> . CGT
    (48) comp_op -> . CGE

    ADD_OP          reduce using rule 37 (arithmetic -> expr SUB_OP expr .)
    SUB_OP          reduce using rule 37 (arithmetic -> expr SUB_OP expr .)
    CEQ             reduce using rule 37 (arithmetic -> expr SUB_OP expr .)
    CNE             reduce using rule 37 (arithmetic -> expr SUB_OP expr .)
    CLT             reduce using rule 37 (arithmetic -> expr SUB_OP expr .)
    CLE             reduce using rule 37 (arithmetic -> expr SUB_OP expr .)
    CGT             reduce using rule 37 (arithmetic -> expr SUB_OP expr .)
    CGE             reduce using rule 37 (arithmetic -> expr SUB_OP expr .)
    END_STATEMENT   reduce using rule 37 (arithmetic -> expr SUB_OP expr .)
    RPAREN          reduce using rule 37 (arithmetic -> expr SUB_OP expr .)
    COLON           reduce using rule 37 (arithmetic -> expr SUB_OP expr .)
    COMMA           reduce using rule 37 (arithmetic -> expr SUB_OP expr .)
    OR              reduce using rule 37 (arithmetic -> expr SUB_OP expr .)
    AND             reduce using rule 37 (arithmetic -> expr SUB_OP expr .)
    MUL_OP          shift and go to state 58
    DIV_OP          shift and go to state 62
    MOD_OP          shift and go to state 67

  ! MUL_OP          [ reduce using rule 37 (arithmetic -> expr SUB_OP expr .) ]
  ! DIV_OP          [ reduce using rule 37 (arithmetic -> expr SUB_OP expr .) ]
  ! MOD_OP          [ reduce using rule 37 (arithmetic -> expr SUB_OP expr .) ]
  ! ADD_OP          [ shift and go to state 65 ]
  ! SUB_OP          [ shift and go to state 61 ]
  ! CEQ             [ shift and go to state 64 ]
  ! CNE             [ shift and go to state 63 ]
  ! CLT             [ shift and go to state 66 ]
  ! CLE             [ shift and go to state 57 ]
  ! CGT             [ shift and go to state 68 ]
  ! CGE             [ shift and go to state 59 ]

    comp_op                        shift and go to state 60

state 91

    (39) arithmetic -> expr DIV_OP expr .
    (36) arithmetic -> expr . ADD_OP expr
    (37) arithmetic -> expr . SUB_OP expr
    (38) arithmetic -> expr . MUL_OP expr
    (39) arithmetic -> expr . DIV_OP expr
    (40) arithmetic -> expr . MOD_OP expr
    (64) condition -> expr . comp_op expr
    (43) comp_op -> . CEQ
    (44) comp_op -> . CNE
    (45) comp_op -> . CLT
    (46) comp_op -> . CLE
    (47) comp_op -> . CGT
    (48) comp_op -> . CGE

    ADD_OP          reduce using rule 39 (arithmetic -> expr DIV_OP expr .)
    SUB_OP          reduce using rule 39 (arithmetic -> expr DIV_OP expr .)
    MUL_OP          reduce using rule 39 (arithmetic -> expr DIV_OP expr .)
    DIV_OP          reduce using rule 39 (arithmetic -> expr DIV_OP expr .)
    MOD_OP          reduce using rule 39 (arithmetic -> expr DIV_OP expr .)
    CEQ             reduce using rule 39 (arithmetic -> expr DIV_OP expr .)
    CNE             reduce using rule 39 (arithmetic -> expr DIV_OP expr .)
    CLT             reduce using rule 39 (arithmetic -> expr DIV_OP expr .)
    CLE             reduce using rule 39 (arithmetic -> expr DIV_OP expr .)
    CGT             reduce using rule 39 (arithmetic -> expr DIV_OP expr .)
    CGE             reduce using rule 39 (arithmetic -> expr DIV_OP expr .)
    END_STATEMENT   reduce using rule 39 (arithmetic -> expr DIV_OP expr .)
    RPAREN          reduce using rule 39 (arithmetic -> expr DIV_OP expr .)
    COLON           reduce using rule 39 (arithmetic -> expr DIV_OP expr .)
    COMMA           reduce using rule 39 (arithmetic -> expr DIV_OP expr .)
    OR              reduce using rule 39 (arithmetic -> expr DIV_OP expr .)
    AND             reduce using rule 39 (arithmetic -> expr DIV_OP expr .)

  ! ADD_OP          [ shift and go to state 65 ]
  ! SUB_OP          [ shift and go to state 61 ]
  ! MUL_OP          [ shift and go to state 58 ]
  ! DIV_OP          [ shift and go to state 62 ]
  ! MOD_OP          [ shift and go to state 67 ]
  ! CEQ             [ shift and go to state 64 ]
  ! CNE             [ shift and go to state 63 ]
  ! CLT             [ shift and go to state 66 ]
  ! CLE             [ shift and go to state 57 ]
  ! CGT             [ shift and go to state 68 ]
  ! CGE             [ shift and go to state 59 ]

    comp_op                        shift and go to state 60

state 92

    (36) arithmetic -> expr ADD_OP expr .
    (36) arithmetic -> expr . ADD_OP expr
    (37) arithmetic -> expr . SUB_OP expr
    (38) arithmetic -> expr . MUL_OP expr
    (39) arithmetic -> expr . DIV_OP expr
    (40) arithmetic -> expr . MOD_OP expr
    (64) condition -> expr . comp_op expr
    (43) comp_op -> . CEQ
    (44) comp_op -> . CNE
    (45) comp_op -> . CLT
    (46) comp_op -> . CLE
    (47) comp_op -> . CGT
    (48) comp_op -> . CGE

    ADD_OP          reduce using rule 36 (arithmetic -> expr ADD_OP expr .)
    SUB_OP          reduce using rule 36 (arithmetic -> expr ADD_OP expr .)
    CEQ             reduce using rule 36 (arithmetic -> expr ADD_OP expr .)
    CNE             reduce using rule 36 (arithmetic -> expr ADD_OP expr .)
    CLT             reduce using rule 36 (arithmetic -> expr ADD_OP expr .)
    CLE             reduce using rule 36 (arithmetic -> expr ADD_OP expr .)
    CGT             reduce using rule 36 (arithmetic -> expr ADD_OP expr .)
    CGE             reduce using rule 36 (arithmetic -> expr ADD_OP expr .)
    END_STATEMENT   reduce using rule 36 (arithmetic -> expr ADD_OP expr .)
    RPAREN          reduce using rule 36 (arithmetic -> expr ADD_OP expr .)
    COLON           reduce using rule 36 (arithmetic -> expr ADD_OP expr .)
    COMMA           reduce using rule 36 (arithmetic -> expr ADD_OP expr .)
    OR              reduce using rule 36 (arithmetic -> expr ADD_OP expr .)
    AND             reduce using rule 36 (arithmetic -> expr ADD_OP expr .)
    MUL_OP          shift and go to state 58
    DIV_OP          shift and go to state 62
    MOD_OP          shift and go to state 67

  ! MUL_OP          [ reduce using rule 36 (arithmetic -> expr ADD_OP expr .) ]
  ! DIV_OP          [ reduce using rule 36 (arithmetic -> expr ADD_OP expr .) ]
  ! MOD_OP          [ reduce using rule 36 (arithmetic -> expr ADD_OP expr .) ]
  ! ADD_OP          [ shift and go to state 65 ]
  ! SUB_OP          [ shift and go to state 61 ]
  ! CEQ             [ shift and go to state 64 ]
  ! CNE             [ shift and go to state 63 ]
  ! CLT             [ shift and go to state 66 ]
  ! CLE             [ shift and go to state 57 ]
  ! CGT             [ shift and go to state 68 ]
  ! CGE             [ shift and go to state 59 ]

    comp_op                        shift and go to state 60

state 93

    (40) arithmetic -> expr MOD_OP expr .
    (36) arithmetic -> expr . ADD_OP expr
    (37) arithmetic -> expr . SUB_OP expr
    (38) arithmetic -> expr . MUL_OP expr
    (39) arithmetic -> expr . DIV_OP expr
    (40) arithmetic -> expr . MOD_OP expr
    (64) condition -> expr . comp_op expr
    (43) comp_op -> . CEQ
    (44) comp_op -> . CNE
    (45) comp_op -> . CLT
    (46) comp_op -> . CLE
    (47) comp_op -> . CGT
    (48) comp_op -> . CGE

    ADD_OP          reduce using rule 40 (arithmetic -> expr MOD_OP expr .)
    SUB_OP          reduce using rule 40 (arithmetic -> expr MOD_OP expr .)
    MUL_OP          reduce using rule 40 (arithmetic -> expr MOD_OP expr .)
    DIV_OP          reduce using rule 40 (arithmetic -> expr MOD_OP expr .)
    MOD_OP          reduce using rule 40 (arithmetic -> expr MOD_OP expr .)
    CEQ             reduce using rule 40 (arithmetic -> expr MOD_OP expr .)
    CNE             reduce using rule 40 (arithmetic -> expr MOD_OP expr .)
    CLT             reduce using rule 40 (arithmetic -> expr MOD_OP expr .)
    CLE             reduce using rule 40 (arithmetic -> expr MOD_OP expr .)
    CGT             reduce using rule 40 (arithmetic -> expr MOD_OP expr .)
    CGE             reduce using rule 40 (arithmetic -> expr MOD_OP expr .)
    END_STATEMENT   reduce using rule 40 (arithmetic -> expr MOD_OP expr .)
    RPAREN          reduce using rule 40 (arithmetic -> expr MOD_OP expr .)
    COLON           reduce using rule 40 (arithmetic -> expr MOD_OP expr .)
    COMMA           reduce using rule 40 (arithmetic -> expr MOD_OP expr .)
    OR              reduce using rule 40 (arithmetic -> expr MOD_OP expr .)
    AND             reduce using rule 40 (arithmetic -> expr MOD_OP expr .)

  ! ADD_OP          [ shift and go to state 65 ]
  ! SUB_OP          [ shift and go to state 61 ]
  ! MUL_OP          [ shift and go to state 58 ]
  ! DIV_OP          [ shift and go to state 62 ]
  ! MOD_OP          [ shift and go to state 67 ]
  ! CEQ             [ shift and go to state 64 ]
  ! CNE             [ shift and go to state 63 ]
  ! CLT             [ shift and go to state 66 ]
  ! CLE             [ shift and go to state 57 ]
  ! CGT             [ shift and go to state 68 ]
  ! CGE             [ shift and go to state 59 ]

    comp_op                        shift and go to state 60

state 94

    (60) while_stmt -> WHILE cond_list COLON END_STATEMENT . body END
    (58) body -> . stmt
    (59) body -> . stmt body
    (3) stmt -> . simple_stmt
    (4) stmt -> . compound_stmt
    (5) simple_stmt -> . small_stmt END_STATEMENT
    (49) compound_stmt -> . func_def
    (50) compound_stmt -> . if_stmt
    (51) compound_stmt -> . while_stmt
    (52) compound_stmt -> . for_stmt
    (6) small_stmt -> . assignment
    (7) small_stmt -> . const_decl
    (8) small_stmt -> . expr
    (9) small_stmt -> . return_stmt
    (10) small_stmt -> . loop_stmt
    (53) func_def -> . head END_STATEMENT body END
    (68) if_stmt -> . IF cond_list COLON END_STATEMENT body END
    (69) if_stmt -> . IF cond_list COLON END_STATEMENT body END elseif_list
    (70) if_stmt -> . IF cond_list COLON END_STATEMENT body END elseif_list ELSE COLON END_STATEMENT body END
    (71) if_stmt -> . IF cond_list COLON END_STATEMENT body END ELSE COLON END_STATEMENT body END
    (60) while_stmt -> . WHILE cond_list COLON END_STATEMENT body END
    (66) for_stmt -> . FOR IDENTIFIER IN RANGE LPAREN INTEGER COMMA INTEGER RPAREN COLON END_STATEMENT body END
    (67) for_stmt -> . FOR IDENTIFIER IN IDENTIFIER COLON END_STATEMENT body END
    (16) assignment -> . IDENTIFIER ASSIGN expr
    (17) assignment -> . IDENTIFIER ASSIGN boolean
    (18) assignment -> . ARRAY_CELL ASSIGN expr
    (19) assignment -> . ARRAY_CELL ASSIGN boolean
    (20) const_decl -> . IDENTIFIER CONST expr
    (26) expr -> . IDENTIFIER
    (27) expr -> . ARRAY_CELL
    (28) expr -> . func_call
    (29) expr -> . arithmetic
    (30) expr -> . cond_list
    (31) expr -> . LPAREN expr RPAREN
    (32) expr -> . INTEGER
    (33) expr -> . DOUBLE
    (11) return_stmt -> . RETURN
    (12) return_stmt -> . RETURN expr
    (13) return_stmt -> . RETURN boolean
    (14) loop_stmt -> . BREAK
    (15) loop_stmt -> . CONTINUE
    (54) head -> . FUNCTION IDENTIFIER LPAREN p_func_def_args RPAREN COLON
    (55) head -> . FUNCTION IDENTIFIER LPAREN RPAREN COLON
    (21) func_call -> . IDENTIFIER LPAREN call_args RPAREN
    (22) func_call -> . IDENTIFIER LPAREN RPAREN
    (36) arithmetic -> . expr ADD_OP expr
    (37) arithmetic -> . expr SUB_OP expr
    (38) arithmetic -> . expr MUL_OP expr
    (39) arithmetic -> . expr DIV_OP expr
    (40) arithmetic -> . expr MOD_OP expr
    (61) cond_list -> . condition
    (62) cond_list -> . condition comb_op cond_list
    (63) cond_list -> . LPAREN cond_list RPAREN
    (64) condition -> . expr comp_op expr
    (65) condition -> . boolean
    (34) boolean -> . TRUE
    (35) boolean -> . FALSE

    IF              shift and go to state 25
    WHILE           shift and go to state 3
    FOR             shift and go to state 8
    IDENTIFIER      shift and go to state 12
    ARRAY_CELL      shift and go to state 2
    LPAREN          shift and go to state 22
    INTEGER         shift and go to state 11
    DOUBLE          shift and go to state 33
    RETURN          shift and go to state 6
    BREAK           shift and go to state 30
    CONTINUE        shift and go to state 32
    FUNCTION        shift and go to state 23
    TRUE            shift and go to state 7
    FALSE           shift and go to state 27

    small_stmt                     shift and go to state 1
    boolean                        shift and go to state 4
    return_stmt                    shift and go to state 5
    const_decl                     shift and go to state 9
    compound_stmt                  shift and go to state 13
    arithmetic                     shift and go to state 14
    body                           shift and go to state 105
    head                           shift and go to state 15
    func_def                       shift and go to state 16
    simple_stmt                    shift and go to state 17
    assignment                     shift and go to state 18
    stmt                           shift and go to state 82
    for_stmt                       shift and go to state 20
    loop_stmt                      shift and go to state 21
    condition                      shift and go to state 24
    func_call                      shift and go to state 26
    if_stmt                        shift and go to state 28
    expr                           shift and go to state 29
    while_stmt                     shift and go to state 31
    cond_list                      shift and go to state 34

state 95

    (66) for_stmt -> FOR IDENTIFIER IN RANGE . LPAREN INTEGER COMMA INTEGER RPAREN COLON END_STATEMENT body END

    LPAREN          shift and go to state 106


state 96

    (67) for_stmt -> FOR IDENTIFIER IN IDENTIFIER . COLON END_STATEMENT body END

    COLON           shift and go to state 107


state 97

    (24) call_args -> arg COMMA . call_args
    (23) call_args -> . arg
    (24) call_args -> . arg COMMA call_args
    (25) arg -> . expr
    (26) expr -> . IDENTIFIER
    (27) expr -> . ARRAY_CELL
    (28) expr -> . func_call
    (29) expr -> . arithmetic
    (30) expr -> . cond_list
    (31) expr -> . LPAREN expr RPAREN
    (32) expr -> . INTEGER
    (33) expr -> . DOUBLE
    (21) func_call -> . IDENTIFIER LPAREN call_args RPAREN
    (22) func_call -> . IDENTIFIER LPAREN RPAREN
    (36) arithmetic -> . expr ADD_OP expr
    (37) arithmetic -> . expr SUB_OP expr
    (38) arithmetic -> . expr MUL_OP expr
    (39) arithmetic -> . expr DIV_OP expr
    (40) arithmetic -> . expr MOD_OP expr
    (61) cond_list -> . condition
    (62) cond_list -> . condition comb_op cond_list
    (63) cond_list -> . LPAREN cond_list RPAREN
    (64) condition -> . expr comp_op expr
    (65) condition -> . boolean
    (34) boolean -> . TRUE
    (35) boolean -> . FALSE

    IDENTIFIER      shift and go to state 38
    ARRAY_CELL      shift and go to state 37
    LPAREN          shift and go to state 22
    INTEGER         shift and go to state 11
    DOUBLE          shift and go to state 33
    TRUE            shift and go to state 7
    FALSE           shift and go to state 27

    func_call                      shift and go to state 26
    expr                           shift and go to state 78
    condition                      shift and go to state 24
    boolean                        shift and go to state 4
    call_args                      shift and go to state 108
    arg                            shift and go to state 75
    cond_list                      shift and go to state 34
    arithmetic                     shift and go to state 14

state 98

    (21) func_call -> IDENTIFIER LPAREN call_args RPAREN .

    ADD_OP          reduce using rule 21 (func_call -> IDENTIFIER LPAREN call_args RPAREN .)
    SUB_OP          reduce using rule 21 (func_call -> IDENTIFIER LPAREN call_args RPAREN .)
    MUL_OP          reduce using rule 21 (func_call -> IDENTIFIER LPAREN call_args RPAREN .)
    DIV_OP          reduce using rule 21 (func_call -> IDENTIFIER LPAREN call_args RPAREN .)
    MOD_OP          reduce using rule 21 (func_call -> IDENTIFIER LPAREN call_args RPAREN .)
    CEQ             reduce using rule 21 (func_call -> IDENTIFIER LPAREN call_args RPAREN .)
    CNE             reduce using rule 21 (func_call -> IDENTIFIER LPAREN call_args RPAREN .)
    CLT             reduce using rule 21 (func_call -> IDENTIFIER LPAREN call_args RPAREN .)
    CLE             reduce using rule 21 (func_call -> IDENTIFIER LPAREN call_args RPAREN .)
    CGT             reduce using rule 21 (func_call -> IDENTIFIER LPAREN call_args RPAREN .)
    CGE             reduce using rule 21 (func_call -> IDENTIFIER LPAREN call_args RPAREN .)
    END_STATEMENT   reduce using rule 21 (func_call -> IDENTIFIER LPAREN call_args RPAREN .)
    COLON           reduce using rule 21 (func_call -> IDENTIFIER LPAREN call_args RPAREN .)
    RPAREN          reduce using rule 21 (func_call -> IDENTIFIER LPAREN call_args RPAREN .)
    COMMA           reduce using rule 21 (func_call -> IDENTIFIER LPAREN call_args RPAREN .)
    OR              reduce using rule 21 (func_call -> IDENTIFIER LPAREN call_args RPAREN .)
    AND             reduce using rule 21 (func_call -> IDENTIFIER LPAREN call_args RPAREN .)


state 99

    (53) func_def -> head END_STATEMENT body END .

    IF              reduce using rule 53 (func_def -> head END_STATEMENT body END .)
    WHILE           reduce using rule 53 (func_def -> head END_STATEMENT body END .)
    FOR             reduce using rule 53 (func_def -> head END_STATEMENT body END .)
    IDENTIFIER      reduce using rule 53 (func_def -> head END_STATEMENT body END .)
    ARRAY_CELL      reduce using rule 53 (func_def -> head END_STATEMENT body END .)
    LPAREN          reduce using rule 53 (func_def -> head END_STATEMENT body END .)
    INTEGER         reduce using rule 53 (func_def -> head END_STATEMENT body END .)
    DOUBLE          reduce using rule 53 (func_def -> head END_STATEMENT body END .)
    RETURN          reduce using rule 53 (func_def -> head END_STATEMENT body END .)
    BREAK           reduce using rule 53 (func_def -> head END_STATEMENT body END .)
    CONTINUE        reduce using rule 53 (func_def -> head END_STATEMENT body END .)
    FUNCTION        reduce using rule 53 (func_def -> head END_STATEMENT body END .)
    TRUE            reduce using rule 53 (func_def -> head END_STATEMENT body END .)
    FALSE           reduce using rule 53 (func_def -> head END_STATEMENT body END .)
    END             reduce using rule 53 (func_def -> head END_STATEMENT body END .)
    $end            reduce using rule 53 (func_def -> head END_STATEMENT body END .)


state 100

    (59) body -> stmt body .

    END             reduce using rule 59 (body -> stmt body .)


state 101

    (55) head -> FUNCTION IDENTIFIER LPAREN RPAREN . COLON

    COLON           shift and go to state 109


state 102

    (54) head -> FUNCTION IDENTIFIER LPAREN p_func_def_args . RPAREN COLON

    RPAREN          shift and go to state 110


state 103

    (56) p_func_def_args -> IDENTIFIER .
    (57) p_func_def_args -> IDENTIFIER . COMMA p_func_def_args

    RPAREN          reduce using rule 56 (p_func_def_args -> IDENTIFIER .)
    COMMA           shift and go to state 111


state 104

    (68) if_stmt -> IF cond_list COLON END_STATEMENT . body END
    (69) if_stmt -> IF cond_list COLON END_STATEMENT . body END elseif_list
    (70) if_stmt -> IF cond_list COLON END_STATEMENT . body END elseif_list ELSE COLON END_STATEMENT body END
    (71) if_stmt -> IF cond_list COLON END_STATEMENT . body END ELSE COLON END_STATEMENT body END
    (58) body -> . stmt
    (59) body -> . stmt body
    (3) stmt -> . simple_stmt
    (4) stmt -> . compound_stmt
    (5) simple_stmt -> . small_stmt END_STATEMENT
    (49) compound_stmt -> . func_def
    (50) compound_stmt -> . if_stmt
    (51) compound_stmt -> . while_stmt
    (52) compound_stmt -> . for_stmt
    (6) small_stmt -> . assignment
    (7) small_stmt -> . const_decl
    (8) small_stmt -> . expr
    (9) small_stmt -> . return_stmt
    (10) small_stmt -> . loop_stmt
    (53) func_def -> . head END_STATEMENT body END
    (68) if_stmt -> . IF cond_list COLON END_STATEMENT body END
    (69) if_stmt -> . IF cond_list COLON END_STATEMENT body END elseif_list
    (70) if_stmt -> . IF cond_list COLON END_STATEMENT body END elseif_list ELSE COLON END_STATEMENT body END
    (71) if_stmt -> . IF cond_list COLON END_STATEMENT body END ELSE COLON END_STATEMENT body END
    (60) while_stmt -> . WHILE cond_list COLON END_STATEMENT body END
    (66) for_stmt -> . FOR IDENTIFIER IN RANGE LPAREN INTEGER COMMA INTEGER RPAREN COLON END_STATEMENT body END
    (67) for_stmt -> . FOR IDENTIFIER IN IDENTIFIER COLON END_STATEMENT body END
    (16) assignment -> . IDENTIFIER ASSIGN expr
    (17) assignment -> . IDENTIFIER ASSIGN boolean
    (18) assignment -> . ARRAY_CELL ASSIGN expr
    (19) assignment -> . ARRAY_CELL ASSIGN boolean
    (20) const_decl -> . IDENTIFIER CONST expr
    (26) expr -> . IDENTIFIER
    (27) expr -> . ARRAY_CELL
    (28) expr -> . func_call
    (29) expr -> . arithmetic
    (30) expr -> . cond_list
    (31) expr -> . LPAREN expr RPAREN
    (32) expr -> . INTEGER
    (33) expr -> . DOUBLE
    (11) return_stmt -> . RETURN
    (12) return_stmt -> . RETURN expr
    (13) return_stmt -> . RETURN boolean
    (14) loop_stmt -> . BREAK
    (15) loop_stmt -> . CONTINUE
    (54) head -> . FUNCTION IDENTIFIER LPAREN p_func_def_args RPAREN COLON
    (55) head -> . FUNCTION IDENTIFIER LPAREN RPAREN COLON
    (21) func_call -> . IDENTIFIER LPAREN call_args RPAREN
    (22) func_call -> . IDENTIFIER LPAREN RPAREN
    (36) arithmetic -> . expr ADD_OP expr
    (37) arithmetic -> . expr SUB_OP expr
    (38) arithmetic -> . expr MUL_OP expr
    (39) arithmetic -> . expr DIV_OP expr
    (40) arithmetic -> . expr MOD_OP expr
    (61) cond_list -> . condition
    (62) cond_list -> . condition comb_op cond_list
    (63) cond_list -> . LPAREN cond_list RPAREN
    (64) condition -> . expr comp_op expr
    (65) condition -> . boolean
    (34) boolean -> . TRUE
    (35) boolean -> . FALSE

    IF              shift and go to state 25
    WHILE           shift and go to state 3
    FOR             shift and go to state 8
    IDENTIFIER      shift and go to state 12
    ARRAY_CELL      shift and go to state 2
    LPAREN          shift and go to state 22
    INTEGER         shift and go to state 11
    DOUBLE          shift and go to state 33
    RETURN          shift and go to state 6
    BREAK           shift and go to state 30
    CONTINUE        shift and go to state 32
    FUNCTION        shift and go to state 23
    TRUE            shift and go to state 7
    FALSE           shift and go to state 27

    small_stmt                     shift and go to state 1
    boolean                        shift and go to state 4
    return_stmt                    shift and go to state 5
    const_decl                     shift and go to state 9
    compound_stmt                  shift and go to state 13
    arithmetic                     shift and go to state 14
    body                           shift and go to state 112
    head                           shift and go to state 15
    func_def                       shift and go to state 16
    simple_stmt                    shift and go to state 17
    assignment                     shift and go to state 18
    stmt                           shift and go to state 82
    for_stmt                       shift and go to state 20
    loop_stmt                      shift and go to state 21
    condition                      shift and go to state 24
    func_call                      shift and go to state 26
    if_stmt                        shift and go to state 28
    expr                           shift and go to state 29
    while_stmt                     shift and go to state 31
    cond_list                      shift and go to state 34

state 105

    (60) while_stmt -> WHILE cond_list COLON END_STATEMENT body . END

    END             shift and go to state 113


state 106

    (66) for_stmt -> FOR IDENTIFIER IN RANGE LPAREN . INTEGER COMMA INTEGER RPAREN COLON END_STATEMENT body END

    INTEGER         shift and go to state 114


state 107

    (67) for_stmt -> FOR IDENTIFIER IN IDENTIFIER COLON . END_STATEMENT body END

    END_STATEMENT   shift and go to state 115


state 108

    (24) call_args -> arg COMMA call_args .

    RPAREN          reduce using rule 24 (call_args -> arg COMMA call_args .)


state 109

    (55) head -> FUNCTION IDENTIFIER LPAREN RPAREN COLON .

    END_STATEMENT   reduce using rule 55 (head -> FUNCTION IDENTIFIER LPAREN RPAREN COLON .)


state 110

    (54) head -> FUNCTION IDENTIFIER LPAREN p_func_def_args RPAREN . COLON

    COLON           shift and go to state 116


state 111

    (57) p_func_def_args -> IDENTIFIER COMMA . p_func_def_args
    (56) p_func_def_args -> . IDENTIFIER
    (57) p_func_def_args -> . IDENTIFIER COMMA p_func_def_args

    IDENTIFIER      shift and go to state 103

    p_func_def_args                shift and go to state 117

state 112

    (68) if_stmt -> IF cond_list COLON END_STATEMENT body . END
    (69) if_stmt -> IF cond_list COLON END_STATEMENT body . END elseif_list
    (70) if_stmt -> IF cond_list COLON END_STATEMENT body . END elseif_list ELSE COLON END_STATEMENT body END
    (71) if_stmt -> IF cond_list COLON END_STATEMENT body . END ELSE COLON END_STATEMENT body END

    END             shift and go to state 118


state 113

    (60) while_stmt -> WHILE cond_list COLON END_STATEMENT body END .

    IF              reduce using rule 60 (while_stmt -> WHILE cond_list COLON END_STATEMENT body END .)
    WHILE           reduce using rule 60 (while_stmt -> WHILE cond_list COLON END_STATEMENT body END .)
    FOR             reduce using rule 60 (while_stmt -> WHILE cond_list COLON END_STATEMENT body END .)
    IDENTIFIER      reduce using rule 60 (while_stmt -> WHILE cond_list COLON END_STATEMENT body END .)
    ARRAY_CELL      reduce using rule 60 (while_stmt -> WHILE cond_list COLON END_STATEMENT body END .)
    LPAREN          reduce using rule 60 (while_stmt -> WHILE cond_list COLON END_STATEMENT body END .)
    INTEGER         reduce using rule 60 (while_stmt -> WHILE cond_list COLON END_STATEMENT body END .)
    DOUBLE          reduce using rule 60 (while_stmt -> WHILE cond_list COLON END_STATEMENT body END .)
    RETURN          reduce using rule 60 (while_stmt -> WHILE cond_list COLON END_STATEMENT body END .)
    BREAK           reduce using rule 60 (while_stmt -> WHILE cond_list COLON END_STATEMENT body END .)
    CONTINUE        reduce using rule 60 (while_stmt -> WHILE cond_list COLON END_STATEMENT body END .)
    FUNCTION        reduce using rule 60 (while_stmt -> WHILE cond_list COLON END_STATEMENT body END .)
    TRUE            reduce using rule 60 (while_stmt -> WHILE cond_list COLON END_STATEMENT body END .)
    FALSE           reduce using rule 60 (while_stmt -> WHILE cond_list COLON END_STATEMENT body END .)
    END             reduce using rule 60 (while_stmt -> WHILE cond_list COLON END_STATEMENT body END .)
    $end            reduce using rule 60 (while_stmt -> WHILE cond_list COLON END_STATEMENT body END .)


state 114

    (66) for_stmt -> FOR IDENTIFIER IN RANGE LPAREN INTEGER . COMMA INTEGER RPAREN COLON END_STATEMENT body END

    COMMA           shift and go to state 119


state 115

    (67) for_stmt -> FOR IDENTIFIER IN IDENTIFIER COLON END_STATEMENT . body END
    (58) body -> . stmt
    (59) body -> . stmt body
    (3) stmt -> . simple_stmt
    (4) stmt -> . compound_stmt
    (5) simple_stmt -> . small_stmt END_STATEMENT
    (49) compound_stmt -> . func_def
    (50) compound_stmt -> . if_stmt
    (51) compound_stmt -> . while_stmt
    (52) compound_stmt -> . for_stmt
    (6) small_stmt -> . assignment
    (7) small_stmt -> . const_decl
    (8) small_stmt -> . expr
    (9) small_stmt -> . return_stmt
    (10) small_stmt -> . loop_stmt
    (53) func_def -> . head END_STATEMENT body END
    (68) if_stmt -> . IF cond_list COLON END_STATEMENT body END
    (69) if_stmt -> . IF cond_list COLON END_STATEMENT body END elseif_list
    (70) if_stmt -> . IF cond_list COLON END_STATEMENT body END elseif_list ELSE COLON END_STATEMENT body END
    (71) if_stmt -> . IF cond_list COLON END_STATEMENT body END ELSE COLON END_STATEMENT body END
    (60) while_stmt -> . WHILE cond_list COLON END_STATEMENT body END
    (66) for_stmt -> . FOR IDENTIFIER IN RANGE LPAREN INTEGER COMMA INTEGER RPAREN COLON END_STATEMENT body END
    (67) for_stmt -> . FOR IDENTIFIER IN IDENTIFIER COLON END_STATEMENT body END
    (16) assignment -> . IDENTIFIER ASSIGN expr
    (17) assignment -> . IDENTIFIER ASSIGN boolean
    (18) assignment -> . ARRAY_CELL ASSIGN expr
    (19) assignment -> . ARRAY_CELL ASSIGN boolean
    (20) const_decl -> . IDENTIFIER CONST expr
    (26) expr -> . IDENTIFIER
    (27) expr -> . ARRAY_CELL
    (28) expr -> . func_call
    (29) expr -> . arithmetic
    (30) expr -> . cond_list
    (31) expr -> . LPAREN expr RPAREN
    (32) expr -> . INTEGER
    (33) expr -> . DOUBLE
    (11) return_stmt -> . RETURN
    (12) return_stmt -> . RETURN expr
    (13) return_stmt -> . RETURN boolean
    (14) loop_stmt -> . BREAK
    (15) loop_stmt -> . CONTINUE
    (54) head -> . FUNCTION IDENTIFIER LPAREN p_func_def_args RPAREN COLON
    (55) head -> . FUNCTION IDENTIFIER LPAREN RPAREN COLON
    (21) func_call -> . IDENTIFIER LPAREN call_args RPAREN
    (22) func_call -> . IDENTIFIER LPAREN RPAREN
    (36) arithmetic -> . expr ADD_OP expr
    (37) arithmetic -> . expr SUB_OP expr
    (38) arithmetic -> . expr MUL_OP expr
    (39) arithmetic -> . expr DIV_OP expr
    (40) arithmetic -> . expr MOD_OP expr
    (61) cond_list -> . condition
    (62) cond_list -> . condition comb_op cond_list
    (63) cond_list -> . LPAREN cond_list RPAREN
    (64) condition -> . expr comp_op expr
    (65) condition -> . boolean
    (34) boolean -> . TRUE
    (35) boolean -> . FALSE

    IF              shift and go to state 25
    WHILE           shift and go to state 3
    FOR             shift and go to state 8
    IDENTIFIER      shift and go to state 12
    ARRAY_CELL      shift and go to state 2
    LPAREN          shift and go to state 22
    INTEGER         shift and go to state 11
    DOUBLE          shift and go to state 33
    RETURN          shift and go to state 6
    BREAK           shift and go to state 30
    CONTINUE        shift and go to state 32
    FUNCTION        shift and go to state 23
    TRUE            shift and go to state 7
    FALSE           shift and go to state 27

    small_stmt                     shift and go to state 1
    boolean                        shift and go to state 4
    return_stmt                    shift and go to state 5
    const_decl                     shift and go to state 9
    compound_stmt                  shift and go to state 13
    arithmetic                     shift and go to state 14
    body                           shift and go to state 120
    head                           shift and go to state 15
    func_def                       shift and go to state 16
    simple_stmt                    shift and go to state 17
    assignment                     shift and go to state 18
    stmt                           shift and go to state 82
    for_stmt                       shift and go to state 20
    loop_stmt                      shift and go to state 21
    condition                      shift and go to state 24
    func_call                      shift and go to state 26
    if_stmt                        shift and go to state 28
    expr                           shift and go to state 29
    while_stmt                     shift and go to state 31
    cond_list                      shift and go to state 34

state 116

    (54) head -> FUNCTION IDENTIFIER LPAREN p_func_def_args RPAREN COLON .

    END_STATEMENT   reduce using rule 54 (head -> FUNCTION IDENTIFIER LPAREN p_func_def_args RPAREN COLON .)


state 117

    (57) p_func_def_args -> IDENTIFIER COMMA p_func_def_args .

    RPAREN          reduce using rule 57 (p_func_def_args -> IDENTIFIER COMMA p_func_def_args .)


state 118

    (68) if_stmt -> IF cond_list COLON END_STATEMENT body END .
    (69) if_stmt -> IF cond_list COLON END_STATEMENT body END . elseif_list
    (70) if_stmt -> IF cond_list COLON END_STATEMENT body END . elseif_list ELSE COLON END_STATEMENT body END
    (71) if_stmt -> IF cond_list COLON END_STATEMENT body END . ELSE COLON END_STATEMENT body END
    (72) elseif_list -> . ELSEIF cond_list COLON END_STATEMENT body END
    (73) elseif_list -> . ELSEIF cond_list COLON END_STATEMENT body END elseif_list

    IF              reduce using rule 68 (if_stmt -> IF cond_list COLON END_STATEMENT body END .)
    WHILE           reduce using rule 68 (if_stmt -> IF cond_list COLON END_STATEMENT body END .)
    FOR             reduce using rule 68 (if_stmt -> IF cond_list COLON END_STATEMENT body END .)
    IDENTIFIER      reduce using rule 68 (if_stmt -> IF cond_list COLON END_STATEMENT body END .)
    ARRAY_CELL      reduce using rule 68 (if_stmt -> IF cond_list COLON END_STATEMENT body END .)
    LPAREN          reduce using rule 68 (if_stmt -> IF cond_list COLON END_STATEMENT body END .)
    INTEGER         reduce using rule 68 (if_stmt -> IF cond_list COLON END_STATEMENT body END .)
    DOUBLE          reduce using rule 68 (if_stmt -> IF cond_list COLON END_STATEMENT body END .)
    RETURN          reduce using rule 68 (if_stmt -> IF cond_list COLON END_STATEMENT body END .)
    BREAK           reduce using rule 68 (if_stmt -> IF cond_list COLON END_STATEMENT body END .)
    CONTINUE        reduce using rule 68 (if_stmt -> IF cond_list COLON END_STATEMENT body END .)
    FUNCTION        reduce using rule 68 (if_stmt -> IF cond_list COLON END_STATEMENT body END .)
    TRUE            reduce using rule 68 (if_stmt -> IF cond_list COLON END_STATEMENT body END .)
    FALSE           reduce using rule 68 (if_stmt -> IF cond_list COLON END_STATEMENT body END .)
    END             reduce using rule 68 (if_stmt -> IF cond_list COLON END_STATEMENT body END .)
    $end            reduce using rule 68 (if_stmt -> IF cond_list COLON END_STATEMENT body END .)
    ELSE            shift and go to state 122
    ELSEIF          shift and go to state 123

    elseif_list                    shift and go to state 121

state 119

    (66) for_stmt -> FOR IDENTIFIER IN RANGE LPAREN INTEGER COMMA . INTEGER RPAREN COLON END_STATEMENT body END

    INTEGER         shift and go to state 124


state 120

    (67) for_stmt -> FOR IDENTIFIER IN IDENTIFIER COLON END_STATEMENT body . END

    END             shift and go to state 125


state 121

    (69) if_stmt -> IF cond_list COLON END_STATEMENT body END elseif_list .
    (70) if_stmt -> IF cond_list COLON END_STATEMENT body END elseif_list . ELSE COLON END_STATEMENT body END

    IF              reduce using rule 69 (if_stmt -> IF cond_list COLON END_STATEMENT body END elseif_list .)
    WHILE           reduce using rule 69 (if_stmt -> IF cond_list COLON END_STATEMENT body END elseif_list .)
    FOR             reduce using rule 69 (if_stmt -> IF cond_list COLON END_STATEMENT body END elseif_list .)
    IDENTIFIER      reduce using rule 69 (if_stmt -> IF cond_list COLON END_STATEMENT body END elseif_list .)
    ARRAY_CELL      reduce using rule 69 (if_stmt -> IF cond_list COLON END_STATEMENT body END elseif_list .)
    LPAREN          reduce using rule 69 (if_stmt -> IF cond_list COLON END_STATEMENT body END elseif_list .)
    INTEGER         reduce using rule 69 (if_stmt -> IF cond_list COLON END_STATEMENT body END elseif_list .)
    DOUBLE          reduce using rule 69 (if_stmt -> IF cond_list COLON END_STATEMENT body END elseif_list .)
    RETURN          reduce using rule 69 (if_stmt -> IF cond_list COLON END_STATEMENT body END elseif_list .)
    BREAK           reduce using rule 69 (if_stmt -> IF cond_list COLON END_STATEMENT body END elseif_list .)
    CONTINUE        reduce using rule 69 (if_stmt -> IF cond_list COLON END_STATEMENT body END elseif_list .)
    FUNCTION        reduce using rule 69 (if_stmt -> IF cond_list COLON END_STATEMENT body END elseif_list .)
    TRUE            reduce using rule 69 (if_stmt -> IF cond_list COLON END_STATEMENT body END elseif_list .)
    FALSE           reduce using rule 69 (if_stmt -> IF cond_list COLON END_STATEMENT body END elseif_list .)
    END             reduce using rule 69 (if_stmt -> IF cond_list COLON END_STATEMENT body END elseif_list .)
    $end            reduce using rule 69 (if_stmt -> IF cond_list COLON END_STATEMENT body END elseif_list .)
    ELSE            shift and go to state 126


state 122

    (71) if_stmt -> IF cond_list COLON END_STATEMENT body END ELSE . COLON END_STATEMENT body END

    COLON           shift and go to state 127


state 123

    (72) elseif_list -> ELSEIF . cond_list COLON END_STATEMENT body END
    (73) elseif_list -> ELSEIF . cond_list COLON END_STATEMENT body END elseif_list
    (61) cond_list -> . condition
    (62) cond_list -> . condition comb_op cond_list
    (63) cond_list -> . LPAREN cond_list RPAREN
    (64) condition -> . expr comp_op expr
    (65) condition -> . boolean
    (26) expr -> . IDENTIFIER
    (27) expr -> . ARRAY_CELL
    (28) expr -> . func_call
    (29) expr -> . arithmetic
    (30) expr -> . cond_list
    (31) expr -> . LPAREN expr RPAREN
    (32) expr -> . INTEGER
    (33) expr -> . DOUBLE
    (34) boolean -> . TRUE
    (35) boolean -> . FALSE
    (21) func_call -> . IDENTIFIER LPAREN call_args RPAREN
    (22) func_call -> . IDENTIFIER LPAREN RPAREN
    (36) arithmetic -> . expr ADD_OP expr
    (37) arithmetic -> . expr SUB_OP expr
    (38) arithmetic -> . expr MUL_OP expr
    (39) arithmetic -> . expr DIV_OP expr
    (40) arithmetic -> . expr MOD_OP expr

    LPAREN          shift and go to state 39
    IDENTIFIER      shift and go to state 38
    ARRAY_CELL      shift and go to state 37
    INTEGER         shift and go to state 11
    DOUBLE          shift and go to state 33
    TRUE            shift and go to state 7
    FALSE           shift and go to state 27

    func_call                      shift and go to state 26
    expr                           shift and go to state 40
    boolean                        shift and go to state 4
    arithmetic                     shift and go to state 14
    cond_list                      shift and go to state 128
    condition                      shift and go to state 24

state 124

    (66) for_stmt -> FOR IDENTIFIER IN RANGE LPAREN INTEGER COMMA INTEGER . RPAREN COLON END_STATEMENT body END

    RPAREN          shift and go to state 129


state 125

    (67) for_stmt -> FOR IDENTIFIER IN IDENTIFIER COLON END_STATEMENT body END .

    IF              reduce using rule 67 (for_stmt -> FOR IDENTIFIER IN IDENTIFIER COLON END_STATEMENT body END .)
    WHILE           reduce using rule 67 (for_stmt -> FOR IDENTIFIER IN IDENTIFIER COLON END_STATEMENT body END .)
    FOR             reduce using rule 67 (for_stmt -> FOR IDENTIFIER IN IDENTIFIER COLON END_STATEMENT body END .)
    IDENTIFIER      reduce using rule 67 (for_stmt -> FOR IDENTIFIER IN IDENTIFIER COLON END_STATEMENT body END .)
    ARRAY_CELL      reduce using rule 67 (for_stmt -> FOR IDENTIFIER IN IDENTIFIER COLON END_STATEMENT body END .)
    LPAREN          reduce using rule 67 (for_stmt -> FOR IDENTIFIER IN IDENTIFIER COLON END_STATEMENT body END .)
    INTEGER         reduce using rule 67 (for_stmt -> FOR IDENTIFIER IN IDENTIFIER COLON END_STATEMENT body END .)
    DOUBLE          reduce using rule 67 (for_stmt -> FOR IDENTIFIER IN IDENTIFIER COLON END_STATEMENT body END .)
    RETURN          reduce using rule 67 (for_stmt -> FOR IDENTIFIER IN IDENTIFIER COLON END_STATEMENT body END .)
    BREAK           reduce using rule 67 (for_stmt -> FOR IDENTIFIER IN IDENTIFIER COLON END_STATEMENT body END .)
    CONTINUE        reduce using rule 67 (for_stmt -> FOR IDENTIFIER IN IDENTIFIER COLON END_STATEMENT body END .)
    FUNCTION        reduce using rule 67 (for_stmt -> FOR IDENTIFIER IN IDENTIFIER COLON END_STATEMENT body END .)
    TRUE            reduce using rule 67 (for_stmt -> FOR IDENTIFIER IN IDENTIFIER COLON END_STATEMENT body END .)
    FALSE           reduce using rule 67 (for_stmt -> FOR IDENTIFIER IN IDENTIFIER COLON END_STATEMENT body END .)
    END             reduce using rule 67 (for_stmt -> FOR IDENTIFIER IN IDENTIFIER COLON END_STATEMENT body END .)
    $end            reduce using rule 67 (for_stmt -> FOR IDENTIFIER IN IDENTIFIER COLON END_STATEMENT body END .)


state 126

    (70) if_stmt -> IF cond_list COLON END_STATEMENT body END elseif_list ELSE . COLON END_STATEMENT body END

    COLON           shift and go to state 130


state 127

    (71) if_stmt -> IF cond_list COLON END_STATEMENT body END ELSE COLON . END_STATEMENT body END

    END_STATEMENT   shift and go to state 131


state 128

    (72) elseif_list -> ELSEIF cond_list . COLON END_STATEMENT body END
    (73) elseif_list -> ELSEIF cond_list . COLON END_STATEMENT body END elseif_list
    (30) expr -> cond_list .

    COLON           shift and go to state 132
    ADD_OP          reduce using rule 30 (expr -> cond_list .)
    SUB_OP          reduce using rule 30 (expr -> cond_list .)
    MUL_OP          reduce using rule 30 (expr -> cond_list .)
    DIV_OP          reduce using rule 30 (expr -> cond_list .)
    MOD_OP          reduce using rule 30 (expr -> cond_list .)
    CEQ             reduce using rule 30 (expr -> cond_list .)
    CNE             reduce using rule 30 (expr -> cond_list .)
    CLT             reduce using rule 30 (expr -> cond_list .)
    CLE             reduce using rule 30 (expr -> cond_list .)
    CGT             reduce using rule 30 (expr -> cond_list .)
    CGE             reduce using rule 30 (expr -> cond_list .)


state 129

    (66) for_stmt -> FOR IDENTIFIER IN RANGE LPAREN INTEGER COMMA INTEGER RPAREN . COLON END_STATEMENT body END

    COLON           shift and go to state 133


state 130

    (70) if_stmt -> IF cond_list COLON END_STATEMENT body END elseif_list ELSE COLON . END_STATEMENT body END

    END_STATEMENT   shift and go to state 134


state 131

    (71) if_stmt -> IF cond_list COLON END_STATEMENT body END ELSE COLON END_STATEMENT . body END
    (58) body -> . stmt
    (59) body -> . stmt body
    (3) stmt -> . simple_stmt
    (4) stmt -> . compound_stmt
    (5) simple_stmt -> . small_stmt END_STATEMENT
    (49) compound_stmt -> . func_def
    (50) compound_stmt -> . if_stmt
    (51) compound_stmt -> . while_stmt
    (52) compound_stmt -> . for_stmt
    (6) small_stmt -> . assignment
    (7) small_stmt -> . const_decl
    (8) small_stmt -> . expr
    (9) small_stmt -> . return_stmt
    (10) small_stmt -> . loop_stmt
    (53) func_def -> . head END_STATEMENT body END
    (68) if_stmt -> . IF cond_list COLON END_STATEMENT body END
    (69) if_stmt -> . IF cond_list COLON END_STATEMENT body END elseif_list
    (70) if_stmt -> . IF cond_list COLON END_STATEMENT body END elseif_list ELSE COLON END_STATEMENT body END
    (71) if_stmt -> . IF cond_list COLON END_STATEMENT body END ELSE COLON END_STATEMENT body END
    (60) while_stmt -> . WHILE cond_list COLON END_STATEMENT body END
    (66) for_stmt -> . FOR IDENTIFIER IN RANGE LPAREN INTEGER COMMA INTEGER RPAREN COLON END_STATEMENT body END
    (67) for_stmt -> . FOR IDENTIFIER IN IDENTIFIER COLON END_STATEMENT body END
    (16) assignment -> . IDENTIFIER ASSIGN expr
    (17) assignment -> . IDENTIFIER ASSIGN boolean
    (18) assignment -> . ARRAY_CELL ASSIGN expr
    (19) assignment -> . ARRAY_CELL ASSIGN boolean
    (20) const_decl -> . IDENTIFIER CONST expr
    (26) expr -> . IDENTIFIER
    (27) expr -> . ARRAY_CELL
    (28) expr -> . func_call
    (29) expr -> . arithmetic
    (30) expr -> . cond_list
    (31) expr -> . LPAREN expr RPAREN
    (32) expr -> . INTEGER
    (33) expr -> . DOUBLE
    (11) return_stmt -> . RETURN
    (12) return_stmt -> . RETURN expr
    (13) return_stmt -> . RETURN boolean
    (14) loop_stmt -> . BREAK
    (15) loop_stmt -> . CONTINUE
    (54) head -> . FUNCTION IDENTIFIER LPAREN p_func_def_args RPAREN COLON
    (55) head -> . FUNCTION IDENTIFIER LPAREN RPAREN COLON
    (21) func_call -> . IDENTIFIER LPAREN call_args RPAREN
    (22) func_call -> . IDENTIFIER LPAREN RPAREN
    (36) arithmetic -> . expr ADD_OP expr
    (37) arithmetic -> . expr SUB_OP expr
    (38) arithmetic -> . expr MUL_OP expr
    (39) arithmetic -> . expr DIV_OP expr
    (40) arithmetic -> . expr MOD_OP expr
    (61) cond_list -> . condition
    (62) cond_list -> . condition comb_op cond_list
    (63) cond_list -> . LPAREN cond_list RPAREN
    (64) condition -> . expr comp_op expr
    (65) condition -> . boolean
    (34) boolean -> . TRUE
    (35) boolean -> . FALSE

    IF              shift and go to state 25
    WHILE           shift and go to state 3
    FOR             shift and go to state 8
    IDENTIFIER      shift and go to state 12
    ARRAY_CELL      shift and go to state 2
    LPAREN          shift and go to state 22
    INTEGER         shift and go to state 11
    DOUBLE          shift and go to state 33
    RETURN          shift and go to state 6
    BREAK           shift and go to state 30
    CONTINUE        shift and go to state 32
    FUNCTION        shift and go to state 23
    TRUE            shift and go to state 7
    FALSE           shift and go to state 27

    small_stmt                     shift and go to state 1
    boolean                        shift and go to state 4
    return_stmt                    shift and go to state 5
    const_decl                     shift and go to state 9
    compound_stmt                  shift and go to state 13
    arithmetic                     shift and go to state 14
    body                           shift and go to state 135
    head                           shift and go to state 15
    func_def                       shift and go to state 16
    simple_stmt                    shift and go to state 17
    assignment                     shift and go to state 18
    stmt                           shift and go to state 82
    for_stmt                       shift and go to state 20
    loop_stmt                      shift and go to state 21
    condition                      shift and go to state 24
    func_call                      shift and go to state 26
    if_stmt                        shift and go to state 28
    expr                           shift and go to state 29
    while_stmt                     shift and go to state 31
    cond_list                      shift and go to state 34

state 132

    (72) elseif_list -> ELSEIF cond_list COLON . END_STATEMENT body END
    (73) elseif_list -> ELSEIF cond_list COLON . END_STATEMENT body END elseif_list

    END_STATEMENT   shift and go to state 136


state 133

    (66) for_stmt -> FOR IDENTIFIER IN RANGE LPAREN INTEGER COMMA INTEGER RPAREN COLON . END_STATEMENT body END

    END_STATEMENT   shift and go to state 137


state 134

    (70) if_stmt -> IF cond_list COLON END_STATEMENT body END elseif_list ELSE COLON END_STATEMENT . body END
    (58) body -> . stmt
    (59) body -> . stmt body
    (3) stmt -> . simple_stmt
    (4) stmt -> . compound_stmt
    (5) simple_stmt -> . small_stmt END_STATEMENT
    (49) compound_stmt -> . func_def
    (50) compound_stmt -> . if_stmt
    (51) compound_stmt -> . while_stmt
    (52) compound_stmt -> . for_stmt
    (6) small_stmt -> . assignment
    (7) small_stmt -> . const_decl
    (8) small_stmt -> . expr
    (9) small_stmt -> . return_stmt
    (10) small_stmt -> . loop_stmt
    (53) func_def -> . head END_STATEMENT body END
    (68) if_stmt -> . IF cond_list COLON END_STATEMENT body END
    (69) if_stmt -> . IF cond_list COLON END_STATEMENT body END elseif_list
    (70) if_stmt -> . IF cond_list COLON END_STATEMENT body END elseif_list ELSE COLON END_STATEMENT body END
    (71) if_stmt -> . IF cond_list COLON END_STATEMENT body END ELSE COLON END_STATEMENT body END
    (60) while_stmt -> . WHILE cond_list COLON END_STATEMENT body END
    (66) for_stmt -> . FOR IDENTIFIER IN RANGE LPAREN INTEGER COMMA INTEGER RPAREN COLON END_STATEMENT body END
    (67) for_stmt -> . FOR IDENTIFIER IN IDENTIFIER COLON END_STATEMENT body END
    (16) assignment -> . IDENTIFIER ASSIGN expr
    (17) assignment -> . IDENTIFIER ASSIGN boolean
    (18) assignment -> . ARRAY_CELL ASSIGN expr
    (19) assignment -> . ARRAY_CELL ASSIGN boolean
    (20) const_decl -> . IDENTIFIER CONST expr
    (26) expr -> . IDENTIFIER
    (27) expr -> . ARRAY_CELL
    (28) expr -> . func_call
    (29) expr -> . arithmetic
    (30) expr -> . cond_list
    (31) expr -> . LPAREN expr RPAREN
    (32) expr -> . INTEGER
    (33) expr -> . DOUBLE
    (11) return_stmt -> . RETURN
    (12) return_stmt -> . RETURN expr
    (13) return_stmt -> . RETURN boolean
    (14) loop_stmt -> . BREAK
    (15) loop_stmt -> . CONTINUE
    (54) head -> . FUNCTION IDENTIFIER LPAREN p_func_def_args RPAREN COLON
    (55) head -> . FUNCTION IDENTIFIER LPAREN RPAREN COLON
    (21) func_call -> . IDENTIFIER LPAREN call_args RPAREN
    (22) func_call -> . IDENTIFIER LPAREN RPAREN
    (36) arithmetic -> . expr ADD_OP expr
    (37) arithmetic -> . expr SUB_OP expr
    (38) arithmetic -> . expr MUL_OP expr
    (39) arithmetic -> . expr DIV_OP expr
    (40) arithmetic -> . expr MOD_OP expr
    (61) cond_list -> . condition
    (62) cond_list -> . condition comb_op cond_list
    (63) cond_list -> . LPAREN cond_list RPAREN
    (64) condition -> . expr comp_op expr
    (65) condition -> . boolean
    (34) boolean -> . TRUE
    (35) boolean -> . FALSE

    IF              shift and go to state 25
    WHILE           shift and go to state 3
    FOR             shift and go to state 8
    IDENTIFIER      shift and go to state 12
    ARRAY_CELL      shift and go to state 2
    LPAREN          shift and go to state 22
    INTEGER         shift and go to state 11
    DOUBLE          shift and go to state 33
    RETURN          shift and go to state 6
    BREAK           shift and go to state 30
    CONTINUE        shift and go to state 32
    FUNCTION        shift and go to state 23
    TRUE            shift and go to state 7
    FALSE           shift and go to state 27

    small_stmt                     shift and go to state 1
    boolean                        shift and go to state 4
    return_stmt                    shift and go to state 5
    const_decl                     shift and go to state 9
    compound_stmt                  shift and go to state 13
    arithmetic                     shift and go to state 14
    body                           shift and go to state 138
    head                           shift and go to state 15
    func_def                       shift and go to state 16
    simple_stmt                    shift and go to state 17
    assignment                     shift and go to state 18
    stmt                           shift and go to state 82
    for_stmt                       shift and go to state 20
    loop_stmt                      shift and go to state 21
    condition                      shift and go to state 24
    func_call                      shift and go to state 26
    if_stmt                        shift and go to state 28
    expr                           shift and go to state 29
    while_stmt                     shift and go to state 31
    cond_list                      shift and go to state 34

state 135

    (71) if_stmt -> IF cond_list COLON END_STATEMENT body END ELSE COLON END_STATEMENT body . END

    END             shift and go to state 139


state 136

    (72) elseif_list -> ELSEIF cond_list COLON END_STATEMENT . body END
    (73) elseif_list -> ELSEIF cond_list COLON END_STATEMENT . body END elseif_list
    (58) body -> . stmt
    (59) body -> . stmt body
    (3) stmt -> . simple_stmt
    (4) stmt -> . compound_stmt
    (5) simple_stmt -> . small_stmt END_STATEMENT
    (49) compound_stmt -> . func_def
    (50) compound_stmt -> . if_stmt
    (51) compound_stmt -> . while_stmt
    (52) compound_stmt -> . for_stmt
    (6) small_stmt -> . assignment
    (7) small_stmt -> . const_decl
    (8) small_stmt -> . expr
    (9) small_stmt -> . return_stmt
    (10) small_stmt -> . loop_stmt
    (53) func_def -> . head END_STATEMENT body END
    (68) if_stmt -> . IF cond_list COLON END_STATEMENT body END
    (69) if_stmt -> . IF cond_list COLON END_STATEMENT body END elseif_list
    (70) if_stmt -> . IF cond_list COLON END_STATEMENT body END elseif_list ELSE COLON END_STATEMENT body END
    (71) if_stmt -> . IF cond_list COLON END_STATEMENT body END ELSE COLON END_STATEMENT body END
    (60) while_stmt -> . WHILE cond_list COLON END_STATEMENT body END
    (66) for_stmt -> . FOR IDENTIFIER IN RANGE LPAREN INTEGER COMMA INTEGER RPAREN COLON END_STATEMENT body END
    (67) for_stmt -> . FOR IDENTIFIER IN IDENTIFIER COLON END_STATEMENT body END
    (16) assignment -> . IDENTIFIER ASSIGN expr
    (17) assignment -> . IDENTIFIER ASSIGN boolean
    (18) assignment -> . ARRAY_CELL ASSIGN expr
    (19) assignment -> . ARRAY_CELL ASSIGN boolean
    (20) const_decl -> . IDENTIFIER CONST expr
    (26) expr -> . IDENTIFIER
    (27) expr -> . ARRAY_CELL
    (28) expr -> . func_call
    (29) expr -> . arithmetic
    (30) expr -> . cond_list
    (31) expr -> . LPAREN expr RPAREN
    (32) expr -> . INTEGER
    (33) expr -> . DOUBLE
    (11) return_stmt -> . RETURN
    (12) return_stmt -> . RETURN expr
    (13) return_stmt -> . RETURN boolean
    (14) loop_stmt -> . BREAK
    (15) loop_stmt -> . CONTINUE
    (54) head -> . FUNCTION IDENTIFIER LPAREN p_func_def_args RPAREN COLON
    (55) head -> . FUNCTION IDENTIFIER LPAREN RPAREN COLON
    (21) func_call -> . IDENTIFIER LPAREN call_args RPAREN
    (22) func_call -> . IDENTIFIER LPAREN RPAREN
    (36) arithmetic -> . expr ADD_OP expr
    (37) arithmetic -> . expr SUB_OP expr
    (38) arithmetic -> . expr MUL_OP expr
    (39) arithmetic -> . expr DIV_OP expr
    (40) arithmetic -> . expr MOD_OP expr
    (61) cond_list -> . condition
    (62) cond_list -> . condition comb_op cond_list
    (63) cond_list -> . LPAREN cond_list RPAREN
    (64) condition -> . expr comp_op expr
    (65) condition -> . boolean
    (34) boolean -> . TRUE
    (35) boolean -> . FALSE

    IF              shift and go to state 25
    WHILE           shift and go to state 3
    FOR             shift and go to state 8
    IDENTIFIER      shift and go to state 12
    ARRAY_CELL      shift and go to state 2
    LPAREN          shift and go to state 22
    INTEGER         shift and go to state 11
    DOUBLE          shift and go to state 33
    RETURN          shift and go to state 6
    BREAK           shift and go to state 30
    CONTINUE        shift and go to state 32
    FUNCTION        shift and go to state 23
    TRUE            shift and go to state 7
    FALSE           shift and go to state 27

    small_stmt                     shift and go to state 1
    boolean                        shift and go to state 4
    return_stmt                    shift and go to state 5
    const_decl                     shift and go to state 9
    compound_stmt                  shift and go to state 13
    arithmetic                     shift and go to state 14
    body                           shift and go to state 140
    head                           shift and go to state 15
    func_def                       shift and go to state 16
    simple_stmt                    shift and go to state 17
    assignment                     shift and go to state 18
    stmt                           shift and go to state 82
    for_stmt                       shift and go to state 20
    loop_stmt                      shift and go to state 21
    condition                      shift and go to state 24
    func_call                      shift and go to state 26
    if_stmt                        shift and go to state 28
    expr                           shift and go to state 29
    while_stmt                     shift and go to state 31
    cond_list                      shift and go to state 34

state 137

    (66) for_stmt -> FOR IDENTIFIER IN RANGE LPAREN INTEGER COMMA INTEGER RPAREN COLON END_STATEMENT . body END
    (58) body -> . stmt
    (59) body -> . stmt body
    (3) stmt -> . simple_stmt
    (4) stmt -> . compound_stmt
    (5) simple_stmt -> . small_stmt END_STATEMENT
    (49) compound_stmt -> . func_def
    (50) compound_stmt -> . if_stmt
    (51) compound_stmt -> . while_stmt
    (52) compound_stmt -> . for_stmt
    (6) small_stmt -> . assignment
    (7) small_stmt -> . const_decl
    (8) small_stmt -> . expr
    (9) small_stmt -> . return_stmt
    (10) small_stmt -> . loop_stmt
    (53) func_def -> . head END_STATEMENT body END
    (68) if_stmt -> . IF cond_list COLON END_STATEMENT body END
    (69) if_stmt -> . IF cond_list COLON END_STATEMENT body END elseif_list
    (70) if_stmt -> . IF cond_list COLON END_STATEMENT body END elseif_list ELSE COLON END_STATEMENT body END
    (71) if_stmt -> . IF cond_list COLON END_STATEMENT body END ELSE COLON END_STATEMENT body END
    (60) while_stmt -> . WHILE cond_list COLON END_STATEMENT body END
    (66) for_stmt -> . FOR IDENTIFIER IN RANGE LPAREN INTEGER COMMA INTEGER RPAREN COLON END_STATEMENT body END
    (67) for_stmt -> . FOR IDENTIFIER IN IDENTIFIER COLON END_STATEMENT body END
    (16) assignment -> . IDENTIFIER ASSIGN expr
    (17) assignment -> . IDENTIFIER ASSIGN boolean
    (18) assignment -> . ARRAY_CELL ASSIGN expr
    (19) assignment -> . ARRAY_CELL ASSIGN boolean
    (20) const_decl -> . IDENTIFIER CONST expr
    (26) expr -> . IDENTIFIER
    (27) expr -> . ARRAY_CELL
    (28) expr -> . func_call
    (29) expr -> . arithmetic
    (30) expr -> . cond_list
    (31) expr -> . LPAREN expr RPAREN
    (32) expr -> . INTEGER
    (33) expr -> . DOUBLE
    (11) return_stmt -> . RETURN
    (12) return_stmt -> . RETURN expr
    (13) return_stmt -> . RETURN boolean
    (14) loop_stmt -> . BREAK
    (15) loop_stmt -> . CONTINUE
    (54) head -> . FUNCTION IDENTIFIER LPAREN p_func_def_args RPAREN COLON
    (55) head -> . FUNCTION IDENTIFIER LPAREN RPAREN COLON
    (21) func_call -> . IDENTIFIER LPAREN call_args RPAREN
    (22) func_call -> . IDENTIFIER LPAREN RPAREN
    (36) arithmetic -> . expr ADD_OP expr
    (37) arithmetic -> . expr SUB_OP expr
    (38) arithmetic -> . expr MUL_OP expr
    (39) arithmetic -> . expr DIV_OP expr
    (40) arithmetic -> . expr MOD_OP expr
    (61) cond_list -> . condition
    (62) cond_list -> . condition comb_op cond_list
    (63) cond_list -> . LPAREN cond_list RPAREN
    (64) condition -> . expr comp_op expr
    (65) condition -> . boolean
    (34) boolean -> . TRUE
    (35) boolean -> . FALSE

    IF              shift and go to state 25
    WHILE           shift and go to state 3
    FOR             shift and go to state 8
    IDENTIFIER      shift and go to state 12
    ARRAY_CELL      shift and go to state 2
    LPAREN          shift and go to state 22
    INTEGER         shift and go to state 11
    DOUBLE          shift and go to state 33
    RETURN          shift and go to state 6
    BREAK           shift and go to state 30
    CONTINUE        shift and go to state 32
    FUNCTION        shift and go to state 23
    TRUE            shift and go to state 7
    FALSE           shift and go to state 27

    small_stmt                     shift and go to state 1
    boolean                        shift and go to state 4
    return_stmt                    shift and go to state 5
    const_decl                     shift and go to state 9
    compound_stmt                  shift and go to state 13
    arithmetic                     shift and go to state 14
    body                           shift and go to state 141
    head                           shift and go to state 15
    func_def                       shift and go to state 16
    simple_stmt                    shift and go to state 17
    assignment                     shift and go to state 18
    stmt                           shift and go to state 82
    for_stmt                       shift and go to state 20
    loop_stmt                      shift and go to state 21
    condition                      shift and go to state 24
    func_call                      shift and go to state 26
    if_stmt                        shift and go to state 28
    expr                           shift and go to state 29
    while_stmt                     shift and go to state 31
    cond_list                      shift and go to state 34

state 138

    (70) if_stmt -> IF cond_list COLON END_STATEMENT body END elseif_list ELSE COLON END_STATEMENT body . END

    END             shift and go to state 142


state 139

    (71) if_stmt -> IF cond_list COLON END_STATEMENT body END ELSE COLON END_STATEMENT body END .

    IF              reduce using rule 71 (if_stmt -> IF cond_list COLON END_STATEMENT body END ELSE COLON END_STATEMENT body END .)
    WHILE           reduce using rule 71 (if_stmt -> IF cond_list COLON END_STATEMENT body END ELSE COLON END_STATEMENT body END .)
    FOR             reduce using rule 71 (if_stmt -> IF cond_list COLON END_STATEMENT body END ELSE COLON END_STATEMENT body END .)
    IDENTIFIER      reduce using rule 71 (if_stmt -> IF cond_list COLON END_STATEMENT body END ELSE COLON END_STATEMENT body END .)
    ARRAY_CELL      reduce using rule 71 (if_stmt -> IF cond_list COLON END_STATEMENT body END ELSE COLON END_STATEMENT body END .)
    LPAREN          reduce using rule 71 (if_stmt -> IF cond_list COLON END_STATEMENT body END ELSE COLON END_STATEMENT body END .)
    INTEGER         reduce using rule 71 (if_stmt -> IF cond_list COLON END_STATEMENT body END ELSE COLON END_STATEMENT body END .)
    DOUBLE          reduce using rule 71 (if_stmt -> IF cond_list COLON END_STATEMENT body END ELSE COLON END_STATEMENT body END .)
    RETURN          reduce using rule 71 (if_stmt -> IF cond_list COLON END_STATEMENT body END ELSE COLON END_STATEMENT body END .)
    BREAK           reduce using rule 71 (if_stmt -> IF cond_list COLON END_STATEMENT body END ELSE COLON END_STATEMENT body END .)
    CONTINUE        reduce using rule 71 (if_stmt -> IF cond_list COLON END_STATEMENT body END ELSE COLON END_STATEMENT body END .)
    FUNCTION        reduce using rule 71 (if_stmt -> IF cond_list COLON END_STATEMENT body END ELSE COLON END_STATEMENT body END .)
    TRUE            reduce using rule 71 (if_stmt -> IF cond_list COLON END_STATEMENT body END ELSE COLON END_STATEMENT body END .)
    FALSE           reduce using rule 71 (if_stmt -> IF cond_list COLON END_STATEMENT body END ELSE COLON END_STATEMENT body END .)
    END             reduce using rule 71 (if_stmt -> IF cond_list COLON END_STATEMENT body END ELSE COLON END_STATEMENT body END .)
    $end            reduce using rule 71 (if_stmt -> IF cond_list COLON END_STATEMENT body END ELSE COLON END_STATEMENT body END .)


state 140

    (72) elseif_list -> ELSEIF cond_list COLON END_STATEMENT body . END
    (73) elseif_list -> ELSEIF cond_list COLON END_STATEMENT body . END elseif_list

    END             shift and go to state 143


state 141

    (66) for_stmt -> FOR IDENTIFIER IN RANGE LPAREN INTEGER COMMA INTEGER RPAREN COLON END_STATEMENT body . END

    END             shift and go to state 144


state 142

    (70) if_stmt -> IF cond_list COLON END_STATEMENT body END elseif_list ELSE COLON END_STATEMENT body END .

    IF              reduce using rule 70 (if_stmt -> IF cond_list COLON END_STATEMENT body END elseif_list ELSE COLON END_STATEMENT body END .)
    WHILE           reduce using rule 70 (if_stmt -> IF cond_list COLON END_STATEMENT body END elseif_list ELSE COLON END_STATEMENT body END .)
    FOR             reduce using rule 70 (if_stmt -> IF cond_list COLON END_STATEMENT body END elseif_list ELSE COLON END_STATEMENT body END .)
    IDENTIFIER      reduce using rule 70 (if_stmt -> IF cond_list COLON END_STATEMENT body END elseif_list ELSE COLON END_STATEMENT body END .)
    ARRAY_CELL      reduce using rule 70 (if_stmt -> IF cond_list COLON END_STATEMENT body END elseif_list ELSE COLON END_STATEMENT body END .)
    LPAREN          reduce using rule 70 (if_stmt -> IF cond_list COLON END_STATEMENT body END elseif_list ELSE COLON END_STATEMENT body END .)
    INTEGER         reduce using rule 70 (if_stmt -> IF cond_list COLON END_STATEMENT body END elseif_list ELSE COLON END_STATEMENT body END .)
    DOUBLE          reduce using rule 70 (if_stmt -> IF cond_list COLON END_STATEMENT body END elseif_list ELSE COLON END_STATEMENT body END .)
    RETURN          reduce using rule 70 (if_stmt -> IF cond_list COLON END_STATEMENT body END elseif_list ELSE COLON END_STATEMENT body END .)
    BREAK           reduce using rule 70 (if_stmt -> IF cond_list COLON END_STATEMENT body END elseif_list ELSE COLON END_STATEMENT body END .)
    CONTINUE        reduce using rule 70 (if_stmt -> IF cond_list COLON END_STATEMENT body END elseif_list ELSE COLON END_STATEMENT body END .)
    FUNCTION        reduce using rule 70 (if_stmt -> IF cond_list COLON END_STATEMENT body END elseif_list ELSE COLON END_STATEMENT body END .)
    TRUE            reduce using rule 70 (if_stmt -> IF cond_list COLON END_STATEMENT body END elseif_list ELSE COLON END_STATEMENT body END .)
    FALSE           reduce using rule 70 (if_stmt -> IF cond_list COLON END_STATEMENT body END elseif_list ELSE COLON END_STATEMENT body END .)
    END             reduce using rule 70 (if_stmt -> IF cond_list COLON END_STATEMENT body END elseif_list ELSE COLON END_STATEMENT body END .)
    $end            reduce using rule 70 (if_stmt -> IF cond_list COLON END_STATEMENT body END elseif_list ELSE COLON END_STATEMENT body END .)


state 143

    (72) elseif_list -> ELSEIF cond_list COLON END_STATEMENT body END .
    (73) elseif_list -> ELSEIF cond_list COLON END_STATEMENT body END . elseif_list
    (72) elseif_list -> . ELSEIF cond_list COLON END_STATEMENT body END
    (73) elseif_list -> . ELSEIF cond_list COLON END_STATEMENT body END elseif_list

    ELSE            reduce using rule 72 (elseif_list -> ELSEIF cond_list COLON END_STATEMENT body END .)
    IF              reduce using rule 72 (elseif_list -> ELSEIF cond_list COLON END_STATEMENT body END .)
    WHILE           reduce using rule 72 (elseif_list -> ELSEIF cond_list COLON END_STATEMENT body END .)
    FOR             reduce using rule 72 (elseif_list -> ELSEIF cond_list COLON END_STATEMENT body END .)
    IDENTIFIER      reduce using rule 72 (elseif_list -> ELSEIF cond_list COLON END_STATEMENT body END .)
    ARRAY_CELL      reduce using rule 72 (elseif_list -> ELSEIF cond_list COLON END_STATEMENT body END .)
    LPAREN          reduce using rule 72 (elseif_list -> ELSEIF cond_list COLON END_STATEMENT body END .)
    INTEGER         reduce using rule 72 (elseif_list -> ELSEIF cond_list COLON END_STATEMENT body END .)
    DOUBLE          reduce using rule 72 (elseif_list -> ELSEIF cond_list COLON END_STATEMENT body END .)
    RETURN          reduce using rule 72 (elseif_list -> ELSEIF cond_list COLON END_STATEMENT body END .)
    BREAK           reduce using rule 72 (elseif_list -> ELSEIF cond_list COLON END_STATEMENT body END .)
    CONTINUE        reduce using rule 72 (elseif_list -> ELSEIF cond_list COLON END_STATEMENT body END .)
    FUNCTION        reduce using rule 72 (elseif_list -> ELSEIF cond_list COLON END_STATEMENT body END .)
    TRUE            reduce using rule 72 (elseif_list -> ELSEIF cond_list COLON END_STATEMENT body END .)
    FALSE           reduce using rule 72 (elseif_list -> ELSEIF cond_list COLON END_STATEMENT body END .)
    $end            reduce using rule 72 (elseif_list -> ELSEIF cond_list COLON END_STATEMENT body END .)
    END             reduce using rule 72 (elseif_list -> ELSEIF cond_list COLON END_STATEMENT body END .)
    ELSEIF          shift and go to state 123

    elseif_list                    shift and go to state 145

state 144

    (66) for_stmt -> FOR IDENTIFIER IN RANGE LPAREN INTEGER COMMA INTEGER RPAREN COLON END_STATEMENT body END .

    IF              reduce using rule 66 (for_stmt -> FOR IDENTIFIER IN RANGE LPAREN INTEGER COMMA INTEGER RPAREN COLON END_STATEMENT body END .)
    WHILE           reduce using rule 66 (for_stmt -> FOR IDENTIFIER IN RANGE LPAREN INTEGER COMMA INTEGER RPAREN COLON END_STATEMENT body END .)
    FOR             reduce using rule 66 (for_stmt -> FOR IDENTIFIER IN RANGE LPAREN INTEGER COMMA INTEGER RPAREN COLON END_STATEMENT body END .)
    IDENTIFIER      reduce using rule 66 (for_stmt -> FOR IDENTIFIER IN RANGE LPAREN INTEGER COMMA INTEGER RPAREN COLON END_STATEMENT body END .)
    ARRAY_CELL      reduce using rule 66 (for_stmt -> FOR IDENTIFIER IN RANGE LPAREN INTEGER COMMA INTEGER RPAREN COLON END_STATEMENT body END .)
    LPAREN          reduce using rule 66 (for_stmt -> FOR IDENTIFIER IN RANGE LPAREN INTEGER COMMA INTEGER RPAREN COLON END_STATEMENT body END .)
    INTEGER         reduce using rule 66 (for_stmt -> FOR IDENTIFIER IN RANGE LPAREN INTEGER COMMA INTEGER RPAREN COLON END_STATEMENT body END .)
    DOUBLE          reduce using rule 66 (for_stmt -> FOR IDENTIFIER IN RANGE LPAREN INTEGER COMMA INTEGER RPAREN COLON END_STATEMENT body END .)
    RETURN          reduce using rule 66 (for_stmt -> FOR IDENTIFIER IN RANGE LPAREN INTEGER COMMA INTEGER RPAREN COLON END_STATEMENT body END .)
    BREAK           reduce using rule 66 (for_stmt -> FOR IDENTIFIER IN RANGE LPAREN INTEGER COMMA INTEGER RPAREN COLON END_STATEMENT body END .)
    CONTINUE        reduce using rule 66 (for_stmt -> FOR IDENTIFIER IN RANGE LPAREN INTEGER COMMA INTEGER RPAREN COLON END_STATEMENT body END .)
    FUNCTION        reduce using rule 66 (for_stmt -> FOR IDENTIFIER IN RANGE LPAREN INTEGER COMMA INTEGER RPAREN COLON END_STATEMENT body END .)
    TRUE            reduce using rule 66 (for_stmt -> FOR IDENTIFIER IN RANGE LPAREN INTEGER COMMA INTEGER RPAREN COLON END_STATEMENT body END .)
    FALSE           reduce using rule 66 (for_stmt -> FOR IDENTIFIER IN RANGE LPAREN INTEGER COMMA INTEGER RPAREN COLON END_STATEMENT body END .)
    END             reduce using rule 66 (for_stmt -> FOR IDENTIFIER IN RANGE LPAREN INTEGER COMMA INTEGER RPAREN COLON END_STATEMENT body END .)
    $end            reduce using rule 66 (for_stmt -> FOR IDENTIFIER IN RANGE LPAREN INTEGER COMMA INTEGER RPAREN COLON END_STATEMENT body END .)


state 145

    (73) elseif_list -> ELSEIF cond_list COLON END_STATEMENT body END elseif_list .

    ELSE            reduce using rule 73 (elseif_list -> ELSEIF cond_list COLON END_STATEMENT body END elseif_list .)
    IF              reduce using rule 73 (elseif_list -> ELSEIF cond_list COLON END_STATEMENT body END elseif_list .)
    WHILE           reduce using rule 73 (elseif_list -> ELSEIF cond_list COLON END_STATEMENT body END elseif_list .)
    FOR             reduce using rule 73 (elseif_list -> ELSEIF cond_list COLON END_STATEMENT body END elseif_list .)
    IDENTIFIER      reduce using rule 73 (elseif_list -> ELSEIF cond_list COLON END_STATEMENT body END elseif_list .)
    ARRAY_CELL      reduce using rule 73 (elseif_list -> ELSEIF cond_list COLON END_STATEMENT body END elseif_list .)
    LPAREN          reduce using rule 73 (elseif_list -> ELSEIF cond_list COLON END_STATEMENT body END elseif_list .)
    INTEGER         reduce using rule 73 (elseif_list -> ELSEIF cond_list COLON END_STATEMENT body END elseif_list .)
    DOUBLE          reduce using rule 73 (elseif_list -> ELSEIF cond_list COLON END_STATEMENT body END elseif_list .)
    RETURN          reduce using rule 73 (elseif_list -> ELSEIF cond_list COLON END_STATEMENT body END elseif_list .)
    BREAK           reduce using rule 73 (elseif_list -> ELSEIF cond_list COLON END_STATEMENT body END elseif_list .)
    CONTINUE        reduce using rule 73 (elseif_list -> ELSEIF cond_list COLON END_STATEMENT body END elseif_list .)
    FUNCTION        reduce using rule 73 (elseif_list -> ELSEIF cond_list COLON END_STATEMENT body END elseif_list .)
    TRUE            reduce using rule 73 (elseif_list -> ELSEIF cond_list COLON END_STATEMENT body END elseif_list .)
    FALSE           reduce using rule 73 (elseif_list -> ELSEIF cond_list COLON END_STATEMENT body END elseif_list .)
    $end            reduce using rule 73 (elseif_list -> ELSEIF cond_list COLON END_STATEMENT body END elseif_list .)
    END             reduce using rule 73 (elseif_list -> ELSEIF cond_list COLON END_STATEMENT body END elseif_list .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for OR in state 24 resolved as shift
WARNING: shift/reduce conflict for AND in state 24 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 51 resolved as shift
WARNING: shift/reduce conflict for ADD_OP in state 89 resolved as shift
WARNING: shift/reduce conflict for SUB_OP in state 89 resolved as shift
WARNING: shift/reduce conflict for MUL_OP in state 89 resolved as shift
WARNING: shift/reduce conflict for DIV_OP in state 89 resolved as shift
WARNING: shift/reduce conflict for MOD_OP in state 89 resolved as shift
WARNING: shift/reduce conflict for CEQ in state 89 resolved as shift
WARNING: shift/reduce conflict for CNE in state 89 resolved as shift
WARNING: shift/reduce conflict for CLT in state 89 resolved as shift
WARNING: shift/reduce conflict for CLE in state 89 resolved as shift
WARNING: shift/reduce conflict for CGT in state 89 resolved as shift
WARNING: shift/reduce conflict for CGE in state 89 resolved as shift
WARNING: reduce/reduce conflict in state 42 resolved using rule (return_stmt -> RETURN boolean)
WARNING: rejected rule (condition -> boolean) in state 42
WARNING: reduce/reduce conflict in state 69 resolved using rule (assignment -> ARRAY_CELL ASSIGN boolean)
WARNING: rejected rule (condition -> boolean) in state 69
WARNING: reduce/reduce conflict in state 79 resolved using rule (assignment -> IDENTIFIER ASSIGN boolean)
WARNING: rejected rule (condition -> boolean) in state 79
WARNING: reduce/reduce conflict in state 86 resolved using rule (expr -> cond_list)
WARNING: rejected rule (cond_list -> condition comb_op cond_list) in state 86
