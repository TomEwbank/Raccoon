Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Unused terminals:

    LSBRACKET
    DOT
    QUOTE
    RSBRACKET
    APOSTROPHE

Grammar

Rule 0     S' -> program
Rule 1     program -> stmt
Rule 2     program -> stmt program
Rule 3     stmt -> simple_stmt
Rule 4     stmt -> compound_stmt
Rule 5     simple_stmt -> small_stmt END_STATEMENT
Rule 6     small_stmt -> assignment
Rule 7     small_stmt -> const_decl
Rule 8     small_stmt -> expr
Rule 9     small_stmt -> return_stmt
Rule 10    small_stmt -> loop_stmt
Rule 11    return_stmt -> RETURN
Rule 12    return_stmt -> RETURN expr
Rule 13    loop_stmt -> BREAK
Rule 14    loop_stmt -> CONTINUE
Rule 15    assignment -> IDENTIFIER ASSIGN expr
Rule 16    const_decl -> IDENTIFIER CONST expr
Rule 17    func_call -> IDENTIFIER LPAREN call_args RPAREN
Rule 18    func_call -> IDENTIFIER LPAREN RPAREN
Rule 19    call_args -> expr
Rule 20    call_args -> expr COMMA call_args
Rule 21    expr -> IDENTIFIER
Rule 22    expr -> LPAREN expr RPAREN
Rule 23    expr -> func_call
Rule 24    expr -> INTEGER
Rule 25    expr -> DOUBLE
Rule 26    expr -> boolean
Rule 27    boolean -> TRUE
Rule 28    boolean -> FALSE
Rule 29    expr -> expr ADD_OP expr
Rule 30    expr -> expr SUB_OP expr
Rule 31    expr -> expr MUL_OP expr
Rule 32    expr -> expr DIV_OP expr
Rule 33    expr -> expr MOD_OP expr
Rule 34    expr -> expr comb_op expr
Rule 35    expr -> expr comp_op expr
Rule 36    comb_op -> OR
Rule 37    comb_op -> AND
Rule 38    comp_op -> CEQ
Rule 39    comp_op -> CNE
Rule 40    comp_op -> CLT
Rule 41    comp_op -> CLE
Rule 42    comp_op -> CGT
Rule 43    comp_op -> CGE
Rule 44    compound_stmt -> func_def
Rule 45    compound_stmt -> if_stmt
Rule 46    compound_stmt -> while_stmt
Rule 47    compound_stmt -> for_stmt
Rule 48    func_def -> FUNCTION head END_STATEMENT body END END_STATEMENT
Rule 49    head -> IDENTIFIER LPAREN func_def_args RPAREN COLON
Rule 50    head -> IDENTIFIER LPAREN RPAREN COLON
Rule 51    func_def_args -> IDENTIFIER
Rule 52    func_def_args -> IDENTIFIER COMMA func_def_args
Rule 53    body -> stmt
Rule 54    body -> stmt body
Rule 55    while_stmt -> WHILE expr COLON END_STATEMENT body END END_STATEMENT
Rule 56    for_stmt -> FOR IDENTIFIER IN RANGE LPAREN expr COMMA expr RPAREN COLON END_STATEMENT body END END_STATEMENT
Rule 57    for_stmt -> FOR IDENTIFIER IN IDENTIFIER COLON END_STATEMENT body END END_STATEMENT
Rule 58    if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT
Rule 59    if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT elseif_list
Rule 60    if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT elseif_list ELSE COLON END_STATEMENT body END END_STATEMENT
Rule 61    if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT ELSE COLON END_STATEMENT body END END_STATEMENT
Rule 62    elseif_list -> ELSEIF expr COLON END_STATEMENT body END END_STATEMENT
Rule 63    elseif_list -> ELSEIF expr COLON END_STATEMENT body END END_STATEMENT elseif_list

Terminals, with rules where they appear

ADD_OP               : 29
AND                  : 37
APOSTROPHE           : 
ASSIGN               : 15
BREAK                : 13
CEQ                  : 38
CGE                  : 43
CGT                  : 42
CLE                  : 41
CLT                  : 40
CNE                  : 39
COLON                : 49 50 55 56 57 58 59 60 60 61 61 62 63
COMMA                : 20 52 56
CONST                : 16
CONTINUE             : 14
DIV_OP               : 32
DOT                  : 
DOUBLE               : 25
ELSE                 : 60 61
ELSEIF               : 62 63
END                  : 48 55 56 57 58 59 60 60 61 61 62 63
END_STATEMENT        : 5 48 48 55 55 56 56 57 57 58 58 59 59 60 60 60 60 61 61 61 61 62 62 63 63
FALSE                : 28
FOR                  : 56 57
FUNCTION             : 48
IDENTIFIER           : 15 16 17 18 21 49 50 51 52 56 57 57
IF                   : 58 59 60 61
IN                   : 56 57
INTEGER              : 24
LPAREN               : 17 18 22 49 50 56
LSBRACKET            : 
MOD_OP               : 33
MUL_OP               : 31
OR                   : 36
QUOTE                : 
RANGE                : 56
RETURN               : 11 12
RPAREN               : 17 18 22 49 50 56
RSBRACKET            : 
SUB_OP               : 30
TRUE                 : 27
WHILE                : 55
error                : 

Nonterminals, with rules where they appear

assignment           : 6
body                 : 48 54 55 56 57 58 59 60 60 61 61 62 63
boolean              : 26
call_args            : 17 20
comb_op              : 34
comp_op              : 35
compound_stmt        : 4
const_decl           : 7
elseif_list          : 59 60 63
expr                 : 8 12 15 16 19 20 22 29 29 30 30 31 31 32 32 33 33 34 34 35 35 55 56 56 58 59 60 61 62 63
for_stmt             : 47
func_call            : 23
func_def             : 44
func_def_args        : 49 52
head                 : 48
if_stmt              : 45
loop_stmt            : 10
program              : 2 0
return_stmt          : 9
simple_stmt          : 3
small_stmt           : 5
stmt                 : 1 2 53 54
while_stmt           : 46

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . stmt
    (2) program -> . stmt program
    (3) stmt -> . simple_stmt
    (4) stmt -> . compound_stmt
    (5) simple_stmt -> . small_stmt END_STATEMENT
    (44) compound_stmt -> . func_def
    (45) compound_stmt -> . if_stmt
    (46) compound_stmt -> . while_stmt
    (47) compound_stmt -> . for_stmt
    (6) small_stmt -> . assignment
    (7) small_stmt -> . const_decl
    (8) small_stmt -> . expr
    (9) small_stmt -> . return_stmt
    (10) small_stmt -> . loop_stmt
    (48) func_def -> . FUNCTION head END_STATEMENT body END END_STATEMENT
    (58) if_stmt -> . IF expr COLON END_STATEMENT body END END_STATEMENT
    (59) if_stmt -> . IF expr COLON END_STATEMENT body END END_STATEMENT elseif_list
    (60) if_stmt -> . IF expr COLON END_STATEMENT body END END_STATEMENT elseif_list ELSE COLON END_STATEMENT body END END_STATEMENT
    (61) if_stmt -> . IF expr COLON END_STATEMENT body END END_STATEMENT ELSE COLON END_STATEMENT body END END_STATEMENT
    (55) while_stmt -> . WHILE expr COLON END_STATEMENT body END END_STATEMENT
    (56) for_stmt -> . FOR IDENTIFIER IN RANGE LPAREN expr COMMA expr RPAREN COLON END_STATEMENT body END END_STATEMENT
    (57) for_stmt -> . FOR IDENTIFIER IN IDENTIFIER COLON END_STATEMENT body END END_STATEMENT
    (15) assignment -> . IDENTIFIER ASSIGN expr
    (16) const_decl -> . IDENTIFIER CONST expr
    (21) expr -> . IDENTIFIER
    (22) expr -> . LPAREN expr RPAREN
    (23) expr -> . func_call
    (24) expr -> . INTEGER
    (25) expr -> . DOUBLE
    (26) expr -> . boolean
    (29) expr -> . expr ADD_OP expr
    (30) expr -> . expr SUB_OP expr
    (31) expr -> . expr MUL_OP expr
    (32) expr -> . expr DIV_OP expr
    (33) expr -> . expr MOD_OP expr
    (34) expr -> . expr comb_op expr
    (35) expr -> . expr comp_op expr
    (11) return_stmt -> . RETURN
    (12) return_stmt -> . RETURN expr
    (13) loop_stmt -> . BREAK
    (14) loop_stmt -> . CONTINUE
    (17) func_call -> . IDENTIFIER LPAREN call_args RPAREN
    (18) func_call -> . IDENTIFIER LPAREN RPAREN
    (27) boolean -> . TRUE
    (28) boolean -> . FALSE

    FUNCTION        shift and go to state 1
    IF              shift and go to state 21
    WHILE           shift and go to state 3
    FOR             shift and go to state 9
    IDENTIFIER      shift and go to state 12
    LPAREN          shift and go to state 20
    INTEGER         shift and go to state 7
    DOUBLE          shift and go to state 29
    RETURN          shift and go to state 6
    BREAK           shift and go to state 26
    CONTINUE        shift and go to state 28
    TRUE            shift and go to state 8
    FALSE           shift and go to state 23

    small_stmt                     shift and go to state 2
    boolean                        shift and go to state 4
    return_stmt                    shift and go to state 5
    const_decl                     shift and go to state 10
    program                        shift and go to state 11
    compound_stmt                  shift and go to state 13
    func_def                       shift and go to state 14
    simple_stmt                    shift and go to state 15
    assignment                     shift and go to state 16
    stmt                           shift and go to state 17
    for_stmt                       shift and go to state 18
    loop_stmt                      shift and go to state 19
    func_call                      shift and go to state 22
    if_stmt                        shift and go to state 24
    expr                           shift and go to state 25
    while_stmt                     shift and go to state 27

state 1

    (48) func_def -> FUNCTION . head END_STATEMENT body END END_STATEMENT
    (49) head -> . IDENTIFIER LPAREN func_def_args RPAREN COLON
    (50) head -> . IDENTIFIER LPAREN RPAREN COLON

    IDENTIFIER      shift and go to state 31

    head                           shift and go to state 30

state 2

    (5) simple_stmt -> small_stmt . END_STATEMENT

    END_STATEMENT   shift and go to state 32


state 3

    (55) while_stmt -> WHILE . expr COLON END_STATEMENT body END END_STATEMENT
    (21) expr -> . IDENTIFIER
    (22) expr -> . LPAREN expr RPAREN
    (23) expr -> . func_call
    (24) expr -> . INTEGER
    (25) expr -> . DOUBLE
    (26) expr -> . boolean
    (29) expr -> . expr ADD_OP expr
    (30) expr -> . expr SUB_OP expr
    (31) expr -> . expr MUL_OP expr
    (32) expr -> . expr DIV_OP expr
    (33) expr -> . expr MOD_OP expr
    (34) expr -> . expr comb_op expr
    (35) expr -> . expr comp_op expr
    (17) func_call -> . IDENTIFIER LPAREN call_args RPAREN
    (18) func_call -> . IDENTIFIER LPAREN RPAREN
    (27) boolean -> . TRUE
    (28) boolean -> . FALSE

    IDENTIFIER      shift and go to state 33
    LPAREN          shift and go to state 20
    INTEGER         shift and go to state 7
    DOUBLE          shift and go to state 29
    TRUE            shift and go to state 8
    FALSE           shift and go to state 23

    func_call                      shift and go to state 22
    expr                           shift and go to state 34
    boolean                        shift and go to state 4

state 4

    (26) expr -> boolean .

    ADD_OP          reduce using rule 26 (expr -> boolean .)
    SUB_OP          reduce using rule 26 (expr -> boolean .)
    MUL_OP          reduce using rule 26 (expr -> boolean .)
    DIV_OP          reduce using rule 26 (expr -> boolean .)
    MOD_OP          reduce using rule 26 (expr -> boolean .)
    OR              reduce using rule 26 (expr -> boolean .)
    AND             reduce using rule 26 (expr -> boolean .)
    CEQ             reduce using rule 26 (expr -> boolean .)
    CNE             reduce using rule 26 (expr -> boolean .)
    CLT             reduce using rule 26 (expr -> boolean .)
    CLE             reduce using rule 26 (expr -> boolean .)
    CGT             reduce using rule 26 (expr -> boolean .)
    CGE             reduce using rule 26 (expr -> boolean .)
    END_STATEMENT   reduce using rule 26 (expr -> boolean .)
    COMMA           reduce using rule 26 (expr -> boolean .)
    RPAREN          reduce using rule 26 (expr -> boolean .)
    COLON           reduce using rule 26 (expr -> boolean .)


state 5

    (9) small_stmt -> return_stmt .

    END_STATEMENT   reduce using rule 9 (small_stmt -> return_stmt .)


state 6

    (11) return_stmt -> RETURN .
    (12) return_stmt -> RETURN . expr
    (21) expr -> . IDENTIFIER
    (22) expr -> . LPAREN expr RPAREN
    (23) expr -> . func_call
    (24) expr -> . INTEGER
    (25) expr -> . DOUBLE
    (26) expr -> . boolean
    (29) expr -> . expr ADD_OP expr
    (30) expr -> . expr SUB_OP expr
    (31) expr -> . expr MUL_OP expr
    (32) expr -> . expr DIV_OP expr
    (33) expr -> . expr MOD_OP expr
    (34) expr -> . expr comb_op expr
    (35) expr -> . expr comp_op expr
    (17) func_call -> . IDENTIFIER LPAREN call_args RPAREN
    (18) func_call -> . IDENTIFIER LPAREN RPAREN
    (27) boolean -> . TRUE
    (28) boolean -> . FALSE

    END_STATEMENT   reduce using rule 11 (return_stmt -> RETURN .)
    IDENTIFIER      shift and go to state 33
    LPAREN          shift and go to state 20
    INTEGER         shift and go to state 7
    DOUBLE          shift and go to state 29
    TRUE            shift and go to state 8
    FALSE           shift and go to state 23

    func_call                      shift and go to state 22
    expr                           shift and go to state 35
    boolean                        shift and go to state 4

state 7

    (24) expr -> INTEGER .

    ADD_OP          reduce using rule 24 (expr -> INTEGER .)
    SUB_OP          reduce using rule 24 (expr -> INTEGER .)
    MUL_OP          reduce using rule 24 (expr -> INTEGER .)
    DIV_OP          reduce using rule 24 (expr -> INTEGER .)
    MOD_OP          reduce using rule 24 (expr -> INTEGER .)
    OR              reduce using rule 24 (expr -> INTEGER .)
    AND             reduce using rule 24 (expr -> INTEGER .)
    CEQ             reduce using rule 24 (expr -> INTEGER .)
    CNE             reduce using rule 24 (expr -> INTEGER .)
    CLT             reduce using rule 24 (expr -> INTEGER .)
    CLE             reduce using rule 24 (expr -> INTEGER .)
    CGT             reduce using rule 24 (expr -> INTEGER .)
    CGE             reduce using rule 24 (expr -> INTEGER .)
    END_STATEMENT   reduce using rule 24 (expr -> INTEGER .)
    COMMA           reduce using rule 24 (expr -> INTEGER .)
    RPAREN          reduce using rule 24 (expr -> INTEGER .)
    COLON           reduce using rule 24 (expr -> INTEGER .)


state 8

    (27) boolean -> TRUE .

    COMMA           reduce using rule 27 (boolean -> TRUE .)
    ADD_OP          reduce using rule 27 (boolean -> TRUE .)
    SUB_OP          reduce using rule 27 (boolean -> TRUE .)
    MUL_OP          reduce using rule 27 (boolean -> TRUE .)
    DIV_OP          reduce using rule 27 (boolean -> TRUE .)
    MOD_OP          reduce using rule 27 (boolean -> TRUE .)
    OR              reduce using rule 27 (boolean -> TRUE .)
    AND             reduce using rule 27 (boolean -> TRUE .)
    CEQ             reduce using rule 27 (boolean -> TRUE .)
    CNE             reduce using rule 27 (boolean -> TRUE .)
    CLT             reduce using rule 27 (boolean -> TRUE .)
    CLE             reduce using rule 27 (boolean -> TRUE .)
    CGT             reduce using rule 27 (boolean -> TRUE .)
    CGE             reduce using rule 27 (boolean -> TRUE .)
    RPAREN          reduce using rule 27 (boolean -> TRUE .)
    END_STATEMENT   reduce using rule 27 (boolean -> TRUE .)
    COLON           reduce using rule 27 (boolean -> TRUE .)


state 9

    (56) for_stmt -> FOR . IDENTIFIER IN RANGE LPAREN expr COMMA expr RPAREN COLON END_STATEMENT body END END_STATEMENT
    (57) for_stmt -> FOR . IDENTIFIER IN IDENTIFIER COLON END_STATEMENT body END END_STATEMENT

    IDENTIFIER      shift and go to state 36


state 10

    (7) small_stmt -> const_decl .

    END_STATEMENT   reduce using rule 7 (small_stmt -> const_decl .)


state 11

    (0) S' -> program .



state 12

    (15) assignment -> IDENTIFIER . ASSIGN expr
    (16) const_decl -> IDENTIFIER . CONST expr
    (21) expr -> IDENTIFIER .
    (17) func_call -> IDENTIFIER . LPAREN call_args RPAREN
    (18) func_call -> IDENTIFIER . LPAREN RPAREN

    ASSIGN          shift and go to state 39
    CONST           shift and go to state 37
    ADD_OP          reduce using rule 21 (expr -> IDENTIFIER .)
    SUB_OP          reduce using rule 21 (expr -> IDENTIFIER .)
    MUL_OP          reduce using rule 21 (expr -> IDENTIFIER .)
    DIV_OP          reduce using rule 21 (expr -> IDENTIFIER .)
    MOD_OP          reduce using rule 21 (expr -> IDENTIFIER .)
    OR              reduce using rule 21 (expr -> IDENTIFIER .)
    AND             reduce using rule 21 (expr -> IDENTIFIER .)
    CEQ             reduce using rule 21 (expr -> IDENTIFIER .)
    CNE             reduce using rule 21 (expr -> IDENTIFIER .)
    CLT             reduce using rule 21 (expr -> IDENTIFIER .)
    CLE             reduce using rule 21 (expr -> IDENTIFIER .)
    CGT             reduce using rule 21 (expr -> IDENTIFIER .)
    CGE             reduce using rule 21 (expr -> IDENTIFIER .)
    END_STATEMENT   reduce using rule 21 (expr -> IDENTIFIER .)
    LPAREN          shift and go to state 38


state 13

    (4) stmt -> compound_stmt .

    FUNCTION        reduce using rule 4 (stmt -> compound_stmt .)
    IF              reduce using rule 4 (stmt -> compound_stmt .)
    WHILE           reduce using rule 4 (stmt -> compound_stmt .)
    FOR             reduce using rule 4 (stmt -> compound_stmt .)
    IDENTIFIER      reduce using rule 4 (stmt -> compound_stmt .)
    LPAREN          reduce using rule 4 (stmt -> compound_stmt .)
    INTEGER         reduce using rule 4 (stmt -> compound_stmt .)
    DOUBLE          reduce using rule 4 (stmt -> compound_stmt .)
    RETURN          reduce using rule 4 (stmt -> compound_stmt .)
    BREAK           reduce using rule 4 (stmt -> compound_stmt .)
    CONTINUE        reduce using rule 4 (stmt -> compound_stmt .)
    TRUE            reduce using rule 4 (stmt -> compound_stmt .)
    FALSE           reduce using rule 4 (stmt -> compound_stmt .)
    END             reduce using rule 4 (stmt -> compound_stmt .)
    $end            reduce using rule 4 (stmt -> compound_stmt .)


state 14

    (44) compound_stmt -> func_def .

    FUNCTION        reduce using rule 44 (compound_stmt -> func_def .)
    IF              reduce using rule 44 (compound_stmt -> func_def .)
    WHILE           reduce using rule 44 (compound_stmt -> func_def .)
    FOR             reduce using rule 44 (compound_stmt -> func_def .)
    IDENTIFIER      reduce using rule 44 (compound_stmt -> func_def .)
    LPAREN          reduce using rule 44 (compound_stmt -> func_def .)
    INTEGER         reduce using rule 44 (compound_stmt -> func_def .)
    DOUBLE          reduce using rule 44 (compound_stmt -> func_def .)
    RETURN          reduce using rule 44 (compound_stmt -> func_def .)
    BREAK           reduce using rule 44 (compound_stmt -> func_def .)
    CONTINUE        reduce using rule 44 (compound_stmt -> func_def .)
    TRUE            reduce using rule 44 (compound_stmt -> func_def .)
    FALSE           reduce using rule 44 (compound_stmt -> func_def .)
    END             reduce using rule 44 (compound_stmt -> func_def .)
    $end            reduce using rule 44 (compound_stmt -> func_def .)


state 15

    (3) stmt -> simple_stmt .

    FUNCTION        reduce using rule 3 (stmt -> simple_stmt .)
    IF              reduce using rule 3 (stmt -> simple_stmt .)
    WHILE           reduce using rule 3 (stmt -> simple_stmt .)
    FOR             reduce using rule 3 (stmt -> simple_stmt .)
    IDENTIFIER      reduce using rule 3 (stmt -> simple_stmt .)
    LPAREN          reduce using rule 3 (stmt -> simple_stmt .)
    INTEGER         reduce using rule 3 (stmt -> simple_stmt .)
    DOUBLE          reduce using rule 3 (stmt -> simple_stmt .)
    RETURN          reduce using rule 3 (stmt -> simple_stmt .)
    BREAK           reduce using rule 3 (stmt -> simple_stmt .)
    CONTINUE        reduce using rule 3 (stmt -> simple_stmt .)
    TRUE            reduce using rule 3 (stmt -> simple_stmt .)
    FALSE           reduce using rule 3 (stmt -> simple_stmt .)
    END             reduce using rule 3 (stmt -> simple_stmt .)
    $end            reduce using rule 3 (stmt -> simple_stmt .)


state 16

    (6) small_stmt -> assignment .

    END_STATEMENT   reduce using rule 6 (small_stmt -> assignment .)


state 17

    (1) program -> stmt .
    (2) program -> stmt . program
    (1) program -> . stmt
    (2) program -> . stmt program
    (3) stmt -> . simple_stmt
    (4) stmt -> . compound_stmt
    (5) simple_stmt -> . small_stmt END_STATEMENT
    (44) compound_stmt -> . func_def
    (45) compound_stmt -> . if_stmt
    (46) compound_stmt -> . while_stmt
    (47) compound_stmt -> . for_stmt
    (6) small_stmt -> . assignment
    (7) small_stmt -> . const_decl
    (8) small_stmt -> . expr
    (9) small_stmt -> . return_stmt
    (10) small_stmt -> . loop_stmt
    (48) func_def -> . FUNCTION head END_STATEMENT body END END_STATEMENT
    (58) if_stmt -> . IF expr COLON END_STATEMENT body END END_STATEMENT
    (59) if_stmt -> . IF expr COLON END_STATEMENT body END END_STATEMENT elseif_list
    (60) if_stmt -> . IF expr COLON END_STATEMENT body END END_STATEMENT elseif_list ELSE COLON END_STATEMENT body END END_STATEMENT
    (61) if_stmt -> . IF expr COLON END_STATEMENT body END END_STATEMENT ELSE COLON END_STATEMENT body END END_STATEMENT
    (55) while_stmt -> . WHILE expr COLON END_STATEMENT body END END_STATEMENT
    (56) for_stmt -> . FOR IDENTIFIER IN RANGE LPAREN expr COMMA expr RPAREN COLON END_STATEMENT body END END_STATEMENT
    (57) for_stmt -> . FOR IDENTIFIER IN IDENTIFIER COLON END_STATEMENT body END END_STATEMENT
    (15) assignment -> . IDENTIFIER ASSIGN expr
    (16) const_decl -> . IDENTIFIER CONST expr
    (21) expr -> . IDENTIFIER
    (22) expr -> . LPAREN expr RPAREN
    (23) expr -> . func_call
    (24) expr -> . INTEGER
    (25) expr -> . DOUBLE
    (26) expr -> . boolean
    (29) expr -> . expr ADD_OP expr
    (30) expr -> . expr SUB_OP expr
    (31) expr -> . expr MUL_OP expr
    (32) expr -> . expr DIV_OP expr
    (33) expr -> . expr MOD_OP expr
    (34) expr -> . expr comb_op expr
    (35) expr -> . expr comp_op expr
    (11) return_stmt -> . RETURN
    (12) return_stmt -> . RETURN expr
    (13) loop_stmt -> . BREAK
    (14) loop_stmt -> . CONTINUE
    (17) func_call -> . IDENTIFIER LPAREN call_args RPAREN
    (18) func_call -> . IDENTIFIER LPAREN RPAREN
    (27) boolean -> . TRUE
    (28) boolean -> . FALSE

    $end            reduce using rule 1 (program -> stmt .)
    FUNCTION        shift and go to state 1
    IF              shift and go to state 21
    WHILE           shift and go to state 3
    FOR             shift and go to state 9
    IDENTIFIER      shift and go to state 12
    LPAREN          shift and go to state 20
    INTEGER         shift and go to state 7
    DOUBLE          shift and go to state 29
    RETURN          shift and go to state 6
    BREAK           shift and go to state 26
    CONTINUE        shift and go to state 28
    TRUE            shift and go to state 8
    FALSE           shift and go to state 23

    small_stmt                     shift and go to state 2
    boolean                        shift and go to state 4
    return_stmt                    shift and go to state 5
    const_decl                     shift and go to state 10
    program                        shift and go to state 40
    compound_stmt                  shift and go to state 13
    func_def                       shift and go to state 14
    simple_stmt                    shift and go to state 15
    assignment                     shift and go to state 16
    stmt                           shift and go to state 17
    for_stmt                       shift and go to state 18
    loop_stmt                      shift and go to state 19
    func_call                      shift and go to state 22
    if_stmt                        shift and go to state 24
    expr                           shift and go to state 25
    while_stmt                     shift and go to state 27

state 18

    (47) compound_stmt -> for_stmt .

    FUNCTION        reduce using rule 47 (compound_stmt -> for_stmt .)
    IF              reduce using rule 47 (compound_stmt -> for_stmt .)
    WHILE           reduce using rule 47 (compound_stmt -> for_stmt .)
    FOR             reduce using rule 47 (compound_stmt -> for_stmt .)
    IDENTIFIER      reduce using rule 47 (compound_stmt -> for_stmt .)
    LPAREN          reduce using rule 47 (compound_stmt -> for_stmt .)
    INTEGER         reduce using rule 47 (compound_stmt -> for_stmt .)
    DOUBLE          reduce using rule 47 (compound_stmt -> for_stmt .)
    RETURN          reduce using rule 47 (compound_stmt -> for_stmt .)
    BREAK           reduce using rule 47 (compound_stmt -> for_stmt .)
    CONTINUE        reduce using rule 47 (compound_stmt -> for_stmt .)
    TRUE            reduce using rule 47 (compound_stmt -> for_stmt .)
    FALSE           reduce using rule 47 (compound_stmt -> for_stmt .)
    END             reduce using rule 47 (compound_stmt -> for_stmt .)
    $end            reduce using rule 47 (compound_stmt -> for_stmt .)


state 19

    (10) small_stmt -> loop_stmt .

    END_STATEMENT   reduce using rule 10 (small_stmt -> loop_stmt .)


state 20

    (22) expr -> LPAREN . expr RPAREN
    (21) expr -> . IDENTIFIER
    (22) expr -> . LPAREN expr RPAREN
    (23) expr -> . func_call
    (24) expr -> . INTEGER
    (25) expr -> . DOUBLE
    (26) expr -> . boolean
    (29) expr -> . expr ADD_OP expr
    (30) expr -> . expr SUB_OP expr
    (31) expr -> . expr MUL_OP expr
    (32) expr -> . expr DIV_OP expr
    (33) expr -> . expr MOD_OP expr
    (34) expr -> . expr comb_op expr
    (35) expr -> . expr comp_op expr
    (17) func_call -> . IDENTIFIER LPAREN call_args RPAREN
    (18) func_call -> . IDENTIFIER LPAREN RPAREN
    (27) boolean -> . TRUE
    (28) boolean -> . FALSE

    IDENTIFIER      shift and go to state 33
    LPAREN          shift and go to state 20
    INTEGER         shift and go to state 7
    DOUBLE          shift and go to state 29
    TRUE            shift and go to state 8
    FALSE           shift and go to state 23

    func_call                      shift and go to state 22
    expr                           shift and go to state 41
    boolean                        shift and go to state 4

state 21

    (58) if_stmt -> IF . expr COLON END_STATEMENT body END END_STATEMENT
    (59) if_stmt -> IF . expr COLON END_STATEMENT body END END_STATEMENT elseif_list
    (60) if_stmt -> IF . expr COLON END_STATEMENT body END END_STATEMENT elseif_list ELSE COLON END_STATEMENT body END END_STATEMENT
    (61) if_stmt -> IF . expr COLON END_STATEMENT body END END_STATEMENT ELSE COLON END_STATEMENT body END END_STATEMENT
    (21) expr -> . IDENTIFIER
    (22) expr -> . LPAREN expr RPAREN
    (23) expr -> . func_call
    (24) expr -> . INTEGER
    (25) expr -> . DOUBLE
    (26) expr -> . boolean
    (29) expr -> . expr ADD_OP expr
    (30) expr -> . expr SUB_OP expr
    (31) expr -> . expr MUL_OP expr
    (32) expr -> . expr DIV_OP expr
    (33) expr -> . expr MOD_OP expr
    (34) expr -> . expr comb_op expr
    (35) expr -> . expr comp_op expr
    (17) func_call -> . IDENTIFIER LPAREN call_args RPAREN
    (18) func_call -> . IDENTIFIER LPAREN RPAREN
    (27) boolean -> . TRUE
    (28) boolean -> . FALSE

    IDENTIFIER      shift and go to state 33
    LPAREN          shift and go to state 20
    INTEGER         shift and go to state 7
    DOUBLE          shift and go to state 29
    TRUE            shift and go to state 8
    FALSE           shift and go to state 23

    func_call                      shift and go to state 22
    expr                           shift and go to state 42
    boolean                        shift and go to state 4

state 22

    (23) expr -> func_call .

    ADD_OP          reduce using rule 23 (expr -> func_call .)
    SUB_OP          reduce using rule 23 (expr -> func_call .)
    MUL_OP          reduce using rule 23 (expr -> func_call .)
    DIV_OP          reduce using rule 23 (expr -> func_call .)
    MOD_OP          reduce using rule 23 (expr -> func_call .)
    OR              reduce using rule 23 (expr -> func_call .)
    AND             reduce using rule 23 (expr -> func_call .)
    CEQ             reduce using rule 23 (expr -> func_call .)
    CNE             reduce using rule 23 (expr -> func_call .)
    CLT             reduce using rule 23 (expr -> func_call .)
    CLE             reduce using rule 23 (expr -> func_call .)
    CGT             reduce using rule 23 (expr -> func_call .)
    CGE             reduce using rule 23 (expr -> func_call .)
    END_STATEMENT   reduce using rule 23 (expr -> func_call .)
    COMMA           reduce using rule 23 (expr -> func_call .)
    RPAREN          reduce using rule 23 (expr -> func_call .)
    COLON           reduce using rule 23 (expr -> func_call .)


state 23

    (28) boolean -> FALSE .

    COMMA           reduce using rule 28 (boolean -> FALSE .)
    ADD_OP          reduce using rule 28 (boolean -> FALSE .)
    SUB_OP          reduce using rule 28 (boolean -> FALSE .)
    MUL_OP          reduce using rule 28 (boolean -> FALSE .)
    DIV_OP          reduce using rule 28 (boolean -> FALSE .)
    MOD_OP          reduce using rule 28 (boolean -> FALSE .)
    OR              reduce using rule 28 (boolean -> FALSE .)
    AND             reduce using rule 28 (boolean -> FALSE .)
    CEQ             reduce using rule 28 (boolean -> FALSE .)
    CNE             reduce using rule 28 (boolean -> FALSE .)
    CLT             reduce using rule 28 (boolean -> FALSE .)
    CLE             reduce using rule 28 (boolean -> FALSE .)
    CGT             reduce using rule 28 (boolean -> FALSE .)
    CGE             reduce using rule 28 (boolean -> FALSE .)
    RPAREN          reduce using rule 28 (boolean -> FALSE .)
    END_STATEMENT   reduce using rule 28 (boolean -> FALSE .)
    COLON           reduce using rule 28 (boolean -> FALSE .)


state 24

    (45) compound_stmt -> if_stmt .

    FUNCTION        reduce using rule 45 (compound_stmt -> if_stmt .)
    IF              reduce using rule 45 (compound_stmt -> if_stmt .)
    WHILE           reduce using rule 45 (compound_stmt -> if_stmt .)
    FOR             reduce using rule 45 (compound_stmt -> if_stmt .)
    IDENTIFIER      reduce using rule 45 (compound_stmt -> if_stmt .)
    LPAREN          reduce using rule 45 (compound_stmt -> if_stmt .)
    INTEGER         reduce using rule 45 (compound_stmt -> if_stmt .)
    DOUBLE          reduce using rule 45 (compound_stmt -> if_stmt .)
    RETURN          reduce using rule 45 (compound_stmt -> if_stmt .)
    BREAK           reduce using rule 45 (compound_stmt -> if_stmt .)
    CONTINUE        reduce using rule 45 (compound_stmt -> if_stmt .)
    TRUE            reduce using rule 45 (compound_stmt -> if_stmt .)
    FALSE           reduce using rule 45 (compound_stmt -> if_stmt .)
    END             reduce using rule 45 (compound_stmt -> if_stmt .)
    $end            reduce using rule 45 (compound_stmt -> if_stmt .)


state 25

    (8) small_stmt -> expr .
    (29) expr -> expr . ADD_OP expr
    (30) expr -> expr . SUB_OP expr
    (31) expr -> expr . MUL_OP expr
    (32) expr -> expr . DIV_OP expr
    (33) expr -> expr . MOD_OP expr
    (34) expr -> expr . comb_op expr
    (35) expr -> expr . comp_op expr
    (36) comb_op -> . OR
    (37) comb_op -> . AND
    (38) comp_op -> . CEQ
    (39) comp_op -> . CNE
    (40) comp_op -> . CLT
    (41) comp_op -> . CLE
    (42) comp_op -> . CGT
    (43) comp_op -> . CGE

    END_STATEMENT   reduce using rule 8 (small_stmt -> expr .)
    ADD_OP          shift and go to state 54
    SUB_OP          shift and go to state 50
    MUL_OP          shift and go to state 45
    DIV_OP          shift and go to state 51
    MOD_OP          shift and go to state 56
    OR              shift and go to state 57
    AND             shift and go to state 43
    CEQ             shift and go to state 53
    CNE             shift and go to state 52
    CLT             shift and go to state 55
    CLE             shift and go to state 44
    CGT             shift and go to state 46
    CGE             shift and go to state 47

    comp_op                        shift and go to state 49
    comb_op                        shift and go to state 48

state 26

    (13) loop_stmt -> BREAK .

    END_STATEMENT   reduce using rule 13 (loop_stmt -> BREAK .)


state 27

    (46) compound_stmt -> while_stmt .

    FUNCTION        reduce using rule 46 (compound_stmt -> while_stmt .)
    IF              reduce using rule 46 (compound_stmt -> while_stmt .)
    WHILE           reduce using rule 46 (compound_stmt -> while_stmt .)
    FOR             reduce using rule 46 (compound_stmt -> while_stmt .)
    IDENTIFIER      reduce using rule 46 (compound_stmt -> while_stmt .)
    LPAREN          reduce using rule 46 (compound_stmt -> while_stmt .)
    INTEGER         reduce using rule 46 (compound_stmt -> while_stmt .)
    DOUBLE          reduce using rule 46 (compound_stmt -> while_stmt .)
    RETURN          reduce using rule 46 (compound_stmt -> while_stmt .)
    BREAK           reduce using rule 46 (compound_stmt -> while_stmt .)
    CONTINUE        reduce using rule 46 (compound_stmt -> while_stmt .)
    TRUE            reduce using rule 46 (compound_stmt -> while_stmt .)
    FALSE           reduce using rule 46 (compound_stmt -> while_stmt .)
    END             reduce using rule 46 (compound_stmt -> while_stmt .)
    $end            reduce using rule 46 (compound_stmt -> while_stmt .)


state 28

    (14) loop_stmt -> CONTINUE .

    END_STATEMENT   reduce using rule 14 (loop_stmt -> CONTINUE .)


state 29

    (25) expr -> DOUBLE .

    ADD_OP          reduce using rule 25 (expr -> DOUBLE .)
    SUB_OP          reduce using rule 25 (expr -> DOUBLE .)
    MUL_OP          reduce using rule 25 (expr -> DOUBLE .)
    DIV_OP          reduce using rule 25 (expr -> DOUBLE .)
    MOD_OP          reduce using rule 25 (expr -> DOUBLE .)
    OR              reduce using rule 25 (expr -> DOUBLE .)
    AND             reduce using rule 25 (expr -> DOUBLE .)
    CEQ             reduce using rule 25 (expr -> DOUBLE .)
    CNE             reduce using rule 25 (expr -> DOUBLE .)
    CLT             reduce using rule 25 (expr -> DOUBLE .)
    CLE             reduce using rule 25 (expr -> DOUBLE .)
    CGT             reduce using rule 25 (expr -> DOUBLE .)
    CGE             reduce using rule 25 (expr -> DOUBLE .)
    END_STATEMENT   reduce using rule 25 (expr -> DOUBLE .)
    COMMA           reduce using rule 25 (expr -> DOUBLE .)
    RPAREN          reduce using rule 25 (expr -> DOUBLE .)
    COLON           reduce using rule 25 (expr -> DOUBLE .)


state 30

    (48) func_def -> FUNCTION head . END_STATEMENT body END END_STATEMENT

    END_STATEMENT   shift and go to state 58


state 31

    (49) head -> IDENTIFIER . LPAREN func_def_args RPAREN COLON
    (50) head -> IDENTIFIER . LPAREN RPAREN COLON

    LPAREN          shift and go to state 59


state 32

    (5) simple_stmt -> small_stmt END_STATEMENT .

    FUNCTION        reduce using rule 5 (simple_stmt -> small_stmt END_STATEMENT .)
    IF              reduce using rule 5 (simple_stmt -> small_stmt END_STATEMENT .)
    WHILE           reduce using rule 5 (simple_stmt -> small_stmt END_STATEMENT .)
    FOR             reduce using rule 5 (simple_stmt -> small_stmt END_STATEMENT .)
    IDENTIFIER      reduce using rule 5 (simple_stmt -> small_stmt END_STATEMENT .)
    LPAREN          reduce using rule 5 (simple_stmt -> small_stmt END_STATEMENT .)
    INTEGER         reduce using rule 5 (simple_stmt -> small_stmt END_STATEMENT .)
    DOUBLE          reduce using rule 5 (simple_stmt -> small_stmt END_STATEMENT .)
    RETURN          reduce using rule 5 (simple_stmt -> small_stmt END_STATEMENT .)
    BREAK           reduce using rule 5 (simple_stmt -> small_stmt END_STATEMENT .)
    CONTINUE        reduce using rule 5 (simple_stmt -> small_stmt END_STATEMENT .)
    TRUE            reduce using rule 5 (simple_stmt -> small_stmt END_STATEMENT .)
    FALSE           reduce using rule 5 (simple_stmt -> small_stmt END_STATEMENT .)
    END             reduce using rule 5 (simple_stmt -> small_stmt END_STATEMENT .)
    $end            reduce using rule 5 (simple_stmt -> small_stmt END_STATEMENT .)


state 33

    (21) expr -> IDENTIFIER .
    (17) func_call -> IDENTIFIER . LPAREN call_args RPAREN
    (18) func_call -> IDENTIFIER . LPAREN RPAREN

    ADD_OP          reduce using rule 21 (expr -> IDENTIFIER .)
    SUB_OP          reduce using rule 21 (expr -> IDENTIFIER .)
    MUL_OP          reduce using rule 21 (expr -> IDENTIFIER .)
    DIV_OP          reduce using rule 21 (expr -> IDENTIFIER .)
    MOD_OP          reduce using rule 21 (expr -> IDENTIFIER .)
    OR              reduce using rule 21 (expr -> IDENTIFIER .)
    AND             reduce using rule 21 (expr -> IDENTIFIER .)
    CEQ             reduce using rule 21 (expr -> IDENTIFIER .)
    CNE             reduce using rule 21 (expr -> IDENTIFIER .)
    CLT             reduce using rule 21 (expr -> IDENTIFIER .)
    CLE             reduce using rule 21 (expr -> IDENTIFIER .)
    CGT             reduce using rule 21 (expr -> IDENTIFIER .)
    CGE             reduce using rule 21 (expr -> IDENTIFIER .)
    END_STATEMENT   reduce using rule 21 (expr -> IDENTIFIER .)
    COMMA           reduce using rule 21 (expr -> IDENTIFIER .)
    RPAREN          reduce using rule 21 (expr -> IDENTIFIER .)
    COLON           reduce using rule 21 (expr -> IDENTIFIER .)
    LPAREN          shift and go to state 38


state 34

    (55) while_stmt -> WHILE expr . COLON END_STATEMENT body END END_STATEMENT
    (29) expr -> expr . ADD_OP expr
    (30) expr -> expr . SUB_OP expr
    (31) expr -> expr . MUL_OP expr
    (32) expr -> expr . DIV_OP expr
    (33) expr -> expr . MOD_OP expr
    (34) expr -> expr . comb_op expr
    (35) expr -> expr . comp_op expr
    (36) comb_op -> . OR
    (37) comb_op -> . AND
    (38) comp_op -> . CEQ
    (39) comp_op -> . CNE
    (40) comp_op -> . CLT
    (41) comp_op -> . CLE
    (42) comp_op -> . CGT
    (43) comp_op -> . CGE

    COLON           shift and go to state 60
    ADD_OP          shift and go to state 54
    SUB_OP          shift and go to state 50
    MUL_OP          shift and go to state 45
    DIV_OP          shift and go to state 51
    MOD_OP          shift and go to state 56
    OR              shift and go to state 57
    AND             shift and go to state 43
    CEQ             shift and go to state 53
    CNE             shift and go to state 52
    CLT             shift and go to state 55
    CLE             shift and go to state 44
    CGT             shift and go to state 46
    CGE             shift and go to state 47

    comp_op                        shift and go to state 49
    comb_op                        shift and go to state 48

state 35

    (12) return_stmt -> RETURN expr .
    (29) expr -> expr . ADD_OP expr
    (30) expr -> expr . SUB_OP expr
    (31) expr -> expr . MUL_OP expr
    (32) expr -> expr . DIV_OP expr
    (33) expr -> expr . MOD_OP expr
    (34) expr -> expr . comb_op expr
    (35) expr -> expr . comp_op expr
    (36) comb_op -> . OR
    (37) comb_op -> . AND
    (38) comp_op -> . CEQ
    (39) comp_op -> . CNE
    (40) comp_op -> . CLT
    (41) comp_op -> . CLE
    (42) comp_op -> . CGT
    (43) comp_op -> . CGE

    END_STATEMENT   reduce using rule 12 (return_stmt -> RETURN expr .)
    ADD_OP          shift and go to state 54
    SUB_OP          shift and go to state 50
    MUL_OP          shift and go to state 45
    DIV_OP          shift and go to state 51
    MOD_OP          shift and go to state 56
    OR              shift and go to state 57
    AND             shift and go to state 43
    CEQ             shift and go to state 53
    CNE             shift and go to state 52
    CLT             shift and go to state 55
    CLE             shift and go to state 44
    CGT             shift and go to state 46
    CGE             shift and go to state 47

    comp_op                        shift and go to state 49
    comb_op                        shift and go to state 48

state 36

    (56) for_stmt -> FOR IDENTIFIER . IN RANGE LPAREN expr COMMA expr RPAREN COLON END_STATEMENT body END END_STATEMENT
    (57) for_stmt -> FOR IDENTIFIER . IN IDENTIFIER COLON END_STATEMENT body END END_STATEMENT

    IN              shift and go to state 61


state 37

    (16) const_decl -> IDENTIFIER CONST . expr
    (21) expr -> . IDENTIFIER
    (22) expr -> . LPAREN expr RPAREN
    (23) expr -> . func_call
    (24) expr -> . INTEGER
    (25) expr -> . DOUBLE
    (26) expr -> . boolean
    (29) expr -> . expr ADD_OP expr
    (30) expr -> . expr SUB_OP expr
    (31) expr -> . expr MUL_OP expr
    (32) expr -> . expr DIV_OP expr
    (33) expr -> . expr MOD_OP expr
    (34) expr -> . expr comb_op expr
    (35) expr -> . expr comp_op expr
    (17) func_call -> . IDENTIFIER LPAREN call_args RPAREN
    (18) func_call -> . IDENTIFIER LPAREN RPAREN
    (27) boolean -> . TRUE
    (28) boolean -> . FALSE

    IDENTIFIER      shift and go to state 33
    LPAREN          shift and go to state 20
    INTEGER         shift and go to state 7
    DOUBLE          shift and go to state 29
    TRUE            shift and go to state 8
    FALSE           shift and go to state 23

    func_call                      shift and go to state 22
    expr                           shift and go to state 62
    boolean                        shift and go to state 4

state 38

    (17) func_call -> IDENTIFIER LPAREN . call_args RPAREN
    (18) func_call -> IDENTIFIER LPAREN . RPAREN
    (19) call_args -> . expr
    (20) call_args -> . expr COMMA call_args
    (21) expr -> . IDENTIFIER
    (22) expr -> . LPAREN expr RPAREN
    (23) expr -> . func_call
    (24) expr -> . INTEGER
    (25) expr -> . DOUBLE
    (26) expr -> . boolean
    (29) expr -> . expr ADD_OP expr
    (30) expr -> . expr SUB_OP expr
    (31) expr -> . expr MUL_OP expr
    (32) expr -> . expr DIV_OP expr
    (33) expr -> . expr MOD_OP expr
    (34) expr -> . expr comb_op expr
    (35) expr -> . expr comp_op expr
    (17) func_call -> . IDENTIFIER LPAREN call_args RPAREN
    (18) func_call -> . IDENTIFIER LPAREN RPAREN
    (27) boolean -> . TRUE
    (28) boolean -> . FALSE

    RPAREN          shift and go to state 63
    IDENTIFIER      shift and go to state 33
    LPAREN          shift and go to state 20
    INTEGER         shift and go to state 7
    DOUBLE          shift and go to state 29
    TRUE            shift and go to state 8
    FALSE           shift and go to state 23

    func_call                      shift and go to state 22
    expr                           shift and go to state 64
    boolean                        shift and go to state 4
    call_args                      shift and go to state 65

state 39

    (15) assignment -> IDENTIFIER ASSIGN . expr
    (21) expr -> . IDENTIFIER
    (22) expr -> . LPAREN expr RPAREN
    (23) expr -> . func_call
    (24) expr -> . INTEGER
    (25) expr -> . DOUBLE
    (26) expr -> . boolean
    (29) expr -> . expr ADD_OP expr
    (30) expr -> . expr SUB_OP expr
    (31) expr -> . expr MUL_OP expr
    (32) expr -> . expr DIV_OP expr
    (33) expr -> . expr MOD_OP expr
    (34) expr -> . expr comb_op expr
    (35) expr -> . expr comp_op expr
    (17) func_call -> . IDENTIFIER LPAREN call_args RPAREN
    (18) func_call -> . IDENTIFIER LPAREN RPAREN
    (27) boolean -> . TRUE
    (28) boolean -> . FALSE

    IDENTIFIER      shift and go to state 33
    LPAREN          shift and go to state 20
    INTEGER         shift and go to state 7
    DOUBLE          shift and go to state 29
    TRUE            shift and go to state 8
    FALSE           shift and go to state 23

    func_call                      shift and go to state 22
    expr                           shift and go to state 66
    boolean                        shift and go to state 4

state 40

    (2) program -> stmt program .

    $end            reduce using rule 2 (program -> stmt program .)


state 41

    (22) expr -> LPAREN expr . RPAREN
    (29) expr -> expr . ADD_OP expr
    (30) expr -> expr . SUB_OP expr
    (31) expr -> expr . MUL_OP expr
    (32) expr -> expr . DIV_OP expr
    (33) expr -> expr . MOD_OP expr
    (34) expr -> expr . comb_op expr
    (35) expr -> expr . comp_op expr
    (36) comb_op -> . OR
    (37) comb_op -> . AND
    (38) comp_op -> . CEQ
    (39) comp_op -> . CNE
    (40) comp_op -> . CLT
    (41) comp_op -> . CLE
    (42) comp_op -> . CGT
    (43) comp_op -> . CGE

    RPAREN          shift and go to state 67
    ADD_OP          shift and go to state 54
    SUB_OP          shift and go to state 50
    MUL_OP          shift and go to state 45
    DIV_OP          shift and go to state 51
    MOD_OP          shift and go to state 56
    OR              shift and go to state 57
    AND             shift and go to state 43
    CEQ             shift and go to state 53
    CNE             shift and go to state 52
    CLT             shift and go to state 55
    CLE             shift and go to state 44
    CGT             shift and go to state 46
    CGE             shift and go to state 47

    comp_op                        shift and go to state 49
    comb_op                        shift and go to state 48

state 42

    (58) if_stmt -> IF expr . COLON END_STATEMENT body END END_STATEMENT
    (59) if_stmt -> IF expr . COLON END_STATEMENT body END END_STATEMENT elseif_list
    (60) if_stmt -> IF expr . COLON END_STATEMENT body END END_STATEMENT elseif_list ELSE COLON END_STATEMENT body END END_STATEMENT
    (61) if_stmt -> IF expr . COLON END_STATEMENT body END END_STATEMENT ELSE COLON END_STATEMENT body END END_STATEMENT
    (29) expr -> expr . ADD_OP expr
    (30) expr -> expr . SUB_OP expr
    (31) expr -> expr . MUL_OP expr
    (32) expr -> expr . DIV_OP expr
    (33) expr -> expr . MOD_OP expr
    (34) expr -> expr . comb_op expr
    (35) expr -> expr . comp_op expr
    (36) comb_op -> . OR
    (37) comb_op -> . AND
    (38) comp_op -> . CEQ
    (39) comp_op -> . CNE
    (40) comp_op -> . CLT
    (41) comp_op -> . CLE
    (42) comp_op -> . CGT
    (43) comp_op -> . CGE

    COLON           shift and go to state 68
    ADD_OP          shift and go to state 54
    SUB_OP          shift and go to state 50
    MUL_OP          shift and go to state 45
    DIV_OP          shift and go to state 51
    MOD_OP          shift and go to state 56
    OR              shift and go to state 57
    AND             shift and go to state 43
    CEQ             shift and go to state 53
    CNE             shift and go to state 52
    CLT             shift and go to state 55
    CLE             shift and go to state 44
    CGT             shift and go to state 46
    CGE             shift and go to state 47

    comp_op                        shift and go to state 49
    comb_op                        shift and go to state 48

state 43

    (37) comb_op -> AND .

    IDENTIFIER      reduce using rule 37 (comb_op -> AND .)
    LPAREN          reduce using rule 37 (comb_op -> AND .)
    INTEGER         reduce using rule 37 (comb_op -> AND .)
    DOUBLE          reduce using rule 37 (comb_op -> AND .)
    TRUE            reduce using rule 37 (comb_op -> AND .)
    FALSE           reduce using rule 37 (comb_op -> AND .)


state 44

    (41) comp_op -> CLE .

    IDENTIFIER      reduce using rule 41 (comp_op -> CLE .)
    LPAREN          reduce using rule 41 (comp_op -> CLE .)
    INTEGER         reduce using rule 41 (comp_op -> CLE .)
    DOUBLE          reduce using rule 41 (comp_op -> CLE .)
    TRUE            reduce using rule 41 (comp_op -> CLE .)
    FALSE           reduce using rule 41 (comp_op -> CLE .)


state 45

    (31) expr -> expr MUL_OP . expr
    (21) expr -> . IDENTIFIER
    (22) expr -> . LPAREN expr RPAREN
    (23) expr -> . func_call
    (24) expr -> . INTEGER
    (25) expr -> . DOUBLE
    (26) expr -> . boolean
    (29) expr -> . expr ADD_OP expr
    (30) expr -> . expr SUB_OP expr
    (31) expr -> . expr MUL_OP expr
    (32) expr -> . expr DIV_OP expr
    (33) expr -> . expr MOD_OP expr
    (34) expr -> . expr comb_op expr
    (35) expr -> . expr comp_op expr
    (17) func_call -> . IDENTIFIER LPAREN call_args RPAREN
    (18) func_call -> . IDENTIFIER LPAREN RPAREN
    (27) boolean -> . TRUE
    (28) boolean -> . FALSE

    IDENTIFIER      shift and go to state 33
    LPAREN          shift and go to state 20
    INTEGER         shift and go to state 7
    DOUBLE          shift and go to state 29
    TRUE            shift and go to state 8
    FALSE           shift and go to state 23

    func_call                      shift and go to state 22
    expr                           shift and go to state 69
    boolean                        shift and go to state 4

state 46

    (42) comp_op -> CGT .

    IDENTIFIER      reduce using rule 42 (comp_op -> CGT .)
    LPAREN          reduce using rule 42 (comp_op -> CGT .)
    INTEGER         reduce using rule 42 (comp_op -> CGT .)
    DOUBLE          reduce using rule 42 (comp_op -> CGT .)
    TRUE            reduce using rule 42 (comp_op -> CGT .)
    FALSE           reduce using rule 42 (comp_op -> CGT .)


state 47

    (43) comp_op -> CGE .

    IDENTIFIER      reduce using rule 43 (comp_op -> CGE .)
    LPAREN          reduce using rule 43 (comp_op -> CGE .)
    INTEGER         reduce using rule 43 (comp_op -> CGE .)
    DOUBLE          reduce using rule 43 (comp_op -> CGE .)
    TRUE            reduce using rule 43 (comp_op -> CGE .)
    FALSE           reduce using rule 43 (comp_op -> CGE .)


state 48

    (34) expr -> expr comb_op . expr
    (21) expr -> . IDENTIFIER
    (22) expr -> . LPAREN expr RPAREN
    (23) expr -> . func_call
    (24) expr -> . INTEGER
    (25) expr -> . DOUBLE
    (26) expr -> . boolean
    (29) expr -> . expr ADD_OP expr
    (30) expr -> . expr SUB_OP expr
    (31) expr -> . expr MUL_OP expr
    (32) expr -> . expr DIV_OP expr
    (33) expr -> . expr MOD_OP expr
    (34) expr -> . expr comb_op expr
    (35) expr -> . expr comp_op expr
    (17) func_call -> . IDENTIFIER LPAREN call_args RPAREN
    (18) func_call -> . IDENTIFIER LPAREN RPAREN
    (27) boolean -> . TRUE
    (28) boolean -> . FALSE

    IDENTIFIER      shift and go to state 33
    LPAREN          shift and go to state 20
    INTEGER         shift and go to state 7
    DOUBLE          shift and go to state 29
    TRUE            shift and go to state 8
    FALSE           shift and go to state 23

    func_call                      shift and go to state 22
    expr                           shift and go to state 70
    boolean                        shift and go to state 4

state 49

    (35) expr -> expr comp_op . expr
    (21) expr -> . IDENTIFIER
    (22) expr -> . LPAREN expr RPAREN
    (23) expr -> . func_call
    (24) expr -> . INTEGER
    (25) expr -> . DOUBLE
    (26) expr -> . boolean
    (29) expr -> . expr ADD_OP expr
    (30) expr -> . expr SUB_OP expr
    (31) expr -> . expr MUL_OP expr
    (32) expr -> . expr DIV_OP expr
    (33) expr -> . expr MOD_OP expr
    (34) expr -> . expr comb_op expr
    (35) expr -> . expr comp_op expr
    (17) func_call -> . IDENTIFIER LPAREN call_args RPAREN
    (18) func_call -> . IDENTIFIER LPAREN RPAREN
    (27) boolean -> . TRUE
    (28) boolean -> . FALSE

    IDENTIFIER      shift and go to state 33
    LPAREN          shift and go to state 20
    INTEGER         shift and go to state 7
    DOUBLE          shift and go to state 29
    TRUE            shift and go to state 8
    FALSE           shift and go to state 23

    func_call                      shift and go to state 22
    expr                           shift and go to state 71
    boolean                        shift and go to state 4

state 50

    (30) expr -> expr SUB_OP . expr
    (21) expr -> . IDENTIFIER
    (22) expr -> . LPAREN expr RPAREN
    (23) expr -> . func_call
    (24) expr -> . INTEGER
    (25) expr -> . DOUBLE
    (26) expr -> . boolean
    (29) expr -> . expr ADD_OP expr
    (30) expr -> . expr SUB_OP expr
    (31) expr -> . expr MUL_OP expr
    (32) expr -> . expr DIV_OP expr
    (33) expr -> . expr MOD_OP expr
    (34) expr -> . expr comb_op expr
    (35) expr -> . expr comp_op expr
    (17) func_call -> . IDENTIFIER LPAREN call_args RPAREN
    (18) func_call -> . IDENTIFIER LPAREN RPAREN
    (27) boolean -> . TRUE
    (28) boolean -> . FALSE

    IDENTIFIER      shift and go to state 33
    LPAREN          shift and go to state 20
    INTEGER         shift and go to state 7
    DOUBLE          shift and go to state 29
    TRUE            shift and go to state 8
    FALSE           shift and go to state 23

    func_call                      shift and go to state 22
    expr                           shift and go to state 72
    boolean                        shift and go to state 4

state 51

    (32) expr -> expr DIV_OP . expr
    (21) expr -> . IDENTIFIER
    (22) expr -> . LPAREN expr RPAREN
    (23) expr -> . func_call
    (24) expr -> . INTEGER
    (25) expr -> . DOUBLE
    (26) expr -> . boolean
    (29) expr -> . expr ADD_OP expr
    (30) expr -> . expr SUB_OP expr
    (31) expr -> . expr MUL_OP expr
    (32) expr -> . expr DIV_OP expr
    (33) expr -> . expr MOD_OP expr
    (34) expr -> . expr comb_op expr
    (35) expr -> . expr comp_op expr
    (17) func_call -> . IDENTIFIER LPAREN call_args RPAREN
    (18) func_call -> . IDENTIFIER LPAREN RPAREN
    (27) boolean -> . TRUE
    (28) boolean -> . FALSE

    IDENTIFIER      shift and go to state 33
    LPAREN          shift and go to state 20
    INTEGER         shift and go to state 7
    DOUBLE          shift and go to state 29
    TRUE            shift and go to state 8
    FALSE           shift and go to state 23

    func_call                      shift and go to state 22
    expr                           shift and go to state 73
    boolean                        shift and go to state 4

state 52

    (39) comp_op -> CNE .

    IDENTIFIER      reduce using rule 39 (comp_op -> CNE .)
    LPAREN          reduce using rule 39 (comp_op -> CNE .)
    INTEGER         reduce using rule 39 (comp_op -> CNE .)
    DOUBLE          reduce using rule 39 (comp_op -> CNE .)
    TRUE            reduce using rule 39 (comp_op -> CNE .)
    FALSE           reduce using rule 39 (comp_op -> CNE .)


state 53

    (38) comp_op -> CEQ .

    IDENTIFIER      reduce using rule 38 (comp_op -> CEQ .)
    LPAREN          reduce using rule 38 (comp_op -> CEQ .)
    INTEGER         reduce using rule 38 (comp_op -> CEQ .)
    DOUBLE          reduce using rule 38 (comp_op -> CEQ .)
    TRUE            reduce using rule 38 (comp_op -> CEQ .)
    FALSE           reduce using rule 38 (comp_op -> CEQ .)


state 54

    (29) expr -> expr ADD_OP . expr
    (21) expr -> . IDENTIFIER
    (22) expr -> . LPAREN expr RPAREN
    (23) expr -> . func_call
    (24) expr -> . INTEGER
    (25) expr -> . DOUBLE
    (26) expr -> . boolean
    (29) expr -> . expr ADD_OP expr
    (30) expr -> . expr SUB_OP expr
    (31) expr -> . expr MUL_OP expr
    (32) expr -> . expr DIV_OP expr
    (33) expr -> . expr MOD_OP expr
    (34) expr -> . expr comb_op expr
    (35) expr -> . expr comp_op expr
    (17) func_call -> . IDENTIFIER LPAREN call_args RPAREN
    (18) func_call -> . IDENTIFIER LPAREN RPAREN
    (27) boolean -> . TRUE
    (28) boolean -> . FALSE

    IDENTIFIER      shift and go to state 33
    LPAREN          shift and go to state 20
    INTEGER         shift and go to state 7
    DOUBLE          shift and go to state 29
    TRUE            shift and go to state 8
    FALSE           shift and go to state 23

    func_call                      shift and go to state 22
    expr                           shift and go to state 74
    boolean                        shift and go to state 4

state 55

    (40) comp_op -> CLT .

    IDENTIFIER      reduce using rule 40 (comp_op -> CLT .)
    LPAREN          reduce using rule 40 (comp_op -> CLT .)
    INTEGER         reduce using rule 40 (comp_op -> CLT .)
    DOUBLE          reduce using rule 40 (comp_op -> CLT .)
    TRUE            reduce using rule 40 (comp_op -> CLT .)
    FALSE           reduce using rule 40 (comp_op -> CLT .)


state 56

    (33) expr -> expr MOD_OP . expr
    (21) expr -> . IDENTIFIER
    (22) expr -> . LPAREN expr RPAREN
    (23) expr -> . func_call
    (24) expr -> . INTEGER
    (25) expr -> . DOUBLE
    (26) expr -> . boolean
    (29) expr -> . expr ADD_OP expr
    (30) expr -> . expr SUB_OP expr
    (31) expr -> . expr MUL_OP expr
    (32) expr -> . expr DIV_OP expr
    (33) expr -> . expr MOD_OP expr
    (34) expr -> . expr comb_op expr
    (35) expr -> . expr comp_op expr
    (17) func_call -> . IDENTIFIER LPAREN call_args RPAREN
    (18) func_call -> . IDENTIFIER LPAREN RPAREN
    (27) boolean -> . TRUE
    (28) boolean -> . FALSE

    IDENTIFIER      shift and go to state 33
    LPAREN          shift and go to state 20
    INTEGER         shift and go to state 7
    DOUBLE          shift and go to state 29
    TRUE            shift and go to state 8
    FALSE           shift and go to state 23

    func_call                      shift and go to state 22
    expr                           shift and go to state 75
    boolean                        shift and go to state 4

state 57

    (36) comb_op -> OR .

    IDENTIFIER      reduce using rule 36 (comb_op -> OR .)
    LPAREN          reduce using rule 36 (comb_op -> OR .)
    INTEGER         reduce using rule 36 (comb_op -> OR .)
    DOUBLE          reduce using rule 36 (comb_op -> OR .)
    TRUE            reduce using rule 36 (comb_op -> OR .)
    FALSE           reduce using rule 36 (comb_op -> OR .)


state 58

    (48) func_def -> FUNCTION head END_STATEMENT . body END END_STATEMENT
    (53) body -> . stmt
    (54) body -> . stmt body
    (3) stmt -> . simple_stmt
    (4) stmt -> . compound_stmt
    (5) simple_stmt -> . small_stmt END_STATEMENT
    (44) compound_stmt -> . func_def
    (45) compound_stmt -> . if_stmt
    (46) compound_stmt -> . while_stmt
    (47) compound_stmt -> . for_stmt
    (6) small_stmt -> . assignment
    (7) small_stmt -> . const_decl
    (8) small_stmt -> . expr
    (9) small_stmt -> . return_stmt
    (10) small_stmt -> . loop_stmt
    (48) func_def -> . FUNCTION head END_STATEMENT body END END_STATEMENT
    (58) if_stmt -> . IF expr COLON END_STATEMENT body END END_STATEMENT
    (59) if_stmt -> . IF expr COLON END_STATEMENT body END END_STATEMENT elseif_list
    (60) if_stmt -> . IF expr COLON END_STATEMENT body END END_STATEMENT elseif_list ELSE COLON END_STATEMENT body END END_STATEMENT
    (61) if_stmt -> . IF expr COLON END_STATEMENT body END END_STATEMENT ELSE COLON END_STATEMENT body END END_STATEMENT
    (55) while_stmt -> . WHILE expr COLON END_STATEMENT body END END_STATEMENT
    (56) for_stmt -> . FOR IDENTIFIER IN RANGE LPAREN expr COMMA expr RPAREN COLON END_STATEMENT body END END_STATEMENT
    (57) for_stmt -> . FOR IDENTIFIER IN IDENTIFIER COLON END_STATEMENT body END END_STATEMENT
    (15) assignment -> . IDENTIFIER ASSIGN expr
    (16) const_decl -> . IDENTIFIER CONST expr
    (21) expr -> . IDENTIFIER
    (22) expr -> . LPAREN expr RPAREN
    (23) expr -> . func_call
    (24) expr -> . INTEGER
    (25) expr -> . DOUBLE
    (26) expr -> . boolean
    (29) expr -> . expr ADD_OP expr
    (30) expr -> . expr SUB_OP expr
    (31) expr -> . expr MUL_OP expr
    (32) expr -> . expr DIV_OP expr
    (33) expr -> . expr MOD_OP expr
    (34) expr -> . expr comb_op expr
    (35) expr -> . expr comp_op expr
    (11) return_stmt -> . RETURN
    (12) return_stmt -> . RETURN expr
    (13) loop_stmt -> . BREAK
    (14) loop_stmt -> . CONTINUE
    (17) func_call -> . IDENTIFIER LPAREN call_args RPAREN
    (18) func_call -> . IDENTIFIER LPAREN RPAREN
    (27) boolean -> . TRUE
    (28) boolean -> . FALSE

    FUNCTION        shift and go to state 1
    IF              shift and go to state 21
    WHILE           shift and go to state 3
    FOR             shift and go to state 9
    IDENTIFIER      shift and go to state 12
    LPAREN          shift and go to state 20
    INTEGER         shift and go to state 7
    DOUBLE          shift and go to state 29
    RETURN          shift and go to state 6
    BREAK           shift and go to state 26
    CONTINUE        shift and go to state 28
    TRUE            shift and go to state 8
    FALSE           shift and go to state 23

    body                           shift and go to state 76
    func_call                      shift and go to state 22
    if_stmt                        shift and go to state 24
    func_def                       shift and go to state 14
    simple_stmt                    shift and go to state 15
    assignment                     shift and go to state 16
    for_stmt                       shift and go to state 18
    stmt                           shift and go to state 77
    small_stmt                     shift and go to state 2
    while_stmt                     shift and go to state 27
    boolean                        shift and go to state 4
    return_stmt                    shift and go to state 5
    loop_stmt                      shift and go to state 19
    expr                           shift and go to state 25
    const_decl                     shift and go to state 10
    compound_stmt                  shift and go to state 13

state 59

    (49) head -> IDENTIFIER LPAREN . func_def_args RPAREN COLON
    (50) head -> IDENTIFIER LPAREN . RPAREN COLON
    (51) func_def_args -> . IDENTIFIER
    (52) func_def_args -> . IDENTIFIER COMMA func_def_args

    RPAREN          shift and go to state 79
    IDENTIFIER      shift and go to state 80

    func_def_args                  shift and go to state 78

state 60

    (55) while_stmt -> WHILE expr COLON . END_STATEMENT body END END_STATEMENT

    END_STATEMENT   shift and go to state 81


state 61

    (56) for_stmt -> FOR IDENTIFIER IN . RANGE LPAREN expr COMMA expr RPAREN COLON END_STATEMENT body END END_STATEMENT
    (57) for_stmt -> FOR IDENTIFIER IN . IDENTIFIER COLON END_STATEMENT body END END_STATEMENT

    RANGE           shift and go to state 82
    IDENTIFIER      shift and go to state 83


state 62

    (16) const_decl -> IDENTIFIER CONST expr .
    (29) expr -> expr . ADD_OP expr
    (30) expr -> expr . SUB_OP expr
    (31) expr -> expr . MUL_OP expr
    (32) expr -> expr . DIV_OP expr
    (33) expr -> expr . MOD_OP expr
    (34) expr -> expr . comb_op expr
    (35) expr -> expr . comp_op expr
    (36) comb_op -> . OR
    (37) comb_op -> . AND
    (38) comp_op -> . CEQ
    (39) comp_op -> . CNE
    (40) comp_op -> . CLT
    (41) comp_op -> . CLE
    (42) comp_op -> . CGT
    (43) comp_op -> . CGE

    END_STATEMENT   reduce using rule 16 (const_decl -> IDENTIFIER CONST expr .)
    ADD_OP          shift and go to state 54
    SUB_OP          shift and go to state 50
    MUL_OP          shift and go to state 45
    DIV_OP          shift and go to state 51
    MOD_OP          shift and go to state 56
    OR              shift and go to state 57
    AND             shift and go to state 43
    CEQ             shift and go to state 53
    CNE             shift and go to state 52
    CLT             shift and go to state 55
    CLE             shift and go to state 44
    CGT             shift and go to state 46
    CGE             shift and go to state 47

    comp_op                        shift and go to state 49
    comb_op                        shift and go to state 48

state 63

    (18) func_call -> IDENTIFIER LPAREN RPAREN .

    ADD_OP          reduce using rule 18 (func_call -> IDENTIFIER LPAREN RPAREN .)
    SUB_OP          reduce using rule 18 (func_call -> IDENTIFIER LPAREN RPAREN .)
    MUL_OP          reduce using rule 18 (func_call -> IDENTIFIER LPAREN RPAREN .)
    DIV_OP          reduce using rule 18 (func_call -> IDENTIFIER LPAREN RPAREN .)
    MOD_OP          reduce using rule 18 (func_call -> IDENTIFIER LPAREN RPAREN .)
    OR              reduce using rule 18 (func_call -> IDENTIFIER LPAREN RPAREN .)
    AND             reduce using rule 18 (func_call -> IDENTIFIER LPAREN RPAREN .)
    CEQ             reduce using rule 18 (func_call -> IDENTIFIER LPAREN RPAREN .)
    CNE             reduce using rule 18 (func_call -> IDENTIFIER LPAREN RPAREN .)
    CLT             reduce using rule 18 (func_call -> IDENTIFIER LPAREN RPAREN .)
    CLE             reduce using rule 18 (func_call -> IDENTIFIER LPAREN RPAREN .)
    CGT             reduce using rule 18 (func_call -> IDENTIFIER LPAREN RPAREN .)
    CGE             reduce using rule 18 (func_call -> IDENTIFIER LPAREN RPAREN .)
    END_STATEMENT   reduce using rule 18 (func_call -> IDENTIFIER LPAREN RPAREN .)
    COLON           reduce using rule 18 (func_call -> IDENTIFIER LPAREN RPAREN .)
    RPAREN          reduce using rule 18 (func_call -> IDENTIFIER LPAREN RPAREN .)
    COMMA           reduce using rule 18 (func_call -> IDENTIFIER LPAREN RPAREN .)


state 64

    (19) call_args -> expr .
    (20) call_args -> expr . COMMA call_args
    (29) expr -> expr . ADD_OP expr
    (30) expr -> expr . SUB_OP expr
    (31) expr -> expr . MUL_OP expr
    (32) expr -> expr . DIV_OP expr
    (33) expr -> expr . MOD_OP expr
    (34) expr -> expr . comb_op expr
    (35) expr -> expr . comp_op expr
    (36) comb_op -> . OR
    (37) comb_op -> . AND
    (38) comp_op -> . CEQ
    (39) comp_op -> . CNE
    (40) comp_op -> . CLT
    (41) comp_op -> . CLE
    (42) comp_op -> . CGT
    (43) comp_op -> . CGE

    RPAREN          reduce using rule 19 (call_args -> expr .)
    COMMA           shift and go to state 84
    ADD_OP          shift and go to state 54
    SUB_OP          shift and go to state 50
    MUL_OP          shift and go to state 45
    DIV_OP          shift and go to state 51
    MOD_OP          shift and go to state 56
    OR              shift and go to state 57
    AND             shift and go to state 43
    CEQ             shift and go to state 53
    CNE             shift and go to state 52
    CLT             shift and go to state 55
    CLE             shift and go to state 44
    CGT             shift and go to state 46
    CGE             shift and go to state 47

    comp_op                        shift and go to state 49
    comb_op                        shift and go to state 48

state 65

    (17) func_call -> IDENTIFIER LPAREN call_args . RPAREN

    RPAREN          shift and go to state 85


state 66

    (15) assignment -> IDENTIFIER ASSIGN expr .
    (29) expr -> expr . ADD_OP expr
    (30) expr -> expr . SUB_OP expr
    (31) expr -> expr . MUL_OP expr
    (32) expr -> expr . DIV_OP expr
    (33) expr -> expr . MOD_OP expr
    (34) expr -> expr . comb_op expr
    (35) expr -> expr . comp_op expr
    (36) comb_op -> . OR
    (37) comb_op -> . AND
    (38) comp_op -> . CEQ
    (39) comp_op -> . CNE
    (40) comp_op -> . CLT
    (41) comp_op -> . CLE
    (42) comp_op -> . CGT
    (43) comp_op -> . CGE

    END_STATEMENT   reduce using rule 15 (assignment -> IDENTIFIER ASSIGN expr .)
    ADD_OP          shift and go to state 54
    SUB_OP          shift and go to state 50
    MUL_OP          shift and go to state 45
    DIV_OP          shift and go to state 51
    MOD_OP          shift and go to state 56
    OR              shift and go to state 57
    AND             shift and go to state 43
    CEQ             shift and go to state 53
    CNE             shift and go to state 52
    CLT             shift and go to state 55
    CLE             shift and go to state 44
    CGT             shift and go to state 46
    CGE             shift and go to state 47

    comp_op                        shift and go to state 49
    comb_op                        shift and go to state 48

state 67

    (22) expr -> LPAREN expr RPAREN .

    ADD_OP          reduce using rule 22 (expr -> LPAREN expr RPAREN .)
    SUB_OP          reduce using rule 22 (expr -> LPAREN expr RPAREN .)
    MUL_OP          reduce using rule 22 (expr -> LPAREN expr RPAREN .)
    DIV_OP          reduce using rule 22 (expr -> LPAREN expr RPAREN .)
    MOD_OP          reduce using rule 22 (expr -> LPAREN expr RPAREN .)
    OR              reduce using rule 22 (expr -> LPAREN expr RPAREN .)
    AND             reduce using rule 22 (expr -> LPAREN expr RPAREN .)
    CEQ             reduce using rule 22 (expr -> LPAREN expr RPAREN .)
    CNE             reduce using rule 22 (expr -> LPAREN expr RPAREN .)
    CLT             reduce using rule 22 (expr -> LPAREN expr RPAREN .)
    CLE             reduce using rule 22 (expr -> LPAREN expr RPAREN .)
    CGT             reduce using rule 22 (expr -> LPAREN expr RPAREN .)
    CGE             reduce using rule 22 (expr -> LPAREN expr RPAREN .)
    END_STATEMENT   reduce using rule 22 (expr -> LPAREN expr RPAREN .)
    COMMA           reduce using rule 22 (expr -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 22 (expr -> LPAREN expr RPAREN .)
    COLON           reduce using rule 22 (expr -> LPAREN expr RPAREN .)


state 68

    (58) if_stmt -> IF expr COLON . END_STATEMENT body END END_STATEMENT
    (59) if_stmt -> IF expr COLON . END_STATEMENT body END END_STATEMENT elseif_list
    (60) if_stmt -> IF expr COLON . END_STATEMENT body END END_STATEMENT elseif_list ELSE COLON END_STATEMENT body END END_STATEMENT
    (61) if_stmt -> IF expr COLON . END_STATEMENT body END END_STATEMENT ELSE COLON END_STATEMENT body END END_STATEMENT

    END_STATEMENT   shift and go to state 86


state 69

    (31) expr -> expr MUL_OP expr .
    (29) expr -> expr . ADD_OP expr
    (30) expr -> expr . SUB_OP expr
    (31) expr -> expr . MUL_OP expr
    (32) expr -> expr . DIV_OP expr
    (33) expr -> expr . MOD_OP expr
    (34) expr -> expr . comb_op expr
    (35) expr -> expr . comp_op expr
    (36) comb_op -> . OR
    (37) comb_op -> . AND
    (38) comp_op -> . CEQ
    (39) comp_op -> . CNE
    (40) comp_op -> . CLT
    (41) comp_op -> . CLE
    (42) comp_op -> . CGT
    (43) comp_op -> . CGE

    ADD_OP          reduce using rule 31 (expr -> expr MUL_OP expr .)
    SUB_OP          reduce using rule 31 (expr -> expr MUL_OP expr .)
    MUL_OP          reduce using rule 31 (expr -> expr MUL_OP expr .)
    DIV_OP          reduce using rule 31 (expr -> expr MUL_OP expr .)
    MOD_OP          reduce using rule 31 (expr -> expr MUL_OP expr .)
    OR              reduce using rule 31 (expr -> expr MUL_OP expr .)
    AND             reduce using rule 31 (expr -> expr MUL_OP expr .)
    CEQ             reduce using rule 31 (expr -> expr MUL_OP expr .)
    CNE             reduce using rule 31 (expr -> expr MUL_OP expr .)
    CLT             reduce using rule 31 (expr -> expr MUL_OP expr .)
    CLE             reduce using rule 31 (expr -> expr MUL_OP expr .)
    CGT             reduce using rule 31 (expr -> expr MUL_OP expr .)
    CGE             reduce using rule 31 (expr -> expr MUL_OP expr .)
    END_STATEMENT   reduce using rule 31 (expr -> expr MUL_OP expr .)
    COMMA           reduce using rule 31 (expr -> expr MUL_OP expr .)
    RPAREN          reduce using rule 31 (expr -> expr MUL_OP expr .)
    COLON           reduce using rule 31 (expr -> expr MUL_OP expr .)

  ! ADD_OP          [ shift and go to state 54 ]
  ! SUB_OP          [ shift and go to state 50 ]
  ! MUL_OP          [ shift and go to state 45 ]
  ! DIV_OP          [ shift and go to state 51 ]
  ! MOD_OP          [ shift and go to state 56 ]
  ! OR              [ shift and go to state 57 ]
  ! AND             [ shift and go to state 43 ]
  ! CEQ             [ shift and go to state 53 ]
  ! CNE             [ shift and go to state 52 ]
  ! CLT             [ shift and go to state 55 ]
  ! CLE             [ shift and go to state 44 ]
  ! CGT             [ shift and go to state 46 ]
  ! CGE             [ shift and go to state 47 ]

    comp_op                        shift and go to state 49
    comb_op                        shift and go to state 48

state 70

    (34) expr -> expr comb_op expr .
    (29) expr -> expr . ADD_OP expr
    (30) expr -> expr . SUB_OP expr
    (31) expr -> expr . MUL_OP expr
    (32) expr -> expr . DIV_OP expr
    (33) expr -> expr . MOD_OP expr
    (34) expr -> expr . comb_op expr
    (35) expr -> expr . comp_op expr
    (36) comb_op -> . OR
    (37) comb_op -> . AND
    (38) comp_op -> . CEQ
    (39) comp_op -> . CNE
    (40) comp_op -> . CLT
    (41) comp_op -> . CLE
    (42) comp_op -> . CGT
    (43) comp_op -> . CGE

  ! shift/reduce conflict for ADD_OP resolved as shift
  ! shift/reduce conflict for SUB_OP resolved as shift
  ! shift/reduce conflict for MUL_OP resolved as shift
  ! shift/reduce conflict for DIV_OP resolved as shift
  ! shift/reduce conflict for MOD_OP resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for CEQ resolved as shift
  ! shift/reduce conflict for CNE resolved as shift
  ! shift/reduce conflict for CLT resolved as shift
  ! shift/reduce conflict for CLE resolved as shift
  ! shift/reduce conflict for CGT resolved as shift
  ! shift/reduce conflict for CGE resolved as shift
    END_STATEMENT   reduce using rule 34 (expr -> expr comb_op expr .)
    COMMA           reduce using rule 34 (expr -> expr comb_op expr .)
    RPAREN          reduce using rule 34 (expr -> expr comb_op expr .)
    COLON           reduce using rule 34 (expr -> expr comb_op expr .)
    ADD_OP          shift and go to state 54
    SUB_OP          shift and go to state 50
    MUL_OP          shift and go to state 45
    DIV_OP          shift and go to state 51
    MOD_OP          shift and go to state 56
    OR              shift and go to state 57
    AND             shift and go to state 43
    CEQ             shift and go to state 53
    CNE             shift and go to state 52
    CLT             shift and go to state 55
    CLE             shift and go to state 44
    CGT             shift and go to state 46
    CGE             shift and go to state 47

  ! ADD_OP          [ reduce using rule 34 (expr -> expr comb_op expr .) ]
  ! SUB_OP          [ reduce using rule 34 (expr -> expr comb_op expr .) ]
  ! MUL_OP          [ reduce using rule 34 (expr -> expr comb_op expr .) ]
  ! DIV_OP          [ reduce using rule 34 (expr -> expr comb_op expr .) ]
  ! MOD_OP          [ reduce using rule 34 (expr -> expr comb_op expr .) ]
  ! OR              [ reduce using rule 34 (expr -> expr comb_op expr .) ]
  ! AND             [ reduce using rule 34 (expr -> expr comb_op expr .) ]
  ! CEQ             [ reduce using rule 34 (expr -> expr comb_op expr .) ]
  ! CNE             [ reduce using rule 34 (expr -> expr comb_op expr .) ]
  ! CLT             [ reduce using rule 34 (expr -> expr comb_op expr .) ]
  ! CLE             [ reduce using rule 34 (expr -> expr comb_op expr .) ]
  ! CGT             [ reduce using rule 34 (expr -> expr comb_op expr .) ]
  ! CGE             [ reduce using rule 34 (expr -> expr comb_op expr .) ]

    comp_op                        shift and go to state 49
    comb_op                        shift and go to state 48

state 71

    (35) expr -> expr comp_op expr .
    (29) expr -> expr . ADD_OP expr
    (30) expr -> expr . SUB_OP expr
    (31) expr -> expr . MUL_OP expr
    (32) expr -> expr . DIV_OP expr
    (33) expr -> expr . MOD_OP expr
    (34) expr -> expr . comb_op expr
    (35) expr -> expr . comp_op expr
    (36) comb_op -> . OR
    (37) comb_op -> . AND
    (38) comp_op -> . CEQ
    (39) comp_op -> . CNE
    (40) comp_op -> . CLT
    (41) comp_op -> . CLE
    (42) comp_op -> . CGT
    (43) comp_op -> . CGE

  ! shift/reduce conflict for ADD_OP resolved as shift
  ! shift/reduce conflict for SUB_OP resolved as shift
  ! shift/reduce conflict for MUL_OP resolved as shift
  ! shift/reduce conflict for DIV_OP resolved as shift
  ! shift/reduce conflict for MOD_OP resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for CEQ resolved as shift
  ! shift/reduce conflict for CNE resolved as shift
  ! shift/reduce conflict for CLT resolved as shift
  ! shift/reduce conflict for CLE resolved as shift
  ! shift/reduce conflict for CGT resolved as shift
  ! shift/reduce conflict for CGE resolved as shift
    END_STATEMENT   reduce using rule 35 (expr -> expr comp_op expr .)
    COMMA           reduce using rule 35 (expr -> expr comp_op expr .)
    RPAREN          reduce using rule 35 (expr -> expr comp_op expr .)
    COLON           reduce using rule 35 (expr -> expr comp_op expr .)
    ADD_OP          shift and go to state 54
    SUB_OP          shift and go to state 50
    MUL_OP          shift and go to state 45
    DIV_OP          shift and go to state 51
    MOD_OP          shift and go to state 56
    OR              shift and go to state 57
    AND             shift and go to state 43
    CEQ             shift and go to state 53
    CNE             shift and go to state 52
    CLT             shift and go to state 55
    CLE             shift and go to state 44
    CGT             shift and go to state 46
    CGE             shift and go to state 47

  ! ADD_OP          [ reduce using rule 35 (expr -> expr comp_op expr .) ]
  ! SUB_OP          [ reduce using rule 35 (expr -> expr comp_op expr .) ]
  ! MUL_OP          [ reduce using rule 35 (expr -> expr comp_op expr .) ]
  ! DIV_OP          [ reduce using rule 35 (expr -> expr comp_op expr .) ]
  ! MOD_OP          [ reduce using rule 35 (expr -> expr comp_op expr .) ]
  ! OR              [ reduce using rule 35 (expr -> expr comp_op expr .) ]
  ! AND             [ reduce using rule 35 (expr -> expr comp_op expr .) ]
  ! CEQ             [ reduce using rule 35 (expr -> expr comp_op expr .) ]
  ! CNE             [ reduce using rule 35 (expr -> expr comp_op expr .) ]
  ! CLT             [ reduce using rule 35 (expr -> expr comp_op expr .) ]
  ! CLE             [ reduce using rule 35 (expr -> expr comp_op expr .) ]
  ! CGT             [ reduce using rule 35 (expr -> expr comp_op expr .) ]
  ! CGE             [ reduce using rule 35 (expr -> expr comp_op expr .) ]

    comp_op                        shift and go to state 49
    comb_op                        shift and go to state 48

state 72

    (30) expr -> expr SUB_OP expr .
    (29) expr -> expr . ADD_OP expr
    (30) expr -> expr . SUB_OP expr
    (31) expr -> expr . MUL_OP expr
    (32) expr -> expr . DIV_OP expr
    (33) expr -> expr . MOD_OP expr
    (34) expr -> expr . comb_op expr
    (35) expr -> expr . comp_op expr
    (36) comb_op -> . OR
    (37) comb_op -> . AND
    (38) comp_op -> . CEQ
    (39) comp_op -> . CNE
    (40) comp_op -> . CLT
    (41) comp_op -> . CLE
    (42) comp_op -> . CGT
    (43) comp_op -> . CGE

    ADD_OP          reduce using rule 30 (expr -> expr SUB_OP expr .)
    SUB_OP          reduce using rule 30 (expr -> expr SUB_OP expr .)
    OR              reduce using rule 30 (expr -> expr SUB_OP expr .)
    AND             reduce using rule 30 (expr -> expr SUB_OP expr .)
    CEQ             reduce using rule 30 (expr -> expr SUB_OP expr .)
    CNE             reduce using rule 30 (expr -> expr SUB_OP expr .)
    CLT             reduce using rule 30 (expr -> expr SUB_OP expr .)
    CLE             reduce using rule 30 (expr -> expr SUB_OP expr .)
    CGT             reduce using rule 30 (expr -> expr SUB_OP expr .)
    CGE             reduce using rule 30 (expr -> expr SUB_OP expr .)
    END_STATEMENT   reduce using rule 30 (expr -> expr SUB_OP expr .)
    COMMA           reduce using rule 30 (expr -> expr SUB_OP expr .)
    RPAREN          reduce using rule 30 (expr -> expr SUB_OP expr .)
    COLON           reduce using rule 30 (expr -> expr SUB_OP expr .)
    MUL_OP          shift and go to state 45
    DIV_OP          shift and go to state 51
    MOD_OP          shift and go to state 56

  ! MUL_OP          [ reduce using rule 30 (expr -> expr SUB_OP expr .) ]
  ! DIV_OP          [ reduce using rule 30 (expr -> expr SUB_OP expr .) ]
  ! MOD_OP          [ reduce using rule 30 (expr -> expr SUB_OP expr .) ]
  ! ADD_OP          [ shift and go to state 54 ]
  ! SUB_OP          [ shift and go to state 50 ]
  ! OR              [ shift and go to state 57 ]
  ! AND             [ shift and go to state 43 ]
  ! CEQ             [ shift and go to state 53 ]
  ! CNE             [ shift and go to state 52 ]
  ! CLT             [ shift and go to state 55 ]
  ! CLE             [ shift and go to state 44 ]
  ! CGT             [ shift and go to state 46 ]
  ! CGE             [ shift and go to state 47 ]

    comp_op                        shift and go to state 49
    comb_op                        shift and go to state 48

state 73

    (32) expr -> expr DIV_OP expr .
    (29) expr -> expr . ADD_OP expr
    (30) expr -> expr . SUB_OP expr
    (31) expr -> expr . MUL_OP expr
    (32) expr -> expr . DIV_OP expr
    (33) expr -> expr . MOD_OP expr
    (34) expr -> expr . comb_op expr
    (35) expr -> expr . comp_op expr
    (36) comb_op -> . OR
    (37) comb_op -> . AND
    (38) comp_op -> . CEQ
    (39) comp_op -> . CNE
    (40) comp_op -> . CLT
    (41) comp_op -> . CLE
    (42) comp_op -> . CGT
    (43) comp_op -> . CGE

    ADD_OP          reduce using rule 32 (expr -> expr DIV_OP expr .)
    SUB_OP          reduce using rule 32 (expr -> expr DIV_OP expr .)
    MUL_OP          reduce using rule 32 (expr -> expr DIV_OP expr .)
    DIV_OP          reduce using rule 32 (expr -> expr DIV_OP expr .)
    MOD_OP          reduce using rule 32 (expr -> expr DIV_OP expr .)
    OR              reduce using rule 32 (expr -> expr DIV_OP expr .)
    AND             reduce using rule 32 (expr -> expr DIV_OP expr .)
    CEQ             reduce using rule 32 (expr -> expr DIV_OP expr .)
    CNE             reduce using rule 32 (expr -> expr DIV_OP expr .)
    CLT             reduce using rule 32 (expr -> expr DIV_OP expr .)
    CLE             reduce using rule 32 (expr -> expr DIV_OP expr .)
    CGT             reduce using rule 32 (expr -> expr DIV_OP expr .)
    CGE             reduce using rule 32 (expr -> expr DIV_OP expr .)
    END_STATEMENT   reduce using rule 32 (expr -> expr DIV_OP expr .)
    COMMA           reduce using rule 32 (expr -> expr DIV_OP expr .)
    RPAREN          reduce using rule 32 (expr -> expr DIV_OP expr .)
    COLON           reduce using rule 32 (expr -> expr DIV_OP expr .)

  ! ADD_OP          [ shift and go to state 54 ]
  ! SUB_OP          [ shift and go to state 50 ]
  ! MUL_OP          [ shift and go to state 45 ]
  ! DIV_OP          [ shift and go to state 51 ]
  ! MOD_OP          [ shift and go to state 56 ]
  ! OR              [ shift and go to state 57 ]
  ! AND             [ shift and go to state 43 ]
  ! CEQ             [ shift and go to state 53 ]
  ! CNE             [ shift and go to state 52 ]
  ! CLT             [ shift and go to state 55 ]
  ! CLE             [ shift and go to state 44 ]
  ! CGT             [ shift and go to state 46 ]
  ! CGE             [ shift and go to state 47 ]

    comp_op                        shift and go to state 49
    comb_op                        shift and go to state 48

state 74

    (29) expr -> expr ADD_OP expr .
    (29) expr -> expr . ADD_OP expr
    (30) expr -> expr . SUB_OP expr
    (31) expr -> expr . MUL_OP expr
    (32) expr -> expr . DIV_OP expr
    (33) expr -> expr . MOD_OP expr
    (34) expr -> expr . comb_op expr
    (35) expr -> expr . comp_op expr
    (36) comb_op -> . OR
    (37) comb_op -> . AND
    (38) comp_op -> . CEQ
    (39) comp_op -> . CNE
    (40) comp_op -> . CLT
    (41) comp_op -> . CLE
    (42) comp_op -> . CGT
    (43) comp_op -> . CGE

    ADD_OP          reduce using rule 29 (expr -> expr ADD_OP expr .)
    SUB_OP          reduce using rule 29 (expr -> expr ADD_OP expr .)
    OR              reduce using rule 29 (expr -> expr ADD_OP expr .)
    AND             reduce using rule 29 (expr -> expr ADD_OP expr .)
    CEQ             reduce using rule 29 (expr -> expr ADD_OP expr .)
    CNE             reduce using rule 29 (expr -> expr ADD_OP expr .)
    CLT             reduce using rule 29 (expr -> expr ADD_OP expr .)
    CLE             reduce using rule 29 (expr -> expr ADD_OP expr .)
    CGT             reduce using rule 29 (expr -> expr ADD_OP expr .)
    CGE             reduce using rule 29 (expr -> expr ADD_OP expr .)
    END_STATEMENT   reduce using rule 29 (expr -> expr ADD_OP expr .)
    COMMA           reduce using rule 29 (expr -> expr ADD_OP expr .)
    RPAREN          reduce using rule 29 (expr -> expr ADD_OP expr .)
    COLON           reduce using rule 29 (expr -> expr ADD_OP expr .)
    MUL_OP          shift and go to state 45
    DIV_OP          shift and go to state 51
    MOD_OP          shift and go to state 56

  ! MUL_OP          [ reduce using rule 29 (expr -> expr ADD_OP expr .) ]
  ! DIV_OP          [ reduce using rule 29 (expr -> expr ADD_OP expr .) ]
  ! MOD_OP          [ reduce using rule 29 (expr -> expr ADD_OP expr .) ]
  ! ADD_OP          [ shift and go to state 54 ]
  ! SUB_OP          [ shift and go to state 50 ]
  ! OR              [ shift and go to state 57 ]
  ! AND             [ shift and go to state 43 ]
  ! CEQ             [ shift and go to state 53 ]
  ! CNE             [ shift and go to state 52 ]
  ! CLT             [ shift and go to state 55 ]
  ! CLE             [ shift and go to state 44 ]
  ! CGT             [ shift and go to state 46 ]
  ! CGE             [ shift and go to state 47 ]

    comp_op                        shift and go to state 49
    comb_op                        shift and go to state 48

state 75

    (33) expr -> expr MOD_OP expr .
    (29) expr -> expr . ADD_OP expr
    (30) expr -> expr . SUB_OP expr
    (31) expr -> expr . MUL_OP expr
    (32) expr -> expr . DIV_OP expr
    (33) expr -> expr . MOD_OP expr
    (34) expr -> expr . comb_op expr
    (35) expr -> expr . comp_op expr
    (36) comb_op -> . OR
    (37) comb_op -> . AND
    (38) comp_op -> . CEQ
    (39) comp_op -> . CNE
    (40) comp_op -> . CLT
    (41) comp_op -> . CLE
    (42) comp_op -> . CGT
    (43) comp_op -> . CGE

    ADD_OP          reduce using rule 33 (expr -> expr MOD_OP expr .)
    SUB_OP          reduce using rule 33 (expr -> expr MOD_OP expr .)
    MUL_OP          reduce using rule 33 (expr -> expr MOD_OP expr .)
    DIV_OP          reduce using rule 33 (expr -> expr MOD_OP expr .)
    MOD_OP          reduce using rule 33 (expr -> expr MOD_OP expr .)
    OR              reduce using rule 33 (expr -> expr MOD_OP expr .)
    AND             reduce using rule 33 (expr -> expr MOD_OP expr .)
    CEQ             reduce using rule 33 (expr -> expr MOD_OP expr .)
    CNE             reduce using rule 33 (expr -> expr MOD_OP expr .)
    CLT             reduce using rule 33 (expr -> expr MOD_OP expr .)
    CLE             reduce using rule 33 (expr -> expr MOD_OP expr .)
    CGT             reduce using rule 33 (expr -> expr MOD_OP expr .)
    CGE             reduce using rule 33 (expr -> expr MOD_OP expr .)
    END_STATEMENT   reduce using rule 33 (expr -> expr MOD_OP expr .)
    COMMA           reduce using rule 33 (expr -> expr MOD_OP expr .)
    RPAREN          reduce using rule 33 (expr -> expr MOD_OP expr .)
    COLON           reduce using rule 33 (expr -> expr MOD_OP expr .)

  ! ADD_OP          [ shift and go to state 54 ]
  ! SUB_OP          [ shift and go to state 50 ]
  ! MUL_OP          [ shift and go to state 45 ]
  ! DIV_OP          [ shift and go to state 51 ]
  ! MOD_OP          [ shift and go to state 56 ]
  ! OR              [ shift and go to state 57 ]
  ! AND             [ shift and go to state 43 ]
  ! CEQ             [ shift and go to state 53 ]
  ! CNE             [ shift and go to state 52 ]
  ! CLT             [ shift and go to state 55 ]
  ! CLE             [ shift and go to state 44 ]
  ! CGT             [ shift and go to state 46 ]
  ! CGE             [ shift and go to state 47 ]

    comp_op                        shift and go to state 49
    comb_op                        shift and go to state 48

state 76

    (48) func_def -> FUNCTION head END_STATEMENT body . END END_STATEMENT

    END             shift and go to state 87


state 77

    (53) body -> stmt .
    (54) body -> stmt . body
    (53) body -> . stmt
    (54) body -> . stmt body
    (3) stmt -> . simple_stmt
    (4) stmt -> . compound_stmt
    (5) simple_stmt -> . small_stmt END_STATEMENT
    (44) compound_stmt -> . func_def
    (45) compound_stmt -> . if_stmt
    (46) compound_stmt -> . while_stmt
    (47) compound_stmt -> . for_stmt
    (6) small_stmt -> . assignment
    (7) small_stmt -> . const_decl
    (8) small_stmt -> . expr
    (9) small_stmt -> . return_stmt
    (10) small_stmt -> . loop_stmt
    (48) func_def -> . FUNCTION head END_STATEMENT body END END_STATEMENT
    (58) if_stmt -> . IF expr COLON END_STATEMENT body END END_STATEMENT
    (59) if_stmt -> . IF expr COLON END_STATEMENT body END END_STATEMENT elseif_list
    (60) if_stmt -> . IF expr COLON END_STATEMENT body END END_STATEMENT elseif_list ELSE COLON END_STATEMENT body END END_STATEMENT
    (61) if_stmt -> . IF expr COLON END_STATEMENT body END END_STATEMENT ELSE COLON END_STATEMENT body END END_STATEMENT
    (55) while_stmt -> . WHILE expr COLON END_STATEMENT body END END_STATEMENT
    (56) for_stmt -> . FOR IDENTIFIER IN RANGE LPAREN expr COMMA expr RPAREN COLON END_STATEMENT body END END_STATEMENT
    (57) for_stmt -> . FOR IDENTIFIER IN IDENTIFIER COLON END_STATEMENT body END END_STATEMENT
    (15) assignment -> . IDENTIFIER ASSIGN expr
    (16) const_decl -> . IDENTIFIER CONST expr
    (21) expr -> . IDENTIFIER
    (22) expr -> . LPAREN expr RPAREN
    (23) expr -> . func_call
    (24) expr -> . INTEGER
    (25) expr -> . DOUBLE
    (26) expr -> . boolean
    (29) expr -> . expr ADD_OP expr
    (30) expr -> . expr SUB_OP expr
    (31) expr -> . expr MUL_OP expr
    (32) expr -> . expr DIV_OP expr
    (33) expr -> . expr MOD_OP expr
    (34) expr -> . expr comb_op expr
    (35) expr -> . expr comp_op expr
    (11) return_stmt -> . RETURN
    (12) return_stmt -> . RETURN expr
    (13) loop_stmt -> . BREAK
    (14) loop_stmt -> . CONTINUE
    (17) func_call -> . IDENTIFIER LPAREN call_args RPAREN
    (18) func_call -> . IDENTIFIER LPAREN RPAREN
    (27) boolean -> . TRUE
    (28) boolean -> . FALSE

    END             reduce using rule 53 (body -> stmt .)
    FUNCTION        shift and go to state 1
    IF              shift and go to state 21
    WHILE           shift and go to state 3
    FOR             shift and go to state 9
    IDENTIFIER      shift and go to state 12
    LPAREN          shift and go to state 20
    INTEGER         shift and go to state 7
    DOUBLE          shift and go to state 29
    RETURN          shift and go to state 6
    BREAK           shift and go to state 26
    CONTINUE        shift and go to state 28
    TRUE            shift and go to state 8
    FALSE           shift and go to state 23

    body                           shift and go to state 88
    func_call                      shift and go to state 22
    if_stmt                        shift and go to state 24
    func_def                       shift and go to state 14
    simple_stmt                    shift and go to state 15
    assignment                     shift and go to state 16
    for_stmt                       shift and go to state 18
    stmt                           shift and go to state 77
    small_stmt                     shift and go to state 2
    while_stmt                     shift and go to state 27
    boolean                        shift and go to state 4
    return_stmt                    shift and go to state 5
    loop_stmt                      shift and go to state 19
    expr                           shift and go to state 25
    const_decl                     shift and go to state 10
    compound_stmt                  shift and go to state 13

state 78

    (49) head -> IDENTIFIER LPAREN func_def_args . RPAREN COLON

    RPAREN          shift and go to state 89


state 79

    (50) head -> IDENTIFIER LPAREN RPAREN . COLON

    COLON           shift and go to state 90


state 80

    (51) func_def_args -> IDENTIFIER .
    (52) func_def_args -> IDENTIFIER . COMMA func_def_args

    RPAREN          reduce using rule 51 (func_def_args -> IDENTIFIER .)
    COMMA           shift and go to state 91


state 81

    (55) while_stmt -> WHILE expr COLON END_STATEMENT . body END END_STATEMENT
    (53) body -> . stmt
    (54) body -> . stmt body
    (3) stmt -> . simple_stmt
    (4) stmt -> . compound_stmt
    (5) simple_stmt -> . small_stmt END_STATEMENT
    (44) compound_stmt -> . func_def
    (45) compound_stmt -> . if_stmt
    (46) compound_stmt -> . while_stmt
    (47) compound_stmt -> . for_stmt
    (6) small_stmt -> . assignment
    (7) small_stmt -> . const_decl
    (8) small_stmt -> . expr
    (9) small_stmt -> . return_stmt
    (10) small_stmt -> . loop_stmt
    (48) func_def -> . FUNCTION head END_STATEMENT body END END_STATEMENT
    (58) if_stmt -> . IF expr COLON END_STATEMENT body END END_STATEMENT
    (59) if_stmt -> . IF expr COLON END_STATEMENT body END END_STATEMENT elseif_list
    (60) if_stmt -> . IF expr COLON END_STATEMENT body END END_STATEMENT elseif_list ELSE COLON END_STATEMENT body END END_STATEMENT
    (61) if_stmt -> . IF expr COLON END_STATEMENT body END END_STATEMENT ELSE COLON END_STATEMENT body END END_STATEMENT
    (55) while_stmt -> . WHILE expr COLON END_STATEMENT body END END_STATEMENT
    (56) for_stmt -> . FOR IDENTIFIER IN RANGE LPAREN expr COMMA expr RPAREN COLON END_STATEMENT body END END_STATEMENT
    (57) for_stmt -> . FOR IDENTIFIER IN IDENTIFIER COLON END_STATEMENT body END END_STATEMENT
    (15) assignment -> . IDENTIFIER ASSIGN expr
    (16) const_decl -> . IDENTIFIER CONST expr
    (21) expr -> . IDENTIFIER
    (22) expr -> . LPAREN expr RPAREN
    (23) expr -> . func_call
    (24) expr -> . INTEGER
    (25) expr -> . DOUBLE
    (26) expr -> . boolean
    (29) expr -> . expr ADD_OP expr
    (30) expr -> . expr SUB_OP expr
    (31) expr -> . expr MUL_OP expr
    (32) expr -> . expr DIV_OP expr
    (33) expr -> . expr MOD_OP expr
    (34) expr -> . expr comb_op expr
    (35) expr -> . expr comp_op expr
    (11) return_stmt -> . RETURN
    (12) return_stmt -> . RETURN expr
    (13) loop_stmt -> . BREAK
    (14) loop_stmt -> . CONTINUE
    (17) func_call -> . IDENTIFIER LPAREN call_args RPAREN
    (18) func_call -> . IDENTIFIER LPAREN RPAREN
    (27) boolean -> . TRUE
    (28) boolean -> . FALSE

    FUNCTION        shift and go to state 1
    IF              shift and go to state 21
    WHILE           shift and go to state 3
    FOR             shift and go to state 9
    IDENTIFIER      shift and go to state 12
    LPAREN          shift and go to state 20
    INTEGER         shift and go to state 7
    DOUBLE          shift and go to state 29
    RETURN          shift and go to state 6
    BREAK           shift and go to state 26
    CONTINUE        shift and go to state 28
    TRUE            shift and go to state 8
    FALSE           shift and go to state 23

    body                           shift and go to state 92
    func_call                      shift and go to state 22
    if_stmt                        shift and go to state 24
    func_def                       shift and go to state 14
    simple_stmt                    shift and go to state 15
    expr                           shift and go to state 25
    for_stmt                       shift and go to state 18
    stmt                           shift and go to state 77
    small_stmt                     shift and go to state 2
    while_stmt                     shift and go to state 27
    boolean                        shift and go to state 4
    return_stmt                    shift and go to state 5
    loop_stmt                      shift and go to state 19
    assignment                     shift and go to state 16
    const_decl                     shift and go to state 10
    compound_stmt                  shift and go to state 13

state 82

    (56) for_stmt -> FOR IDENTIFIER IN RANGE . LPAREN expr COMMA expr RPAREN COLON END_STATEMENT body END END_STATEMENT

    LPAREN          shift and go to state 93


state 83

    (57) for_stmt -> FOR IDENTIFIER IN IDENTIFIER . COLON END_STATEMENT body END END_STATEMENT

    COLON           shift and go to state 94


state 84

    (20) call_args -> expr COMMA . call_args
    (19) call_args -> . expr
    (20) call_args -> . expr COMMA call_args
    (21) expr -> . IDENTIFIER
    (22) expr -> . LPAREN expr RPAREN
    (23) expr -> . func_call
    (24) expr -> . INTEGER
    (25) expr -> . DOUBLE
    (26) expr -> . boolean
    (29) expr -> . expr ADD_OP expr
    (30) expr -> . expr SUB_OP expr
    (31) expr -> . expr MUL_OP expr
    (32) expr -> . expr DIV_OP expr
    (33) expr -> . expr MOD_OP expr
    (34) expr -> . expr comb_op expr
    (35) expr -> . expr comp_op expr
    (17) func_call -> . IDENTIFIER LPAREN call_args RPAREN
    (18) func_call -> . IDENTIFIER LPAREN RPAREN
    (27) boolean -> . TRUE
    (28) boolean -> . FALSE

    IDENTIFIER      shift and go to state 33
    LPAREN          shift and go to state 20
    INTEGER         shift and go to state 7
    DOUBLE          shift and go to state 29
    TRUE            shift and go to state 8
    FALSE           shift and go to state 23

    func_call                      shift and go to state 22
    expr                           shift and go to state 64
    boolean                        shift and go to state 4
    call_args                      shift and go to state 95

state 85

    (17) func_call -> IDENTIFIER LPAREN call_args RPAREN .

    ADD_OP          reduce using rule 17 (func_call -> IDENTIFIER LPAREN call_args RPAREN .)
    SUB_OP          reduce using rule 17 (func_call -> IDENTIFIER LPAREN call_args RPAREN .)
    MUL_OP          reduce using rule 17 (func_call -> IDENTIFIER LPAREN call_args RPAREN .)
    DIV_OP          reduce using rule 17 (func_call -> IDENTIFIER LPAREN call_args RPAREN .)
    MOD_OP          reduce using rule 17 (func_call -> IDENTIFIER LPAREN call_args RPAREN .)
    OR              reduce using rule 17 (func_call -> IDENTIFIER LPAREN call_args RPAREN .)
    AND             reduce using rule 17 (func_call -> IDENTIFIER LPAREN call_args RPAREN .)
    CEQ             reduce using rule 17 (func_call -> IDENTIFIER LPAREN call_args RPAREN .)
    CNE             reduce using rule 17 (func_call -> IDENTIFIER LPAREN call_args RPAREN .)
    CLT             reduce using rule 17 (func_call -> IDENTIFIER LPAREN call_args RPAREN .)
    CLE             reduce using rule 17 (func_call -> IDENTIFIER LPAREN call_args RPAREN .)
    CGT             reduce using rule 17 (func_call -> IDENTIFIER LPAREN call_args RPAREN .)
    CGE             reduce using rule 17 (func_call -> IDENTIFIER LPAREN call_args RPAREN .)
    END_STATEMENT   reduce using rule 17 (func_call -> IDENTIFIER LPAREN call_args RPAREN .)
    COLON           reduce using rule 17 (func_call -> IDENTIFIER LPAREN call_args RPAREN .)
    RPAREN          reduce using rule 17 (func_call -> IDENTIFIER LPAREN call_args RPAREN .)
    COMMA           reduce using rule 17 (func_call -> IDENTIFIER LPAREN call_args RPAREN .)


state 86

    (58) if_stmt -> IF expr COLON END_STATEMENT . body END END_STATEMENT
    (59) if_stmt -> IF expr COLON END_STATEMENT . body END END_STATEMENT elseif_list
    (60) if_stmt -> IF expr COLON END_STATEMENT . body END END_STATEMENT elseif_list ELSE COLON END_STATEMENT body END END_STATEMENT
    (61) if_stmt -> IF expr COLON END_STATEMENT . body END END_STATEMENT ELSE COLON END_STATEMENT body END END_STATEMENT
    (53) body -> . stmt
    (54) body -> . stmt body
    (3) stmt -> . simple_stmt
    (4) stmt -> . compound_stmt
    (5) simple_stmt -> . small_stmt END_STATEMENT
    (44) compound_stmt -> . func_def
    (45) compound_stmt -> . if_stmt
    (46) compound_stmt -> . while_stmt
    (47) compound_stmt -> . for_stmt
    (6) small_stmt -> . assignment
    (7) small_stmt -> . const_decl
    (8) small_stmt -> . expr
    (9) small_stmt -> . return_stmt
    (10) small_stmt -> . loop_stmt
    (48) func_def -> . FUNCTION head END_STATEMENT body END END_STATEMENT
    (58) if_stmt -> . IF expr COLON END_STATEMENT body END END_STATEMENT
    (59) if_stmt -> . IF expr COLON END_STATEMENT body END END_STATEMENT elseif_list
    (60) if_stmt -> . IF expr COLON END_STATEMENT body END END_STATEMENT elseif_list ELSE COLON END_STATEMENT body END END_STATEMENT
    (61) if_stmt -> . IF expr COLON END_STATEMENT body END END_STATEMENT ELSE COLON END_STATEMENT body END END_STATEMENT
    (55) while_stmt -> . WHILE expr COLON END_STATEMENT body END END_STATEMENT
    (56) for_stmt -> . FOR IDENTIFIER IN RANGE LPAREN expr COMMA expr RPAREN COLON END_STATEMENT body END END_STATEMENT
    (57) for_stmt -> . FOR IDENTIFIER IN IDENTIFIER COLON END_STATEMENT body END END_STATEMENT
    (15) assignment -> . IDENTIFIER ASSIGN expr
    (16) const_decl -> . IDENTIFIER CONST expr
    (21) expr -> . IDENTIFIER
    (22) expr -> . LPAREN expr RPAREN
    (23) expr -> . func_call
    (24) expr -> . INTEGER
    (25) expr -> . DOUBLE
    (26) expr -> . boolean
    (29) expr -> . expr ADD_OP expr
    (30) expr -> . expr SUB_OP expr
    (31) expr -> . expr MUL_OP expr
    (32) expr -> . expr DIV_OP expr
    (33) expr -> . expr MOD_OP expr
    (34) expr -> . expr comb_op expr
    (35) expr -> . expr comp_op expr
    (11) return_stmt -> . RETURN
    (12) return_stmt -> . RETURN expr
    (13) loop_stmt -> . BREAK
    (14) loop_stmt -> . CONTINUE
    (17) func_call -> . IDENTIFIER LPAREN call_args RPAREN
    (18) func_call -> . IDENTIFIER LPAREN RPAREN
    (27) boolean -> . TRUE
    (28) boolean -> . FALSE

    FUNCTION        shift and go to state 1
    IF              shift and go to state 21
    WHILE           shift and go to state 3
    FOR             shift and go to state 9
    IDENTIFIER      shift and go to state 12
    LPAREN          shift and go to state 20
    INTEGER         shift and go to state 7
    DOUBLE          shift and go to state 29
    RETURN          shift and go to state 6
    BREAK           shift and go to state 26
    CONTINUE        shift and go to state 28
    TRUE            shift and go to state 8
    FALSE           shift and go to state 23

    body                           shift and go to state 96
    func_call                      shift and go to state 22
    func_def                       shift and go to state 14
    simple_stmt                    shift and go to state 15
    expr                           shift and go to state 25
    for_stmt                       shift and go to state 18
    stmt                           shift and go to state 77
    small_stmt                     shift and go to state 2
    while_stmt                     shift and go to state 27
    boolean                        shift and go to state 4
    return_stmt                    shift and go to state 5
    loop_stmt                      shift and go to state 19
    assignment                     shift and go to state 16
    const_decl                     shift and go to state 10
    compound_stmt                  shift and go to state 13
    if_stmt                        shift and go to state 24

state 87

    (48) func_def -> FUNCTION head END_STATEMENT body END . END_STATEMENT

    END_STATEMENT   shift and go to state 97


state 88

    (54) body -> stmt body .

    END             reduce using rule 54 (body -> stmt body .)


state 89

    (49) head -> IDENTIFIER LPAREN func_def_args RPAREN . COLON

    COLON           shift and go to state 98


state 90

    (50) head -> IDENTIFIER LPAREN RPAREN COLON .

    END_STATEMENT   reduce using rule 50 (head -> IDENTIFIER LPAREN RPAREN COLON .)


state 91

    (52) func_def_args -> IDENTIFIER COMMA . func_def_args
    (51) func_def_args -> . IDENTIFIER
    (52) func_def_args -> . IDENTIFIER COMMA func_def_args

    IDENTIFIER      shift and go to state 80

    func_def_args                  shift and go to state 99

state 92

    (55) while_stmt -> WHILE expr COLON END_STATEMENT body . END END_STATEMENT

    END             shift and go to state 100


state 93

    (56) for_stmt -> FOR IDENTIFIER IN RANGE LPAREN . expr COMMA expr RPAREN COLON END_STATEMENT body END END_STATEMENT
    (21) expr -> . IDENTIFIER
    (22) expr -> . LPAREN expr RPAREN
    (23) expr -> . func_call
    (24) expr -> . INTEGER
    (25) expr -> . DOUBLE
    (26) expr -> . boolean
    (29) expr -> . expr ADD_OP expr
    (30) expr -> . expr SUB_OP expr
    (31) expr -> . expr MUL_OP expr
    (32) expr -> . expr DIV_OP expr
    (33) expr -> . expr MOD_OP expr
    (34) expr -> . expr comb_op expr
    (35) expr -> . expr comp_op expr
    (17) func_call -> . IDENTIFIER LPAREN call_args RPAREN
    (18) func_call -> . IDENTIFIER LPAREN RPAREN
    (27) boolean -> . TRUE
    (28) boolean -> . FALSE

    IDENTIFIER      shift and go to state 33
    LPAREN          shift and go to state 20
    INTEGER         shift and go to state 7
    DOUBLE          shift and go to state 29
    TRUE            shift and go to state 8
    FALSE           shift and go to state 23

    func_call                      shift and go to state 22
    expr                           shift and go to state 101
    boolean                        shift and go to state 4

state 94

    (57) for_stmt -> FOR IDENTIFIER IN IDENTIFIER COLON . END_STATEMENT body END END_STATEMENT

    END_STATEMENT   shift and go to state 102


state 95

    (20) call_args -> expr COMMA call_args .

    RPAREN          reduce using rule 20 (call_args -> expr COMMA call_args .)


state 96

    (58) if_stmt -> IF expr COLON END_STATEMENT body . END END_STATEMENT
    (59) if_stmt -> IF expr COLON END_STATEMENT body . END END_STATEMENT elseif_list
    (60) if_stmt -> IF expr COLON END_STATEMENT body . END END_STATEMENT elseif_list ELSE COLON END_STATEMENT body END END_STATEMENT
    (61) if_stmt -> IF expr COLON END_STATEMENT body . END END_STATEMENT ELSE COLON END_STATEMENT body END END_STATEMENT

    END             shift and go to state 103


state 97

    (48) func_def -> FUNCTION head END_STATEMENT body END END_STATEMENT .

    FUNCTION        reduce using rule 48 (func_def -> FUNCTION head END_STATEMENT body END END_STATEMENT .)
    IF              reduce using rule 48 (func_def -> FUNCTION head END_STATEMENT body END END_STATEMENT .)
    WHILE           reduce using rule 48 (func_def -> FUNCTION head END_STATEMENT body END END_STATEMENT .)
    FOR             reduce using rule 48 (func_def -> FUNCTION head END_STATEMENT body END END_STATEMENT .)
    IDENTIFIER      reduce using rule 48 (func_def -> FUNCTION head END_STATEMENT body END END_STATEMENT .)
    LPAREN          reduce using rule 48 (func_def -> FUNCTION head END_STATEMENT body END END_STATEMENT .)
    INTEGER         reduce using rule 48 (func_def -> FUNCTION head END_STATEMENT body END END_STATEMENT .)
    DOUBLE          reduce using rule 48 (func_def -> FUNCTION head END_STATEMENT body END END_STATEMENT .)
    RETURN          reduce using rule 48 (func_def -> FUNCTION head END_STATEMENT body END END_STATEMENT .)
    BREAK           reduce using rule 48 (func_def -> FUNCTION head END_STATEMENT body END END_STATEMENT .)
    CONTINUE        reduce using rule 48 (func_def -> FUNCTION head END_STATEMENT body END END_STATEMENT .)
    TRUE            reduce using rule 48 (func_def -> FUNCTION head END_STATEMENT body END END_STATEMENT .)
    FALSE           reduce using rule 48 (func_def -> FUNCTION head END_STATEMENT body END END_STATEMENT .)
    END             reduce using rule 48 (func_def -> FUNCTION head END_STATEMENT body END END_STATEMENT .)
    $end            reduce using rule 48 (func_def -> FUNCTION head END_STATEMENT body END END_STATEMENT .)


state 98

    (49) head -> IDENTIFIER LPAREN func_def_args RPAREN COLON .

    END_STATEMENT   reduce using rule 49 (head -> IDENTIFIER LPAREN func_def_args RPAREN COLON .)


state 99

    (52) func_def_args -> IDENTIFIER COMMA func_def_args .

    RPAREN          reduce using rule 52 (func_def_args -> IDENTIFIER COMMA func_def_args .)


state 100

    (55) while_stmt -> WHILE expr COLON END_STATEMENT body END . END_STATEMENT

    END_STATEMENT   shift and go to state 104


state 101

    (56) for_stmt -> FOR IDENTIFIER IN RANGE LPAREN expr . COMMA expr RPAREN COLON END_STATEMENT body END END_STATEMENT
    (29) expr -> expr . ADD_OP expr
    (30) expr -> expr . SUB_OP expr
    (31) expr -> expr . MUL_OP expr
    (32) expr -> expr . DIV_OP expr
    (33) expr -> expr . MOD_OP expr
    (34) expr -> expr . comb_op expr
    (35) expr -> expr . comp_op expr
    (36) comb_op -> . OR
    (37) comb_op -> . AND
    (38) comp_op -> . CEQ
    (39) comp_op -> . CNE
    (40) comp_op -> . CLT
    (41) comp_op -> . CLE
    (42) comp_op -> . CGT
    (43) comp_op -> . CGE

    COMMA           shift and go to state 105
    ADD_OP          shift and go to state 54
    SUB_OP          shift and go to state 50
    MUL_OP          shift and go to state 45
    DIV_OP          shift and go to state 51
    MOD_OP          shift and go to state 56
    OR              shift and go to state 57
    AND             shift and go to state 43
    CEQ             shift and go to state 53
    CNE             shift and go to state 52
    CLT             shift and go to state 55
    CLE             shift and go to state 44
    CGT             shift and go to state 46
    CGE             shift and go to state 47

    comp_op                        shift and go to state 49
    comb_op                        shift and go to state 48

state 102

    (57) for_stmt -> FOR IDENTIFIER IN IDENTIFIER COLON END_STATEMENT . body END END_STATEMENT
    (53) body -> . stmt
    (54) body -> . stmt body
    (3) stmt -> . simple_stmt
    (4) stmt -> . compound_stmt
    (5) simple_stmt -> . small_stmt END_STATEMENT
    (44) compound_stmt -> . func_def
    (45) compound_stmt -> . if_stmt
    (46) compound_stmt -> . while_stmt
    (47) compound_stmt -> . for_stmt
    (6) small_stmt -> . assignment
    (7) small_stmt -> . const_decl
    (8) small_stmt -> . expr
    (9) small_stmt -> . return_stmt
    (10) small_stmt -> . loop_stmt
    (48) func_def -> . FUNCTION head END_STATEMENT body END END_STATEMENT
    (58) if_stmt -> . IF expr COLON END_STATEMENT body END END_STATEMENT
    (59) if_stmt -> . IF expr COLON END_STATEMENT body END END_STATEMENT elseif_list
    (60) if_stmt -> . IF expr COLON END_STATEMENT body END END_STATEMENT elseif_list ELSE COLON END_STATEMENT body END END_STATEMENT
    (61) if_stmt -> . IF expr COLON END_STATEMENT body END END_STATEMENT ELSE COLON END_STATEMENT body END END_STATEMENT
    (55) while_stmt -> . WHILE expr COLON END_STATEMENT body END END_STATEMENT
    (56) for_stmt -> . FOR IDENTIFIER IN RANGE LPAREN expr COMMA expr RPAREN COLON END_STATEMENT body END END_STATEMENT
    (57) for_stmt -> . FOR IDENTIFIER IN IDENTIFIER COLON END_STATEMENT body END END_STATEMENT
    (15) assignment -> . IDENTIFIER ASSIGN expr
    (16) const_decl -> . IDENTIFIER CONST expr
    (21) expr -> . IDENTIFIER
    (22) expr -> . LPAREN expr RPAREN
    (23) expr -> . func_call
    (24) expr -> . INTEGER
    (25) expr -> . DOUBLE
    (26) expr -> . boolean
    (29) expr -> . expr ADD_OP expr
    (30) expr -> . expr SUB_OP expr
    (31) expr -> . expr MUL_OP expr
    (32) expr -> . expr DIV_OP expr
    (33) expr -> . expr MOD_OP expr
    (34) expr -> . expr comb_op expr
    (35) expr -> . expr comp_op expr
    (11) return_stmt -> . RETURN
    (12) return_stmt -> . RETURN expr
    (13) loop_stmt -> . BREAK
    (14) loop_stmt -> . CONTINUE
    (17) func_call -> . IDENTIFIER LPAREN call_args RPAREN
    (18) func_call -> . IDENTIFIER LPAREN RPAREN
    (27) boolean -> . TRUE
    (28) boolean -> . FALSE

    FUNCTION        shift and go to state 1
    IF              shift and go to state 21
    WHILE           shift and go to state 3
    FOR             shift and go to state 9
    IDENTIFIER      shift and go to state 12
    LPAREN          shift and go to state 20
    INTEGER         shift and go to state 7
    DOUBLE          shift and go to state 29
    RETURN          shift and go to state 6
    BREAK           shift and go to state 26
    CONTINUE        shift and go to state 28
    TRUE            shift and go to state 8
    FALSE           shift and go to state 23

    body                           shift and go to state 106
    func_call                      shift and go to state 22
    if_stmt                        shift and go to state 24
    func_def                       shift and go to state 14
    simple_stmt                    shift and go to state 15
    assignment                     shift and go to state 16
    for_stmt                       shift and go to state 18
    stmt                           shift and go to state 77
    small_stmt                     shift and go to state 2
    while_stmt                     shift and go to state 27
    boolean                        shift and go to state 4
    return_stmt                    shift and go to state 5
    loop_stmt                      shift and go to state 19
    expr                           shift and go to state 25
    const_decl                     shift and go to state 10
    compound_stmt                  shift and go to state 13

state 103

    (58) if_stmt -> IF expr COLON END_STATEMENT body END . END_STATEMENT
    (59) if_stmt -> IF expr COLON END_STATEMENT body END . END_STATEMENT elseif_list
    (60) if_stmt -> IF expr COLON END_STATEMENT body END . END_STATEMENT elseif_list ELSE COLON END_STATEMENT body END END_STATEMENT
    (61) if_stmt -> IF expr COLON END_STATEMENT body END . END_STATEMENT ELSE COLON END_STATEMENT body END END_STATEMENT

    END_STATEMENT   shift and go to state 107


state 104

    (55) while_stmt -> WHILE expr COLON END_STATEMENT body END END_STATEMENT .

    FUNCTION        reduce using rule 55 (while_stmt -> WHILE expr COLON END_STATEMENT body END END_STATEMENT .)
    IF              reduce using rule 55 (while_stmt -> WHILE expr COLON END_STATEMENT body END END_STATEMENT .)
    WHILE           reduce using rule 55 (while_stmt -> WHILE expr COLON END_STATEMENT body END END_STATEMENT .)
    FOR             reduce using rule 55 (while_stmt -> WHILE expr COLON END_STATEMENT body END END_STATEMENT .)
    IDENTIFIER      reduce using rule 55 (while_stmt -> WHILE expr COLON END_STATEMENT body END END_STATEMENT .)
    LPAREN          reduce using rule 55 (while_stmt -> WHILE expr COLON END_STATEMENT body END END_STATEMENT .)
    INTEGER         reduce using rule 55 (while_stmt -> WHILE expr COLON END_STATEMENT body END END_STATEMENT .)
    DOUBLE          reduce using rule 55 (while_stmt -> WHILE expr COLON END_STATEMENT body END END_STATEMENT .)
    RETURN          reduce using rule 55 (while_stmt -> WHILE expr COLON END_STATEMENT body END END_STATEMENT .)
    BREAK           reduce using rule 55 (while_stmt -> WHILE expr COLON END_STATEMENT body END END_STATEMENT .)
    CONTINUE        reduce using rule 55 (while_stmt -> WHILE expr COLON END_STATEMENT body END END_STATEMENT .)
    TRUE            reduce using rule 55 (while_stmt -> WHILE expr COLON END_STATEMENT body END END_STATEMENT .)
    FALSE           reduce using rule 55 (while_stmt -> WHILE expr COLON END_STATEMENT body END END_STATEMENT .)
    END             reduce using rule 55 (while_stmt -> WHILE expr COLON END_STATEMENT body END END_STATEMENT .)
    $end            reduce using rule 55 (while_stmt -> WHILE expr COLON END_STATEMENT body END END_STATEMENT .)


state 105

    (56) for_stmt -> FOR IDENTIFIER IN RANGE LPAREN expr COMMA . expr RPAREN COLON END_STATEMENT body END END_STATEMENT
    (21) expr -> . IDENTIFIER
    (22) expr -> . LPAREN expr RPAREN
    (23) expr -> . func_call
    (24) expr -> . INTEGER
    (25) expr -> . DOUBLE
    (26) expr -> . boolean
    (29) expr -> . expr ADD_OP expr
    (30) expr -> . expr SUB_OP expr
    (31) expr -> . expr MUL_OP expr
    (32) expr -> . expr DIV_OP expr
    (33) expr -> . expr MOD_OP expr
    (34) expr -> . expr comb_op expr
    (35) expr -> . expr comp_op expr
    (17) func_call -> . IDENTIFIER LPAREN call_args RPAREN
    (18) func_call -> . IDENTIFIER LPAREN RPAREN
    (27) boolean -> . TRUE
    (28) boolean -> . FALSE

    IDENTIFIER      shift and go to state 33
    LPAREN          shift and go to state 20
    INTEGER         shift and go to state 7
    DOUBLE          shift and go to state 29
    TRUE            shift and go to state 8
    FALSE           shift and go to state 23

    func_call                      shift and go to state 22
    expr                           shift and go to state 108
    boolean                        shift and go to state 4

state 106

    (57) for_stmt -> FOR IDENTIFIER IN IDENTIFIER COLON END_STATEMENT body . END END_STATEMENT

    END             shift and go to state 109


state 107

    (58) if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT .
    (59) if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT . elseif_list
    (60) if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT . elseif_list ELSE COLON END_STATEMENT body END END_STATEMENT
    (61) if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT . ELSE COLON END_STATEMENT body END END_STATEMENT
    (62) elseif_list -> . ELSEIF expr COLON END_STATEMENT body END END_STATEMENT
    (63) elseif_list -> . ELSEIF expr COLON END_STATEMENT body END END_STATEMENT elseif_list

    FUNCTION        reduce using rule 58 (if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT .)
    IF              reduce using rule 58 (if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT .)
    WHILE           reduce using rule 58 (if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT .)
    FOR             reduce using rule 58 (if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT .)
    IDENTIFIER      reduce using rule 58 (if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT .)
    LPAREN          reduce using rule 58 (if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT .)
    INTEGER         reduce using rule 58 (if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT .)
    DOUBLE          reduce using rule 58 (if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT .)
    RETURN          reduce using rule 58 (if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT .)
    BREAK           reduce using rule 58 (if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT .)
    CONTINUE        reduce using rule 58 (if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT .)
    TRUE            reduce using rule 58 (if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT .)
    FALSE           reduce using rule 58 (if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT .)
    END             reduce using rule 58 (if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT .)
    $end            reduce using rule 58 (if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT .)
    ELSE            shift and go to state 111
    ELSEIF          shift and go to state 112

    elseif_list                    shift and go to state 110

state 108

    (56) for_stmt -> FOR IDENTIFIER IN RANGE LPAREN expr COMMA expr . RPAREN COLON END_STATEMENT body END END_STATEMENT
    (29) expr -> expr . ADD_OP expr
    (30) expr -> expr . SUB_OP expr
    (31) expr -> expr . MUL_OP expr
    (32) expr -> expr . DIV_OP expr
    (33) expr -> expr . MOD_OP expr
    (34) expr -> expr . comb_op expr
    (35) expr -> expr . comp_op expr
    (36) comb_op -> . OR
    (37) comb_op -> . AND
    (38) comp_op -> . CEQ
    (39) comp_op -> . CNE
    (40) comp_op -> . CLT
    (41) comp_op -> . CLE
    (42) comp_op -> . CGT
    (43) comp_op -> . CGE

    RPAREN          shift and go to state 113
    ADD_OP          shift and go to state 54
    SUB_OP          shift and go to state 50
    MUL_OP          shift and go to state 45
    DIV_OP          shift and go to state 51
    MOD_OP          shift and go to state 56
    OR              shift and go to state 57
    AND             shift and go to state 43
    CEQ             shift and go to state 53
    CNE             shift and go to state 52
    CLT             shift and go to state 55
    CLE             shift and go to state 44
    CGT             shift and go to state 46
    CGE             shift and go to state 47

    comp_op                        shift and go to state 49
    comb_op                        shift and go to state 48

state 109

    (57) for_stmt -> FOR IDENTIFIER IN IDENTIFIER COLON END_STATEMENT body END . END_STATEMENT

    END_STATEMENT   shift and go to state 114


state 110

    (59) if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT elseif_list .
    (60) if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT elseif_list . ELSE COLON END_STATEMENT body END END_STATEMENT

    FUNCTION        reduce using rule 59 (if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT elseif_list .)
    IF              reduce using rule 59 (if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT elseif_list .)
    WHILE           reduce using rule 59 (if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT elseif_list .)
    FOR             reduce using rule 59 (if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT elseif_list .)
    IDENTIFIER      reduce using rule 59 (if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT elseif_list .)
    LPAREN          reduce using rule 59 (if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT elseif_list .)
    INTEGER         reduce using rule 59 (if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT elseif_list .)
    DOUBLE          reduce using rule 59 (if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT elseif_list .)
    RETURN          reduce using rule 59 (if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT elseif_list .)
    BREAK           reduce using rule 59 (if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT elseif_list .)
    CONTINUE        reduce using rule 59 (if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT elseif_list .)
    TRUE            reduce using rule 59 (if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT elseif_list .)
    FALSE           reduce using rule 59 (if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT elseif_list .)
    END             reduce using rule 59 (if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT elseif_list .)
    $end            reduce using rule 59 (if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT elseif_list .)
    ELSE            shift and go to state 115


state 111

    (61) if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT ELSE . COLON END_STATEMENT body END END_STATEMENT

    COLON           shift and go to state 116


state 112

    (62) elseif_list -> ELSEIF . expr COLON END_STATEMENT body END END_STATEMENT
    (63) elseif_list -> ELSEIF . expr COLON END_STATEMENT body END END_STATEMENT elseif_list
    (21) expr -> . IDENTIFIER
    (22) expr -> . LPAREN expr RPAREN
    (23) expr -> . func_call
    (24) expr -> . INTEGER
    (25) expr -> . DOUBLE
    (26) expr -> . boolean
    (29) expr -> . expr ADD_OP expr
    (30) expr -> . expr SUB_OP expr
    (31) expr -> . expr MUL_OP expr
    (32) expr -> . expr DIV_OP expr
    (33) expr -> . expr MOD_OP expr
    (34) expr -> . expr comb_op expr
    (35) expr -> . expr comp_op expr
    (17) func_call -> . IDENTIFIER LPAREN call_args RPAREN
    (18) func_call -> . IDENTIFIER LPAREN RPAREN
    (27) boolean -> . TRUE
    (28) boolean -> . FALSE

    IDENTIFIER      shift and go to state 33
    LPAREN          shift and go to state 20
    INTEGER         shift and go to state 7
    DOUBLE          shift and go to state 29
    TRUE            shift and go to state 8
    FALSE           shift and go to state 23

    func_call                      shift and go to state 22
    expr                           shift and go to state 117
    boolean                        shift and go to state 4

state 113

    (56) for_stmt -> FOR IDENTIFIER IN RANGE LPAREN expr COMMA expr RPAREN . COLON END_STATEMENT body END END_STATEMENT

    COLON           shift and go to state 118


state 114

    (57) for_stmt -> FOR IDENTIFIER IN IDENTIFIER COLON END_STATEMENT body END END_STATEMENT .

    FUNCTION        reduce using rule 57 (for_stmt -> FOR IDENTIFIER IN IDENTIFIER COLON END_STATEMENT body END END_STATEMENT .)
    IF              reduce using rule 57 (for_stmt -> FOR IDENTIFIER IN IDENTIFIER COLON END_STATEMENT body END END_STATEMENT .)
    WHILE           reduce using rule 57 (for_stmt -> FOR IDENTIFIER IN IDENTIFIER COLON END_STATEMENT body END END_STATEMENT .)
    FOR             reduce using rule 57 (for_stmt -> FOR IDENTIFIER IN IDENTIFIER COLON END_STATEMENT body END END_STATEMENT .)
    IDENTIFIER      reduce using rule 57 (for_stmt -> FOR IDENTIFIER IN IDENTIFIER COLON END_STATEMENT body END END_STATEMENT .)
    LPAREN          reduce using rule 57 (for_stmt -> FOR IDENTIFIER IN IDENTIFIER COLON END_STATEMENT body END END_STATEMENT .)
    INTEGER         reduce using rule 57 (for_stmt -> FOR IDENTIFIER IN IDENTIFIER COLON END_STATEMENT body END END_STATEMENT .)
    DOUBLE          reduce using rule 57 (for_stmt -> FOR IDENTIFIER IN IDENTIFIER COLON END_STATEMENT body END END_STATEMENT .)
    RETURN          reduce using rule 57 (for_stmt -> FOR IDENTIFIER IN IDENTIFIER COLON END_STATEMENT body END END_STATEMENT .)
    BREAK           reduce using rule 57 (for_stmt -> FOR IDENTIFIER IN IDENTIFIER COLON END_STATEMENT body END END_STATEMENT .)
    CONTINUE        reduce using rule 57 (for_stmt -> FOR IDENTIFIER IN IDENTIFIER COLON END_STATEMENT body END END_STATEMENT .)
    TRUE            reduce using rule 57 (for_stmt -> FOR IDENTIFIER IN IDENTIFIER COLON END_STATEMENT body END END_STATEMENT .)
    FALSE           reduce using rule 57 (for_stmt -> FOR IDENTIFIER IN IDENTIFIER COLON END_STATEMENT body END END_STATEMENT .)
    END             reduce using rule 57 (for_stmt -> FOR IDENTIFIER IN IDENTIFIER COLON END_STATEMENT body END END_STATEMENT .)
    $end            reduce using rule 57 (for_stmt -> FOR IDENTIFIER IN IDENTIFIER COLON END_STATEMENT body END END_STATEMENT .)


state 115

    (60) if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT elseif_list ELSE . COLON END_STATEMENT body END END_STATEMENT

    COLON           shift and go to state 119


state 116

    (61) if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT ELSE COLON . END_STATEMENT body END END_STATEMENT

    END_STATEMENT   shift and go to state 120


state 117

    (62) elseif_list -> ELSEIF expr . COLON END_STATEMENT body END END_STATEMENT
    (63) elseif_list -> ELSEIF expr . COLON END_STATEMENT body END END_STATEMENT elseif_list
    (29) expr -> expr . ADD_OP expr
    (30) expr -> expr . SUB_OP expr
    (31) expr -> expr . MUL_OP expr
    (32) expr -> expr . DIV_OP expr
    (33) expr -> expr . MOD_OP expr
    (34) expr -> expr . comb_op expr
    (35) expr -> expr . comp_op expr
    (36) comb_op -> . OR
    (37) comb_op -> . AND
    (38) comp_op -> . CEQ
    (39) comp_op -> . CNE
    (40) comp_op -> . CLT
    (41) comp_op -> . CLE
    (42) comp_op -> . CGT
    (43) comp_op -> . CGE

    COLON           shift and go to state 121
    ADD_OP          shift and go to state 54
    SUB_OP          shift and go to state 50
    MUL_OP          shift and go to state 45
    DIV_OP          shift and go to state 51
    MOD_OP          shift and go to state 56
    OR              shift and go to state 57
    AND             shift and go to state 43
    CEQ             shift and go to state 53
    CNE             shift and go to state 52
    CLT             shift and go to state 55
    CLE             shift and go to state 44
    CGT             shift and go to state 46
    CGE             shift and go to state 47

    comp_op                        shift and go to state 49
    comb_op                        shift and go to state 48

state 118

    (56) for_stmt -> FOR IDENTIFIER IN RANGE LPAREN expr COMMA expr RPAREN COLON . END_STATEMENT body END END_STATEMENT

    END_STATEMENT   shift and go to state 122


state 119

    (60) if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT elseif_list ELSE COLON . END_STATEMENT body END END_STATEMENT

    END_STATEMENT   shift and go to state 123


state 120

    (61) if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT ELSE COLON END_STATEMENT . body END END_STATEMENT
    (53) body -> . stmt
    (54) body -> . stmt body
    (3) stmt -> . simple_stmt
    (4) stmt -> . compound_stmt
    (5) simple_stmt -> . small_stmt END_STATEMENT
    (44) compound_stmt -> . func_def
    (45) compound_stmt -> . if_stmt
    (46) compound_stmt -> . while_stmt
    (47) compound_stmt -> . for_stmt
    (6) small_stmt -> . assignment
    (7) small_stmt -> . const_decl
    (8) small_stmt -> . expr
    (9) small_stmt -> . return_stmt
    (10) small_stmt -> . loop_stmt
    (48) func_def -> . FUNCTION head END_STATEMENT body END END_STATEMENT
    (58) if_stmt -> . IF expr COLON END_STATEMENT body END END_STATEMENT
    (59) if_stmt -> . IF expr COLON END_STATEMENT body END END_STATEMENT elseif_list
    (60) if_stmt -> . IF expr COLON END_STATEMENT body END END_STATEMENT elseif_list ELSE COLON END_STATEMENT body END END_STATEMENT
    (61) if_stmt -> . IF expr COLON END_STATEMENT body END END_STATEMENT ELSE COLON END_STATEMENT body END END_STATEMENT
    (55) while_stmt -> . WHILE expr COLON END_STATEMENT body END END_STATEMENT
    (56) for_stmt -> . FOR IDENTIFIER IN RANGE LPAREN expr COMMA expr RPAREN COLON END_STATEMENT body END END_STATEMENT
    (57) for_stmt -> . FOR IDENTIFIER IN IDENTIFIER COLON END_STATEMENT body END END_STATEMENT
    (15) assignment -> . IDENTIFIER ASSIGN expr
    (16) const_decl -> . IDENTIFIER CONST expr
    (21) expr -> . IDENTIFIER
    (22) expr -> . LPAREN expr RPAREN
    (23) expr -> . func_call
    (24) expr -> . INTEGER
    (25) expr -> . DOUBLE
    (26) expr -> . boolean
    (29) expr -> . expr ADD_OP expr
    (30) expr -> . expr SUB_OP expr
    (31) expr -> . expr MUL_OP expr
    (32) expr -> . expr DIV_OP expr
    (33) expr -> . expr MOD_OP expr
    (34) expr -> . expr comb_op expr
    (35) expr -> . expr comp_op expr
    (11) return_stmt -> . RETURN
    (12) return_stmt -> . RETURN expr
    (13) loop_stmt -> . BREAK
    (14) loop_stmt -> . CONTINUE
    (17) func_call -> . IDENTIFIER LPAREN call_args RPAREN
    (18) func_call -> . IDENTIFIER LPAREN RPAREN
    (27) boolean -> . TRUE
    (28) boolean -> . FALSE

    FUNCTION        shift and go to state 1
    IF              shift and go to state 21
    WHILE           shift and go to state 3
    FOR             shift and go to state 9
    IDENTIFIER      shift and go to state 12
    LPAREN          shift and go to state 20
    INTEGER         shift and go to state 7
    DOUBLE          shift and go to state 29
    RETURN          shift and go to state 6
    BREAK           shift and go to state 26
    CONTINUE        shift and go to state 28
    TRUE            shift and go to state 8
    FALSE           shift and go to state 23

    body                           shift and go to state 124
    func_call                      shift and go to state 22
    if_stmt                        shift and go to state 24
    func_def                       shift and go to state 14
    simple_stmt                    shift and go to state 15
    expr                           shift and go to state 25
    for_stmt                       shift and go to state 18
    stmt                           shift and go to state 77
    small_stmt                     shift and go to state 2
    while_stmt                     shift and go to state 27
    boolean                        shift and go to state 4
    return_stmt                    shift and go to state 5
    loop_stmt                      shift and go to state 19
    assignment                     shift and go to state 16
    const_decl                     shift and go to state 10
    compound_stmt                  shift and go to state 13

state 121

    (62) elseif_list -> ELSEIF expr COLON . END_STATEMENT body END END_STATEMENT
    (63) elseif_list -> ELSEIF expr COLON . END_STATEMENT body END END_STATEMENT elseif_list

    END_STATEMENT   shift and go to state 125


state 122

    (56) for_stmt -> FOR IDENTIFIER IN RANGE LPAREN expr COMMA expr RPAREN COLON END_STATEMENT . body END END_STATEMENT
    (53) body -> . stmt
    (54) body -> . stmt body
    (3) stmt -> . simple_stmt
    (4) stmt -> . compound_stmt
    (5) simple_stmt -> . small_stmt END_STATEMENT
    (44) compound_stmt -> . func_def
    (45) compound_stmt -> . if_stmt
    (46) compound_stmt -> . while_stmt
    (47) compound_stmt -> . for_stmt
    (6) small_stmt -> . assignment
    (7) small_stmt -> . const_decl
    (8) small_stmt -> . expr
    (9) small_stmt -> . return_stmt
    (10) small_stmt -> . loop_stmt
    (48) func_def -> . FUNCTION head END_STATEMENT body END END_STATEMENT
    (58) if_stmt -> . IF expr COLON END_STATEMENT body END END_STATEMENT
    (59) if_stmt -> . IF expr COLON END_STATEMENT body END END_STATEMENT elseif_list
    (60) if_stmt -> . IF expr COLON END_STATEMENT body END END_STATEMENT elseif_list ELSE COLON END_STATEMENT body END END_STATEMENT
    (61) if_stmt -> . IF expr COLON END_STATEMENT body END END_STATEMENT ELSE COLON END_STATEMENT body END END_STATEMENT
    (55) while_stmt -> . WHILE expr COLON END_STATEMENT body END END_STATEMENT
    (56) for_stmt -> . FOR IDENTIFIER IN RANGE LPAREN expr COMMA expr RPAREN COLON END_STATEMENT body END END_STATEMENT
    (57) for_stmt -> . FOR IDENTIFIER IN IDENTIFIER COLON END_STATEMENT body END END_STATEMENT
    (15) assignment -> . IDENTIFIER ASSIGN expr
    (16) const_decl -> . IDENTIFIER CONST expr
    (21) expr -> . IDENTIFIER
    (22) expr -> . LPAREN expr RPAREN
    (23) expr -> . func_call
    (24) expr -> . INTEGER
    (25) expr -> . DOUBLE
    (26) expr -> . boolean
    (29) expr -> . expr ADD_OP expr
    (30) expr -> . expr SUB_OP expr
    (31) expr -> . expr MUL_OP expr
    (32) expr -> . expr DIV_OP expr
    (33) expr -> . expr MOD_OP expr
    (34) expr -> . expr comb_op expr
    (35) expr -> . expr comp_op expr
    (11) return_stmt -> . RETURN
    (12) return_stmt -> . RETURN expr
    (13) loop_stmt -> . BREAK
    (14) loop_stmt -> . CONTINUE
    (17) func_call -> . IDENTIFIER LPAREN call_args RPAREN
    (18) func_call -> . IDENTIFIER LPAREN RPAREN
    (27) boolean -> . TRUE
    (28) boolean -> . FALSE

    FUNCTION        shift and go to state 1
    IF              shift and go to state 21
    WHILE           shift and go to state 3
    FOR             shift and go to state 9
    IDENTIFIER      shift and go to state 12
    LPAREN          shift and go to state 20
    INTEGER         shift and go to state 7
    DOUBLE          shift and go to state 29
    RETURN          shift and go to state 6
    BREAK           shift and go to state 26
    CONTINUE        shift and go to state 28
    TRUE            shift and go to state 8
    FALSE           shift and go to state 23

    body                           shift and go to state 126
    func_call                      shift and go to state 22
    if_stmt                        shift and go to state 24
    func_def                       shift and go to state 14
    simple_stmt                    shift and go to state 15
    expr                           shift and go to state 25
    for_stmt                       shift and go to state 18
    stmt                           shift and go to state 77
    small_stmt                     shift and go to state 2
    while_stmt                     shift and go to state 27
    boolean                        shift and go to state 4
    return_stmt                    shift and go to state 5
    loop_stmt                      shift and go to state 19
    assignment                     shift and go to state 16
    const_decl                     shift and go to state 10
    compound_stmt                  shift and go to state 13

state 123

    (60) if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT elseif_list ELSE COLON END_STATEMENT . body END END_STATEMENT
    (53) body -> . stmt
    (54) body -> . stmt body
    (3) stmt -> . simple_stmt
    (4) stmt -> . compound_stmt
    (5) simple_stmt -> . small_stmt END_STATEMENT
    (44) compound_stmt -> . func_def
    (45) compound_stmt -> . if_stmt
    (46) compound_stmt -> . while_stmt
    (47) compound_stmt -> . for_stmt
    (6) small_stmt -> . assignment
    (7) small_stmt -> . const_decl
    (8) small_stmt -> . expr
    (9) small_stmt -> . return_stmt
    (10) small_stmt -> . loop_stmt
    (48) func_def -> . FUNCTION head END_STATEMENT body END END_STATEMENT
    (58) if_stmt -> . IF expr COLON END_STATEMENT body END END_STATEMENT
    (59) if_stmt -> . IF expr COLON END_STATEMENT body END END_STATEMENT elseif_list
    (60) if_stmt -> . IF expr COLON END_STATEMENT body END END_STATEMENT elseif_list ELSE COLON END_STATEMENT body END END_STATEMENT
    (61) if_stmt -> . IF expr COLON END_STATEMENT body END END_STATEMENT ELSE COLON END_STATEMENT body END END_STATEMENT
    (55) while_stmt -> . WHILE expr COLON END_STATEMENT body END END_STATEMENT
    (56) for_stmt -> . FOR IDENTIFIER IN RANGE LPAREN expr COMMA expr RPAREN COLON END_STATEMENT body END END_STATEMENT
    (57) for_stmt -> . FOR IDENTIFIER IN IDENTIFIER COLON END_STATEMENT body END END_STATEMENT
    (15) assignment -> . IDENTIFIER ASSIGN expr
    (16) const_decl -> . IDENTIFIER CONST expr
    (21) expr -> . IDENTIFIER
    (22) expr -> . LPAREN expr RPAREN
    (23) expr -> . func_call
    (24) expr -> . INTEGER
    (25) expr -> . DOUBLE
    (26) expr -> . boolean
    (29) expr -> . expr ADD_OP expr
    (30) expr -> . expr SUB_OP expr
    (31) expr -> . expr MUL_OP expr
    (32) expr -> . expr DIV_OP expr
    (33) expr -> . expr MOD_OP expr
    (34) expr -> . expr comb_op expr
    (35) expr -> . expr comp_op expr
    (11) return_stmt -> . RETURN
    (12) return_stmt -> . RETURN expr
    (13) loop_stmt -> . BREAK
    (14) loop_stmt -> . CONTINUE
    (17) func_call -> . IDENTIFIER LPAREN call_args RPAREN
    (18) func_call -> . IDENTIFIER LPAREN RPAREN
    (27) boolean -> . TRUE
    (28) boolean -> . FALSE

    FUNCTION        shift and go to state 1
    IF              shift and go to state 21
    WHILE           shift and go to state 3
    FOR             shift and go to state 9
    IDENTIFIER      shift and go to state 12
    LPAREN          shift and go to state 20
    INTEGER         shift and go to state 7
    DOUBLE          shift and go to state 29
    RETURN          shift and go to state 6
    BREAK           shift and go to state 26
    CONTINUE        shift and go to state 28
    TRUE            shift and go to state 8
    FALSE           shift and go to state 23

    body                           shift and go to state 127
    func_call                      shift and go to state 22
    func_def                       shift and go to state 14
    simple_stmt                    shift and go to state 15
    expr                           shift and go to state 25
    for_stmt                       shift and go to state 18
    stmt                           shift and go to state 77
    small_stmt                     shift and go to state 2
    while_stmt                     shift and go to state 27
    boolean                        shift and go to state 4
    return_stmt                    shift and go to state 5
    loop_stmt                      shift and go to state 19
    assignment                     shift and go to state 16
    const_decl                     shift and go to state 10
    compound_stmt                  shift and go to state 13
    if_stmt                        shift and go to state 24

state 124

    (61) if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT ELSE COLON END_STATEMENT body . END END_STATEMENT

    END             shift and go to state 128


state 125

    (62) elseif_list -> ELSEIF expr COLON END_STATEMENT . body END END_STATEMENT
    (63) elseif_list -> ELSEIF expr COLON END_STATEMENT . body END END_STATEMENT elseif_list
    (53) body -> . stmt
    (54) body -> . stmt body
    (3) stmt -> . simple_stmt
    (4) stmt -> . compound_stmt
    (5) simple_stmt -> . small_stmt END_STATEMENT
    (44) compound_stmt -> . func_def
    (45) compound_stmt -> . if_stmt
    (46) compound_stmt -> . while_stmt
    (47) compound_stmt -> . for_stmt
    (6) small_stmt -> . assignment
    (7) small_stmt -> . const_decl
    (8) small_stmt -> . expr
    (9) small_stmt -> . return_stmt
    (10) small_stmt -> . loop_stmt
    (48) func_def -> . FUNCTION head END_STATEMENT body END END_STATEMENT
    (58) if_stmt -> . IF expr COLON END_STATEMENT body END END_STATEMENT
    (59) if_stmt -> . IF expr COLON END_STATEMENT body END END_STATEMENT elseif_list
    (60) if_stmt -> . IF expr COLON END_STATEMENT body END END_STATEMENT elseif_list ELSE COLON END_STATEMENT body END END_STATEMENT
    (61) if_stmt -> . IF expr COLON END_STATEMENT body END END_STATEMENT ELSE COLON END_STATEMENT body END END_STATEMENT
    (55) while_stmt -> . WHILE expr COLON END_STATEMENT body END END_STATEMENT
    (56) for_stmt -> . FOR IDENTIFIER IN RANGE LPAREN expr COMMA expr RPAREN COLON END_STATEMENT body END END_STATEMENT
    (57) for_stmt -> . FOR IDENTIFIER IN IDENTIFIER COLON END_STATEMENT body END END_STATEMENT
    (15) assignment -> . IDENTIFIER ASSIGN expr
    (16) const_decl -> . IDENTIFIER CONST expr
    (21) expr -> . IDENTIFIER
    (22) expr -> . LPAREN expr RPAREN
    (23) expr -> . func_call
    (24) expr -> . INTEGER
    (25) expr -> . DOUBLE
    (26) expr -> . boolean
    (29) expr -> . expr ADD_OP expr
    (30) expr -> . expr SUB_OP expr
    (31) expr -> . expr MUL_OP expr
    (32) expr -> . expr DIV_OP expr
    (33) expr -> . expr MOD_OP expr
    (34) expr -> . expr comb_op expr
    (35) expr -> . expr comp_op expr
    (11) return_stmt -> . RETURN
    (12) return_stmt -> . RETURN expr
    (13) loop_stmt -> . BREAK
    (14) loop_stmt -> . CONTINUE
    (17) func_call -> . IDENTIFIER LPAREN call_args RPAREN
    (18) func_call -> . IDENTIFIER LPAREN RPAREN
    (27) boolean -> . TRUE
    (28) boolean -> . FALSE

    FUNCTION        shift and go to state 1
    IF              shift and go to state 21
    WHILE           shift and go to state 3
    FOR             shift and go to state 9
    IDENTIFIER      shift and go to state 12
    LPAREN          shift and go to state 20
    INTEGER         shift and go to state 7
    DOUBLE          shift and go to state 29
    RETURN          shift and go to state 6
    BREAK           shift and go to state 26
    CONTINUE        shift and go to state 28
    TRUE            shift and go to state 8
    FALSE           shift and go to state 23

    body                           shift and go to state 129
    func_call                      shift and go to state 22
    func_def                       shift and go to state 14
    simple_stmt                    shift and go to state 15
    expr                           shift and go to state 25
    for_stmt                       shift and go to state 18
    stmt                           shift and go to state 77
    small_stmt                     shift and go to state 2
    while_stmt                     shift and go to state 27
    boolean                        shift and go to state 4
    return_stmt                    shift and go to state 5
    loop_stmt                      shift and go to state 19
    assignment                     shift and go to state 16
    const_decl                     shift and go to state 10
    compound_stmt                  shift and go to state 13
    if_stmt                        shift and go to state 24

state 126

    (56) for_stmt -> FOR IDENTIFIER IN RANGE LPAREN expr COMMA expr RPAREN COLON END_STATEMENT body . END END_STATEMENT

    END             shift and go to state 130


state 127

    (60) if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT elseif_list ELSE COLON END_STATEMENT body . END END_STATEMENT

    END             shift and go to state 131


state 128

    (61) if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT ELSE COLON END_STATEMENT body END . END_STATEMENT

    END_STATEMENT   shift and go to state 132


state 129

    (62) elseif_list -> ELSEIF expr COLON END_STATEMENT body . END END_STATEMENT
    (63) elseif_list -> ELSEIF expr COLON END_STATEMENT body . END END_STATEMENT elseif_list

    END             shift and go to state 133


state 130

    (56) for_stmt -> FOR IDENTIFIER IN RANGE LPAREN expr COMMA expr RPAREN COLON END_STATEMENT body END . END_STATEMENT

    END_STATEMENT   shift and go to state 134


state 131

    (60) if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT elseif_list ELSE COLON END_STATEMENT body END . END_STATEMENT

    END_STATEMENT   shift and go to state 135


state 132

    (61) if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT ELSE COLON END_STATEMENT body END END_STATEMENT .

    FUNCTION        reduce using rule 61 (if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT ELSE COLON END_STATEMENT body END END_STATEMENT .)
    IF              reduce using rule 61 (if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT ELSE COLON END_STATEMENT body END END_STATEMENT .)
    WHILE           reduce using rule 61 (if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT ELSE COLON END_STATEMENT body END END_STATEMENT .)
    FOR             reduce using rule 61 (if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT ELSE COLON END_STATEMENT body END END_STATEMENT .)
    IDENTIFIER      reduce using rule 61 (if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT ELSE COLON END_STATEMENT body END END_STATEMENT .)
    LPAREN          reduce using rule 61 (if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT ELSE COLON END_STATEMENT body END END_STATEMENT .)
    INTEGER         reduce using rule 61 (if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT ELSE COLON END_STATEMENT body END END_STATEMENT .)
    DOUBLE          reduce using rule 61 (if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT ELSE COLON END_STATEMENT body END END_STATEMENT .)
    RETURN          reduce using rule 61 (if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT ELSE COLON END_STATEMENT body END END_STATEMENT .)
    BREAK           reduce using rule 61 (if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT ELSE COLON END_STATEMENT body END END_STATEMENT .)
    CONTINUE        reduce using rule 61 (if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT ELSE COLON END_STATEMENT body END END_STATEMENT .)
    TRUE            reduce using rule 61 (if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT ELSE COLON END_STATEMENT body END END_STATEMENT .)
    FALSE           reduce using rule 61 (if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT ELSE COLON END_STATEMENT body END END_STATEMENT .)
    END             reduce using rule 61 (if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT ELSE COLON END_STATEMENT body END END_STATEMENT .)
    $end            reduce using rule 61 (if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT ELSE COLON END_STATEMENT body END END_STATEMENT .)


state 133

    (62) elseif_list -> ELSEIF expr COLON END_STATEMENT body END . END_STATEMENT
    (63) elseif_list -> ELSEIF expr COLON END_STATEMENT body END . END_STATEMENT elseif_list

    END_STATEMENT   shift and go to state 136


state 134

    (56) for_stmt -> FOR IDENTIFIER IN RANGE LPAREN expr COMMA expr RPAREN COLON END_STATEMENT body END END_STATEMENT .

    FUNCTION        reduce using rule 56 (for_stmt -> FOR IDENTIFIER IN RANGE LPAREN expr COMMA expr RPAREN COLON END_STATEMENT body END END_STATEMENT .)
    IF              reduce using rule 56 (for_stmt -> FOR IDENTIFIER IN RANGE LPAREN expr COMMA expr RPAREN COLON END_STATEMENT body END END_STATEMENT .)
    WHILE           reduce using rule 56 (for_stmt -> FOR IDENTIFIER IN RANGE LPAREN expr COMMA expr RPAREN COLON END_STATEMENT body END END_STATEMENT .)
    FOR             reduce using rule 56 (for_stmt -> FOR IDENTIFIER IN RANGE LPAREN expr COMMA expr RPAREN COLON END_STATEMENT body END END_STATEMENT .)
    IDENTIFIER      reduce using rule 56 (for_stmt -> FOR IDENTIFIER IN RANGE LPAREN expr COMMA expr RPAREN COLON END_STATEMENT body END END_STATEMENT .)
    LPAREN          reduce using rule 56 (for_stmt -> FOR IDENTIFIER IN RANGE LPAREN expr COMMA expr RPAREN COLON END_STATEMENT body END END_STATEMENT .)
    INTEGER         reduce using rule 56 (for_stmt -> FOR IDENTIFIER IN RANGE LPAREN expr COMMA expr RPAREN COLON END_STATEMENT body END END_STATEMENT .)
    DOUBLE          reduce using rule 56 (for_stmt -> FOR IDENTIFIER IN RANGE LPAREN expr COMMA expr RPAREN COLON END_STATEMENT body END END_STATEMENT .)
    RETURN          reduce using rule 56 (for_stmt -> FOR IDENTIFIER IN RANGE LPAREN expr COMMA expr RPAREN COLON END_STATEMENT body END END_STATEMENT .)
    BREAK           reduce using rule 56 (for_stmt -> FOR IDENTIFIER IN RANGE LPAREN expr COMMA expr RPAREN COLON END_STATEMENT body END END_STATEMENT .)
    CONTINUE        reduce using rule 56 (for_stmt -> FOR IDENTIFIER IN RANGE LPAREN expr COMMA expr RPAREN COLON END_STATEMENT body END END_STATEMENT .)
    TRUE            reduce using rule 56 (for_stmt -> FOR IDENTIFIER IN RANGE LPAREN expr COMMA expr RPAREN COLON END_STATEMENT body END END_STATEMENT .)
    FALSE           reduce using rule 56 (for_stmt -> FOR IDENTIFIER IN RANGE LPAREN expr COMMA expr RPAREN COLON END_STATEMENT body END END_STATEMENT .)
    END             reduce using rule 56 (for_stmt -> FOR IDENTIFIER IN RANGE LPAREN expr COMMA expr RPAREN COLON END_STATEMENT body END END_STATEMENT .)
    $end            reduce using rule 56 (for_stmt -> FOR IDENTIFIER IN RANGE LPAREN expr COMMA expr RPAREN COLON END_STATEMENT body END END_STATEMENT .)


state 135

    (60) if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT elseif_list ELSE COLON END_STATEMENT body END END_STATEMENT .

    FUNCTION        reduce using rule 60 (if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT elseif_list ELSE COLON END_STATEMENT body END END_STATEMENT .)
    IF              reduce using rule 60 (if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT elseif_list ELSE COLON END_STATEMENT body END END_STATEMENT .)
    WHILE           reduce using rule 60 (if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT elseif_list ELSE COLON END_STATEMENT body END END_STATEMENT .)
    FOR             reduce using rule 60 (if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT elseif_list ELSE COLON END_STATEMENT body END END_STATEMENT .)
    IDENTIFIER      reduce using rule 60 (if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT elseif_list ELSE COLON END_STATEMENT body END END_STATEMENT .)
    LPAREN          reduce using rule 60 (if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT elseif_list ELSE COLON END_STATEMENT body END END_STATEMENT .)
    INTEGER         reduce using rule 60 (if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT elseif_list ELSE COLON END_STATEMENT body END END_STATEMENT .)
    DOUBLE          reduce using rule 60 (if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT elseif_list ELSE COLON END_STATEMENT body END END_STATEMENT .)
    RETURN          reduce using rule 60 (if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT elseif_list ELSE COLON END_STATEMENT body END END_STATEMENT .)
    BREAK           reduce using rule 60 (if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT elseif_list ELSE COLON END_STATEMENT body END END_STATEMENT .)
    CONTINUE        reduce using rule 60 (if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT elseif_list ELSE COLON END_STATEMENT body END END_STATEMENT .)
    TRUE            reduce using rule 60 (if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT elseif_list ELSE COLON END_STATEMENT body END END_STATEMENT .)
    FALSE           reduce using rule 60 (if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT elseif_list ELSE COLON END_STATEMENT body END END_STATEMENT .)
    END             reduce using rule 60 (if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT elseif_list ELSE COLON END_STATEMENT body END END_STATEMENT .)
    $end            reduce using rule 60 (if_stmt -> IF expr COLON END_STATEMENT body END END_STATEMENT elseif_list ELSE COLON END_STATEMENT body END END_STATEMENT .)


state 136

    (62) elseif_list -> ELSEIF expr COLON END_STATEMENT body END END_STATEMENT .
    (63) elseif_list -> ELSEIF expr COLON END_STATEMENT body END END_STATEMENT . elseif_list
    (62) elseif_list -> . ELSEIF expr COLON END_STATEMENT body END END_STATEMENT
    (63) elseif_list -> . ELSEIF expr COLON END_STATEMENT body END END_STATEMENT elseif_list

    ELSE            reduce using rule 62 (elseif_list -> ELSEIF expr COLON END_STATEMENT body END END_STATEMENT .)
    FUNCTION        reduce using rule 62 (elseif_list -> ELSEIF expr COLON END_STATEMENT body END END_STATEMENT .)
    IF              reduce using rule 62 (elseif_list -> ELSEIF expr COLON END_STATEMENT body END END_STATEMENT .)
    WHILE           reduce using rule 62 (elseif_list -> ELSEIF expr COLON END_STATEMENT body END END_STATEMENT .)
    FOR             reduce using rule 62 (elseif_list -> ELSEIF expr COLON END_STATEMENT body END END_STATEMENT .)
    IDENTIFIER      reduce using rule 62 (elseif_list -> ELSEIF expr COLON END_STATEMENT body END END_STATEMENT .)
    LPAREN          reduce using rule 62 (elseif_list -> ELSEIF expr COLON END_STATEMENT body END END_STATEMENT .)
    INTEGER         reduce using rule 62 (elseif_list -> ELSEIF expr COLON END_STATEMENT body END END_STATEMENT .)
    DOUBLE          reduce using rule 62 (elseif_list -> ELSEIF expr COLON END_STATEMENT body END END_STATEMENT .)
    RETURN          reduce using rule 62 (elseif_list -> ELSEIF expr COLON END_STATEMENT body END END_STATEMENT .)
    BREAK           reduce using rule 62 (elseif_list -> ELSEIF expr COLON END_STATEMENT body END END_STATEMENT .)
    CONTINUE        reduce using rule 62 (elseif_list -> ELSEIF expr COLON END_STATEMENT body END END_STATEMENT .)
    TRUE            reduce using rule 62 (elseif_list -> ELSEIF expr COLON END_STATEMENT body END END_STATEMENT .)
    FALSE           reduce using rule 62 (elseif_list -> ELSEIF expr COLON END_STATEMENT body END END_STATEMENT .)
    $end            reduce using rule 62 (elseif_list -> ELSEIF expr COLON END_STATEMENT body END END_STATEMENT .)
    END             reduce using rule 62 (elseif_list -> ELSEIF expr COLON END_STATEMENT body END END_STATEMENT .)
    ELSEIF          shift and go to state 112

    elseif_list                    shift and go to state 137

state 137

    (63) elseif_list -> ELSEIF expr COLON END_STATEMENT body END END_STATEMENT elseif_list .

    ELSE            reduce using rule 63 (elseif_list -> ELSEIF expr COLON END_STATEMENT body END END_STATEMENT elseif_list .)
    FUNCTION        reduce using rule 63 (elseif_list -> ELSEIF expr COLON END_STATEMENT body END END_STATEMENT elseif_list .)
    IF              reduce using rule 63 (elseif_list -> ELSEIF expr COLON END_STATEMENT body END END_STATEMENT elseif_list .)
    WHILE           reduce using rule 63 (elseif_list -> ELSEIF expr COLON END_STATEMENT body END END_STATEMENT elseif_list .)
    FOR             reduce using rule 63 (elseif_list -> ELSEIF expr COLON END_STATEMENT body END END_STATEMENT elseif_list .)
    IDENTIFIER      reduce using rule 63 (elseif_list -> ELSEIF expr COLON END_STATEMENT body END END_STATEMENT elseif_list .)
    LPAREN          reduce using rule 63 (elseif_list -> ELSEIF expr COLON END_STATEMENT body END END_STATEMENT elseif_list .)
    INTEGER         reduce using rule 63 (elseif_list -> ELSEIF expr COLON END_STATEMENT body END END_STATEMENT elseif_list .)
    DOUBLE          reduce using rule 63 (elseif_list -> ELSEIF expr COLON END_STATEMENT body END END_STATEMENT elseif_list .)
    RETURN          reduce using rule 63 (elseif_list -> ELSEIF expr COLON END_STATEMENT body END END_STATEMENT elseif_list .)
    BREAK           reduce using rule 63 (elseif_list -> ELSEIF expr COLON END_STATEMENT body END END_STATEMENT elseif_list .)
    CONTINUE        reduce using rule 63 (elseif_list -> ELSEIF expr COLON END_STATEMENT body END END_STATEMENT elseif_list .)
    TRUE            reduce using rule 63 (elseif_list -> ELSEIF expr COLON END_STATEMENT body END END_STATEMENT elseif_list .)
    FALSE           reduce using rule 63 (elseif_list -> ELSEIF expr COLON END_STATEMENT body END END_STATEMENT elseif_list .)
    $end            reduce using rule 63 (elseif_list -> ELSEIF expr COLON END_STATEMENT body END END_STATEMENT elseif_list .)
    END             reduce using rule 63 (elseif_list -> ELSEIF expr COLON END_STATEMENT body END END_STATEMENT elseif_list .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ADD_OP in state 70 resolved as shift
WARNING: shift/reduce conflict for SUB_OP in state 70 resolved as shift
WARNING: shift/reduce conflict for MUL_OP in state 70 resolved as shift
WARNING: shift/reduce conflict for DIV_OP in state 70 resolved as shift
WARNING: shift/reduce conflict for MOD_OP in state 70 resolved as shift
WARNING: shift/reduce conflict for OR in state 70 resolved as shift
WARNING: shift/reduce conflict for AND in state 70 resolved as shift
WARNING: shift/reduce conflict for CEQ in state 70 resolved as shift
WARNING: shift/reduce conflict for CNE in state 70 resolved as shift
WARNING: shift/reduce conflict for CLT in state 70 resolved as shift
WARNING: shift/reduce conflict for CLE in state 70 resolved as shift
WARNING: shift/reduce conflict for CGT in state 70 resolved as shift
WARNING: shift/reduce conflict for CGE in state 70 resolved as shift
WARNING: shift/reduce conflict for ADD_OP in state 71 resolved as shift
WARNING: shift/reduce conflict for SUB_OP in state 71 resolved as shift
WARNING: shift/reduce conflict for MUL_OP in state 71 resolved as shift
WARNING: shift/reduce conflict for DIV_OP in state 71 resolved as shift
WARNING: shift/reduce conflict for MOD_OP in state 71 resolved as shift
WARNING: shift/reduce conflict for OR in state 71 resolved as shift
WARNING: shift/reduce conflict for AND in state 71 resolved as shift
WARNING: shift/reduce conflict for CEQ in state 71 resolved as shift
WARNING: shift/reduce conflict for CNE in state 71 resolved as shift
WARNING: shift/reduce conflict for CLT in state 71 resolved as shift
WARNING: shift/reduce conflict for CLE in state 71 resolved as shift
WARNING: shift/reduce conflict for CGT in state 71 resolved as shift
WARNING: shift/reduce conflict for CGE in state 71 resolved as shift
